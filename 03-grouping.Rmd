```{r setup_aggregation, echo=FALSE}
## global chunk option ##
knitr::opts_chunk$set(echo=TRUE, message=FALSE, fig.width=2.6736, fig.height=2.5, fig.show='hold', results = 'hold') 
```

# Grouping Data

This capter explore manipulating table-like data, summarization and aggregation.

## Sample Data
Sample data used simulate two categorical-alike feature, and two numeric value feature:  

- **dept** is random character between 'D1', 'D2' and 'D3'  
- **grp** is random character with randomly generated 'G1', 'G2'  
- **value1** represents numeric value, normally distributed at mean 50  
- **value2** is numeric value, normally distributed at mean 25  

```{r}
set.seed(1234)
my.df = data.frame(
  dept = paste('D',sample(1:3, 100, replace = T),sep=''),
  grp  = paste('G',sample(1:2, 100, replace = T),sep=''),
  team = paste('T',sample(1:2, 100, replace = T),sep=''),
  value1 = rnorm(1:100, mean = 50, sd = 5),
  value2 = rnorm(1:100, mean = 20, sd = 3),
  value3 = rnorm(1:100, mean = 5, sd = 1),
  stringsAsFactors = F
)
head(my.df)
```

## Grouping Data

This chapter explore multiple methods to group data columns and computes value within groups.

### aggretate - base R

**aggregate** takes in a **list/data.frame**, computes and **output new data.frame**.  
It groups categorical variable(s) and compute value variable(s) based on function FUN.  
FUN can be **min, max, mean, sd, sum or length (frequency count)**.  
**ONLY ONE function** is supported, and it applies to all value variables !!!

#### Basic Syntax (formula method) - data source is data.frame
The formula method use **'data'** parameter and therefore apply for single data source only. The objective is simplicy and without flexibility to customize column names

> **aggregate (data = df, formula, FUN = function)  **  
Formula in the form: **value~categorical**   

> one value variable ~ one categorical variable
```{r}
aggregate (data = my.df, value1 ~ grp, FUN = length)
```

> one value variable ~ multiple categorical variables
```{r}
aggregate (data = my.df, value1 ~ grp + dept, FUN = length)
```

> multiple value variables ~ one categorical variable, **use cbind()**
```{r}
aggregate (data = my.df, cbind(value1,value2) ~ grp, FUN = length)
```

> multiple value variables ~ multiple categorical variable
```{r}
aggregate (data = my.df, cbind(value1,value2) ~ grp + dept, FUN = length)
```

> **ALL** value variables ~ multiple categorical variable, **use dot notation**  
Change from FUN=length to sum results in **error** because sum() cannot be applied to non-numerical variable 'team'
```{r}
aggregate (data = my.df, . ~ grp + dept, FUN = length)
```

#### Advance Syntax (by method) - data source is either list or data.frame

The **advantage** of 'by method' is that it can

- Use list/data.frame subset method to choose column to display, hence flexible  
- customize output column names (list subset method only)  
- Flexible to use multiple data sources, hence **'data' is not used** and has no effect if specified  

> Using **list subseting:** column name is not preserved, hence must specify meaningful column names. If not supplied, generic names and undesirable column names derived from data value will be used as column name  
_**aggregate (x = list(...value_variables...), by = list(...categorical_variables...), FUN = function)**_


```{r}
aggregate (x =  list( v1_mean = my.df$value1, my.df$value2 ), 
           by = list( my.df$grp, DEPT = my.df$dept), FUN=mean)
```

> Using **data.frame subseting:** column names are preserved and no option to change. Notice attempt below to change the column name does not succeed  
_***aggregate( x = df[,c(...)], by = df[,c(...)]), FUN = function) ***_  
_***aggregate( x = df[, p:q], by = df[,s:t]), FUN = function) ***_
```{r}
aggregate(x=my.df[, c(v1_mean='value1', 'value2')], by=my.df[,c(GRP='grp', 'dept')], FUN=mean)
# aggregate(x = my.df[, 4:5], by = my.df[, 1:2], FUN = mean) # produce similar result as above
```


### group_by - dplyr Package


