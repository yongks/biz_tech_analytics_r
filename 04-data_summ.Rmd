```{r setup_aggregation, echo=FALSE}
## global chunk option ##
knitr::opts_chunk$set(echo=TRUE, message=FALSE, fig.width=2.6736, fig.height=2.5, fig.show='hold', results='markup') 
```


# Data Summarization

## Library

|   | Package              | Function      | Purpose                                             |
|---|----------------------|---------------|-----------------------------------------------------|
| 1 | Base R               | table         | Generate frequency table                            |
|   |                      | ftable        | Generate flat table                                 |
|   |                      | prop.table    | Generate probability table out from table or ftable |
|   |                      | addmargins    | Add margin to table or ftable                       |
|   |                      | tapply        | Produce aggregation with one level of grouping      |
|   |                      | aggregate     |       |

| 2 | dplyr                | select        | select the columns                                 |
|   |                      | filter        | filter rows based on criteria                      |
|   |                      | group_by      | create a tiblle table with group columns           |
|   |                      | ungroup       | remvoe group columns                               |
|   |                      | summarize     | specify the columns and functions to summarize     |
|   |                      | summarize_at  | specify the columns to be summarized               |
|   |                      | summarize_if  | conditionally choose the columns to be summarized  |
|   |                      | summarize_all | summarize all columns, be it numeric or not        |
|   |                      | count         | group and count the number of rows within each group |
|   |                      | arrange       | in-group sorting of rows |
|   |                      | slice         | in-group row selection   |
|   |                      | mutate        | create a new column      |

| 3 | tidyr                | gather        | Gather columns into rows |
|   |                      | spread        | Reverse of gather()      |
|   |                      | seperate      | Seperate one column into multiple columns |
|   |                      | unite         | Reverse of seperate()    |

```{r}
library(dplyr)
library(tidyr)
```

## Sample Data
Sample data used simulate two categorical-alike feature, and two numeric value feature:  

- **dept** is random character between 'D1', 'D2' and 'D3'  
- **grp** is random character with randomly generated 'G1', 'G2'  
- **value1** represents numeric value, normally distributed at mean 50  
- **value2** is numeric value, normally distributed at mean 25  

```{r}
set.seed(1234)
my.df = data.frame(
  com  = paste('C',sample(1:2, 100, replace = T),sep=''),
  dept = paste('D',sample(1:3, 100, replace = T),sep=''),
  grp  = paste('G',sample(1:2, 100, replace = T),sep=''),
  team = paste('T',sample(1:2, 100, replace = T),sep=''),
  prd  = paste('P',sample(1:5, 100, replace = T),sep=''),
  value1 = rnorm(1:100, mean = 50, sd = 5),
  value2 = rnorm(1:100, mean = 20, sd = 3),
  value3 = rnorm(1:100, mean =  5, sd = 1),
  stringsAsFactors = F
)
head(my.df)
str(my.df)
```

## Frequency Table

`table` return table object (which is also array) that report frequency count base of categorical-alike data provided.  

`table` has the below data type characteristics. Note that only 2-dimensional table object is a matrix 

| Dimension | is.atomic | is.vector | is.matrix | is.array | is.table |
|:---------:|:---------:|:---------:|:---------:|:--------:|:--------:|
| t1        |     T     |     F     |     F     |     T    |     T    |
| t2        |     T     |     F     |     T     |     T    |     T    |
| t3        |     T     |     F     |     F     |     T    |     T    |
| t4        |     T     |     F     |     F     |     T    |     T    |

`ftable` is technically a **matrix** with two dimensional data (it flatten multiple dimension data). It has below data type characteristic.

| Dimension | is.atomic | is.vector | is.matrix | is.array | is.table |
|:---------:|:---------:|:---------:|:---------:|:--------:|:--------:|
| 1         |     T     |     F     |     T     |     T    |     F    |
| 2         |     T     |     F     |     T     |     T    |     F    |
| 3         |     T     |     F     |     T     |     T    |     F    |
| 4         |     T     |     F     |     T     |     T    |     F    |

### Single Dimension Data
```{r results='markup'}
t1 = table( my.df$com )
t1
str(t1)
```

### Two Dimension Data
```{r results='markup'}
t2 = table( my.df$com, my.df$dept )
t2
str(t2)
```

### Three Dimension Data
When table contain three or more dimension, use `ftable (flat table)` to put multi dimension table into one flat output
```{r results='markup'}
t3 = table( my.df$com, my.df$dept, my.df$grp )
t3
str(t3)
f3 = ftable( t3 )
f3
str(f3)
```

### Four Dimension Data
When table contain three or more dimension, use `ftable (flat table)` to put multi dimension table into one flat output
```{r results='markup', class.source='bg-success', class.output='bg-info'}
t4 = table( my.df$com, my.df$dept, my.df$grp, my.df$team )
t4
str(t4)
f4 = ftable( t4 )
f4
str(f4)
```

### Making Table Proportion

`prop.table` **converts** `table` or `ftable` object into proportion. It can calculate table-wise, column-wise or row-wise proportion.  

> prop.table (x,margin=NULL)  
> $\quad$ x = table object  
> $\quad$ margin = NULL: proportion table-wise, 1-row_wise, 2-column_wise  

#### Proportion Table on 'table' object  

```{r results='markup'}
prop.table( t1 )
prop.table( t2 )
prop.table( t2, margin=1 )
prop.table( t2, margin=2 )
```

#### Proportion Table on 'ftable' object  

```{r results='markup'}
prop.table( f3 )
prop.table( f4 )

prop.table( f3, margin=1 )
prop.table( f4, margin=1 )

prop.table( f3, margin=2 )
prop.table( f4, margin=2 )
```

### Adding Margin Info To Table

> addmargins (x, margin=NULL)  
> $\quad$ x = table or ftable object  
> $\quad$ margin = NULL: row and column-sum, 1-col_sum, 2-row_sum  

#### Margin Info on 'table' object
```{r results='markup'}
addmargins( t2)
addmargins( t2,margin=1 )
addmargins( t2,margin=2 )
addmargins( t3 )
addmargins( t4 )
```

#### Margin Info on 'ftable' object
```{r results='markup'}
addmargins( f3 )
addmargins( f4 )
```

### Proportion Table with Margin

First to obtain the proportion table, then only add the margin.  

```{r results='markup'}
addmargins( prop.table( t2 ))    # add both column and row margin
addmargins( prop.table( t2 ), 1) # add column margin
addmargins( prop.table( t2 ), 2) # add row margin
addmargins( prop.table( t3 ))
addmargins( prop.table( t4 ))
```

```{r results='markup'}
addmargins( prop.table( f3 ))
addmargins( prop.table( f4 ))
```

## Data Aggregation

This chapter explore multiple methods to group data columns and computes value within groups:  

1. tapply
2. aggregate (10x slower than apply)
3. dplyr and tidyr, a much intuitive tools

### tapply

`tapply` is quick and fast way to produce aggregation with **ONE level of grouping**.   

> **`tapply ( X, INDEX, FUN, na.rm = FALSE )`**  
> $\quad$ ` X = value vector`  
> $\quad$ ` INDEX = vector of groups data (can be factor, number or string)`  
> $\quad$ ` FUN = function to apply on X, according to group specified in INDEX`  
> $\quad$ ` na.rm = ignore <NA> values`  

- `X` and `INDEX` must have the same length  
- `tapply` will divide the value vector (X) into groups (base on INDEX), and perform computation (FUN) on each group  
- If there are **`<NA>`** in the vector X, some FUN may fail to return value, such as mean, sum.  So it is essential to specify **`na.rm = TRUE`** in these cases  
- Group identifier will be used as column name (accessible through **`names()`**)  

#### FUN That Returns Vector 

```{r results='markup'}
t1 = tapply(my.df$value1, my.df$com, FUN=mean)
t1
names( t1 )
```

#### FUN That Returns Non-Vector -  output is list

```{r results='markup'}
t2 = tapply(my.df$value1, my.df$com, FUN=summary)
t2
names( t2 )
```


### aggretate - base R

**Aggregate** is a very useful base R function and provides quick way to group data and values:  

- Input in **list/data.frame**, computes and **output new data.frame**.  
- It groups categorical variable(s) and compute value variable(s) based on function FUN.  
- FUN can be **min, max, mean, sd, sum or length (frequency count)**.  
- **ONLY ONE function** is supported, and it applies to all value variables !!!

#### Basic Syntax (formula method) - data source is data.frame
The **formula method** use **'data'** parameter and therefore apply for single data source only. The objective is simplicy and without flexibility to customize column names

> **`aggregate (data = df, formula, FUN = function)  `**  
> $\quad$ Formula in the form: **value~categorical**   

#### One value variable ~ one categorical variable
```{r}
aggregate (data = my.df, value1 ~ grp, FUN = length)
```

#### One value variable ~ multiple categorical variables
```{r}
aggregate (data = my.df, value1 ~ grp + dept, FUN = length)
```

#### Multiple value variables ~ one categorical variable, use cbind()
```{r}
aggregate (data = my.df, cbind(value1,value2) ~ grp, FUN = length)
```

#### multiple value variables ~ multiple categorical variable
```{r}
aggregate (data = my.df, cbind(value1,value2) ~ grp + dept, FUN = length)
```

#### ALL value variables ~ multiple categorical variable, use dot notation
Change from FUN=length to sum results in **error** because sum() cannot be applied to non-numerical variable 'team'
```{r}
aggregate (data = my.df, . ~ grp + dept, FUN = length)
```

#### Advance Syntax (by method) - data source is either list or data.frame

The **advantage** of '**by method'** are:

- Can use list/data.frame subset method to choose column to display, hence flexible  
- Can customize output column names (list subset method only)  
- Flexibility to use multiple data sources, hence **'data' is not used** and has no effect if specified  

> Using **list subseting:** column name is not preserved, hence must specify meaningful column names. If not supplied, generic names and undesirable column names derived from data value will be used as column name  
_**aggregate (x = list(...value_variables...), by = list(...categorical_variables...), FUN = function)**_


```{r}
aggregate (x =  list( v1_mean = my.df$value1, my.df$value2 ), 
           by = list( my.df$grp, DEPT = my.df$dept), FUN=mean)
```

> Using **data.frame subseting:** column names are preserved and no option to change. Notice attempt below to change the column name does not succeed  
_***aggregate( x = df[,c(...)], by = df[,c(...)]), FUN = function) ***_  
_***aggregate( x = df[, p:q], by = df[,s:t]), FUN = function) ***_
```{r}
aggregate(x=my.df[, c(v1_mean='value1', 'value2')], by=my.df[,c(GRP='grp', 'dept')], FUN=mean)
# aggregate(x = my.df[, 4:5], by = my.df[, 1:2], FUN = mean) # produce similar result as above
```

## dplyr

### Grouping
- Gourping returns all rows, with **internal grouping structure**  
- Display of tibble rows **truncates automatically** if too many rows. Use `print(tbl_df(my.tbl), n=40)` to display more rows (quite troublesome, but look at all the other benefits)  
- The internal grouping structure can be used for many types of summarization (discussed below)  
- To get the row numbers for each group, add additional column with **mutate** of **row_number()**  
```{r}
d.df = my.df %>%
  group_by(com,dept, grp) %>%
  mutate( idx = row_number()) %>% 
  arrange( com,dept,grp)

print(tbl_df(d.df),n=18)
```
Verify group levels in `attr(*, "vars")`
```{r}
attr(d.df, 'vars')
```

### Counting
**`count()`** groups and provide additional column **`n`**, which counts the number of rows within the group.  
```{r}
d.df = my.df %>%
  count(com, dept, prd)

d.df

# alternative long methods for similar result
# my.df %>%
#   group_by(com, dept, prd) %>%
#   summarize(count = n())
```
Similar to **`summarize`**, counting reduce grouping level by one.  
```{r, collapse=T}
### count() reduce group level by one, 'prd' is removed from grouping
attr(d.df, 'vars')

```

### In-Group Row Numbering
- Summarize reduce group level by one, hence n() will return the rows within the new group.  
- Example below group with three levels (com, dept,prd), however, after summarize, n() returns the number of rows within (com,dept) group.  
```{r}
d.df = my.df %>%
  group_by(com,dept,prd) %>%
  summarize(avg.value1=mean(value1)) %>%
  mutate (c = 1:n())

d.df
```

### In-Group Row Selection
Example below select highest occurance of  **prd** within the group of (com,dept).  It is based on the principe that count reduce group levels by one, then selection is based on rows within the new group.  
```{r}
my.df %>%
  count(com, dept, prd) %>% 
  slice(which.max(n))
```

### In-Group Summarization

#### Summarize Specific Columns, Mix Functions
Many functions can be applied that returns a single value, to be assigned as new column.
```{r}
d.df = my.df %>%
  group_by(com, dept, prd) %>%
  summarise( avg_value1 = mean(value1),
             min_value2 = min(value2),
             max_value3 = max(value3),
             n.team = n_distinct(team),
             count = n())

d.df
```

#### Summarize Specific Columns, with Single Function  
```{r}
my.df %>%
  group_by(com, dept, prd) %>%
  summarise_at(c('value2', 'value3'), mean)
```

#### Summarize All Columns, with Single Function  
Notice that each column whin the group will be summarized with one more functions. This includes columns which are NOT numeric, resulting warnings and NA.  
```{r, warning=F}
my.df %>%
  group_by(com, dept, prd) %>%
  summarise_all(mean)
```

#### Summarize Specified Columns, with Single Function
```{r}
my.df %>%
  group_by(com, dept, prd) %>%
  summarise_at(c('value2','value3'),mean)
```

#### Summarize Series of Columns, with Single Function
Use **`vars()`** to select the sequence of variable names in colon **`:`**  
```{r}
my.df %>%
  group_by(com, dept, prd) %>%
  summarise_at(vars(value1:value3),mean)
```

#### Summarize Numeric Columns, with Single Function
```{r}
my.df %>%
  group_by(com, dept, prd) %>%
  summarise_if(is.numeric,mean)
```

#### Summarize with Multiple Functions
Any of the above summarize can combine with  **`funs()`** to specify multiple functions.  
```{r}
my.df %>%
  group_by(com, dept, prd) %>%
  summarise_if(is.numeric, funs(mean,sd))
```

#### Summarize Reduce The Grouping Level by One
```{r}
### result in grouping of (com, dept), 'prd' has been removed from grouping
attr(d.df, 'vars')
```


## R with SQL Emulation

Running SQL statement on existing data.frame are useful to derive summarization and aggregation for someone who are familiar with SQL.  

### Library

**sqldf** library is required.  It has dependency on gsubfn, proto and RSQLite packages.  

```{r}
library(sqldf)
```

### Run The Code

R data.frame variable is specified in **'FROM'** clause.  
Note that `.` is a SQL operator, any variable with '.' must be contained within **single quote**.  

```{r}
sqldf("
  SELECT com, dept, count(*) AS qty, AVG(value1) AS v1_mean, SUM(value2) AS v2_sum
  FROM 'my.df'  
  GROUP BY com, dept
")
```
