# Data Preprocessing

## Sample Data

```{r results='markup'}
sample.df <- read.csv ( file="./datasets/import_sample.csv", 
    na.strings=c('NA','NULL',''),
    encoding="UTF-8")
sample.df
str(sample.df)
```
## Duplicate and Deleting Columns

### Duplicating columns

Duplicate single column using `$` selector  

```{r}
sample.df$Z = sample.df$X
str(sample.df)
```

### Delete Columns

Delete **single column** using `$` column selector, setting to NULL.  

```{r}
sample.df$Z = NULL
```

**Delete multiple columns** using multiple columns selector `[,vector]`, with vector containing column numbers or names, setting to NULL.  

```{r}
sample.df[,c('X','date_string')] = NULL
str(sample.df)
```

## Renaming Columns

**colnames** returns vector of names attribute of data.frame.  

```{r, results='hold'}
attributes(sample.df)
colnames(sample.df)
```

Use **colnames** to rename one or multiple columns. Use `[]` to select the specific column(s).  

```{r, results='hold'}
colnames(sample.df)[c(1,6)] = c('id','date_my')
str(sample.df)
```

## Data Conversion

### Date and String Conversion

By default when importing string into data frame, they are converted to factor (stringAsFactor=TRUE). It is usually desirable to convert back to its original format such as string and date.  

**Before Conversion**, except for numeric data, notice all string and date columns are imported as factor.  

```{r}
str(sample.df)
```

**as.Date** can convert vector into `date` data type. The original data must have a **format** that allow as.Date to recognize it.  

**as.character** will convert vector to `chr`.  

```{r results='markup'}
sample.df$id      = as.character(sample.df$id)
sample.df$date_uk = as.Date(sample.df$date_uk, "%d/%m/%Y")
sample.df$date_my = as.Date(sample.df$date_uk, "%Y-%m-%d")
str(sample.df)
sample.df
```


## String Extraction




## Artificial Grouping

Artificial group can be created based on existing numeric data.  Such as age_group based on age.  

### Grouping with Numeric Breakpoints

Simulate data with x,y,z variables. p simulates priority scoring.  

```{r}
x = rnorm(10, mean = 10)
y = rnorm(10, mean = 10)
p = x * y
```

Articial groups is created first by identifying the **number of groups**, generate the break points vector, then **cut** the data base on **break points** and return **factor** as output.  

Automatically calculate breakpoints by distributing numbers into the min-max range, in low to high order:  

```{r, results='markup'}
num_groups = 4
breakPoints = seq(min(p), max(p), length.out = num_groups + 1)
breakPoints
```

> `cut ( x, breaks, right = TRUE, include.lowest = FALSE)`  
> $\quad$ `x: numeric vector to be cutted`   
> $\quad$ `breaks: numeric vector ranging from low to high (in order)`  
> $\quad$ `include.lowest: FALSE - ommit element matching lowest number in breaks`  
> $\quad$ `right: TRUE - close end on right;open end on left`  

The result from **cut** is factor based on order from breakPoints. Therefore, once convert into numeric, the group number is in order of low to high accoriding to breakPoints.  

Verify that group (g) has been assigned for each priority (p).    

```{r}
g = as.numeric( cut( p, breakPoints, include.lowest=TRUE))
data.frame(p,g)
```

### Grouping based on Custom Criteria

???

## Handling Missing Data

### Detecting Missing Data

### Removing Missing Data


## Scaling Data

### Sample Data

Scaling section will use sample data generated as below:  
```{r}
set.seed(1234)
my.df = data.frame(
  id = paste('ID_', 1:5, sep = ''),
  value1 = sample(50:100, 5),
  value2 = sample(10:50, 5),
  stringsAsFactors = F
)
my.df
```

### Z-Score Scaling

`scale` apply transformation **column-wise**, for  columns within matrix or dataframe  
`scale` return a **matrix**  

>`scale (x, center=T, scale=T)`  # default S-Score transformation  
>$\quad$ `center = T (default) means value minus with mean`  
>$\quad$ `scale  = T (default) means value divide by sd`  
>$\quad$ $\quad$ `output scaled:center --> mean`  
>$\quad$ $\quad$ `output scaled:scale  --> sd`  

```{r results='markdown'}
scale( my.df[,2:3] )
scale( my.df[,2:3], scale=F )
```

### Min Max Scaling

Min-Max scaling will transform all numbers between 0 and 1.  
Easiest way to perform this transformation is to write a function then `apply`.  

```{r}
min_max = function(x){(x-min(x))/(max(x)-min(x))}
apply( my.df[,2:3], MARGIN = 2, FUN = min_max )  ## 2 means column-wise
```


