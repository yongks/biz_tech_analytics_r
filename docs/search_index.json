[
["4-data-summarization.html", "Chapter 4 Data Summarization ", " Chapter 4 Data Summarization "],
["4-1-library-2.html", "4.1 Library", " 4.1 Library Package Function Purpose 1 Base R table Generate frequency table ftable Generate flat table prop.table Generate probability table out from table or ftable addmargins Add margin to table or ftable tapply Produce aggregation with one level of grouping aggregate 2 dplyr select select the columns filter filter rows based on criteria arrange sorting of rows distinct unique rows only slice row selection group_by create a tiblle table with group columns ungroup remvoe group columns summarize in-group: specify the columns and functions to summarize summarize_at in-group: specify the columns to be summarized summarize_if in-group: conditionally choose the columns to be summarized summarize_all in-group: summarize all columns, be it numeric or not top_n in-group: highest n rows row_number in-group: automatic row numbering n in-group: total number of rows tally short hand for summarize(n()) count short hand for group_by and tally 3 tidyr gather Gather columns into rows spread Reverse of gather() seperate Seperate one column into multiple columns unite Reverse of seperate() "],
["4-2-sample-data-2.html", "4.2 Sample Data", " 4.2 Sample Data Sample data used simulate two categorical-alike feature, and two numeric value feature: dept is random character between ‘D1’, ‘D2’ and ‘D3’ grp is random character with randomly generated ‘G1’, ‘G2’ value1 represents numeric value, normally distributed at mean 50 value2 is numeric value, normally distributed at mean 25 set.seed(1234) my.df = data.frame( com = paste(&#39;C&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), dept = paste(&#39;D&#39;,sample(1:3, 100, replace = T),sep=&#39;&#39;), grp = paste(&#39;G&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), team = paste(&#39;T&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), prd = paste(&#39;P&#39;,sample(1:5, 100, replace = T),sep=&#39;&#39;), value1 = rnorm(1:100, mean = 50, sd = 5), value2 = rnorm(1:100, mean = 20, sd = 3), value3 = rnorm(1:100, mean = 5, sd = 1), stringsAsFactors = F ) head(my.df) ## com dept grp team prd value1 value2 value3 ## 1 C1 D1 G2 T1 P4 52.18465 13.05189 5.362667 ## 2 C2 D2 G2 T2 P3 55.30062 21.68742 6.411405 ## 3 C2 D1 G1 T2 P4 52.26095 17.64867 6.367544 ## 4 C2 D1 G2 T1 P4 53.31599 19.32184 4.592824 ## 5 C2 D1 G2 T2 P3 44.31813 15.23869 5.762542 ## 6 C2 D1 G2 T1 P1 48.14751 21.64257 4.348799 str(my.df) ## &#39;data.frame&#39;: 100 obs. of 8 variables: ## $ com : chr &quot;C1&quot; &quot;C2&quot; &quot;C2&quot; &quot;C2&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D2&quot; &quot;D1&quot; &quot;D1&quot; ... ## $ grp : chr &quot;G2&quot; &quot;G2&quot; &quot;G1&quot; &quot;G2&quot; ... ## $ team : chr &quot;T1&quot; &quot;T2&quot; &quot;T2&quot; &quot;T1&quot; ... ## $ prd : chr &quot;P4&quot; &quot;P3&quot; &quot;P4&quot; &quot;P4&quot; ... ## $ value1: num 52.2 55.3 52.3 53.3 44.3 ... ## $ value2: num 13.1 21.7 17.6 19.3 15.2 ... ## $ value3: num 5.36 6.41 6.37 4.59 5.76 ... "],
["4-3-frequency-table.html", "4.3 Frequency Table", " 4.3 Frequency Table table return table object (which is also array) that report frequency count base of categorical-alike data provided. table has the below data type characteristics. Note that only 2-dimensional table object is a matrix Dimension is.atomic is.vector is.matrix is.array is.table 1 T F F T T 2 T F T T T 3 T F F T T 4 T F F T T ftable is technically a matrix with two dimensional data (it flatten multiple dimension data). It has below data type characteristic. Dimension is.atomic is.vector is.matrix is.array is.table 1 T F T T F 2 T F T T F 3 T F T T F 4 T F T T F 4.3.1 Single Dimension Data 4.3.1.1 Base R Supply table(x) where x is a factor. If x is not factor, it will be coerce to factor The result is 1-D with frequency count as number, and each category as names t1 = table( my.df$com ) t1 ## ## C1 C2 ## 55 45 names(t1) ## [1] &quot;C1&quot; &quot;C2&quot; is.array(t1) ## [1] TRUE 4.3.1.2 dplyr my.df %&gt;% group_by(com) %&gt;% summarize(n()) my.df %&gt;% group_by(com) %&gt;% tally # tally is wrapper for summarize(n()) my.df %&gt;% count(com) # count is a wrapper for group_by and tally ## # A tibble: 2 x 2 ## com `n()` ## &lt;chr&gt; &lt;int&gt; ## 1 C1 55 ## 2 C2 45 ## # A tibble: 2 x 2 ## com n ## &lt;chr&gt; &lt;int&gt; ## 1 C1 55 ## 2 C2 45 ## # A tibble: 2 x 2 ## com n ## &lt;chr&gt; &lt;int&gt; ## 1 C1 55 ## 2 C2 45 4.3.2 Two Dimension Data 4.3.2.1 Base R Supply table(x,y) where x,y are factors. If x,y is not factor, it will be coerce to factor Frequency table for two dimensional variables is a 2-D matrix/array t2 = table( my.df$com, my.df$dept ) t2 is.matrix(t2) dim(t2) colnames(t2) rownames(t2) ## ## D1 D2 D3 ## C1 16 18 21 ## C2 15 18 12 ## [1] TRUE ## [1] 2 3 ## [1] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## [1] &quot;C1&quot; &quot;C2&quot; 4.3.2.2 dplyr with tidyr Supply dplyr::group_by with two dimensional variables. Note that count() is a short form for group_by() and summarize(). However, it is not possibel to rename column n using count() my.df %&gt;% group_by(com,dept) %&gt;% tally ## # A tibble: 6 x 3 ## # Groups: com [?] ## com dept n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 16 ## 2 C1 D2 18 ## 3 C1 D3 21 ## 4 C2 D1 15 ## 5 C2 D2 18 ## 6 C2 D3 12 my.df %&gt;% count(com,dept) # count is wrapper for group_by and tally ## # A tibble: 6 x 3 ## com dept n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 16 ## 2 C1 D2 18 ## 3 C1 D3 21 ## 4 C2 D1 15 ## 5 C2 D2 18 ## 6 C2 D3 12 my.df %&gt;% count(com,dept) %&gt;% spread(dept,n) # spread com into column ## # A tibble: 2 x 4 ## com D1 D2 D3 ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 C1 16 18 21 ## 2 C2 15 18 12 4.3.3 Three Dimension Data 4.3.3.1 Base R 3-D frequency table is a 3-D array. For3-D table, 2-D table is presented for each 3rd dimension data t3 = table( my.df$com, my.df$dept, my.df$grp ) #last dimension is grp dim(t3) ## [1] 2 3 2 t3 ## , , = G1 ## ## ## D1 D2 D3 ## C1 10 7 11 ## C2 7 9 4 ## ## , , = G2 ## ## ## D1 D2 D3 ## C1 6 11 10 ## C2 8 9 8 rownames(t3) ## [1] &quot;C1&quot; &quot;C2&quot; colnames(t3) ## [1] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; Alternatively, use ftable() to flatten 3-D table above. Last dimension is always presented at column f3 = ftable( t3 ) f3 ## G1 G2 ## ## C1 D1 10 6 ## D2 7 11 ## D3 11 10 ## C2 D1 7 8 ## D2 9 9 ## D3 4 8 str(f3) ## &#39;ftable&#39; int [1:6, 1:2] 10 7 11 7 9 4 6 11 10 8 ... ## - attr(*, &quot;row.vars&quot;)=List of 2 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## - attr(*, &quot;col.vars&quot;)=List of 1 ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; 4.3.3.2 dplyr The result of dplyr on multi-level of grouping is similar to flatten table using ftable() my.df %&gt;% group_by(com, dept, grp ) %&gt;% tally ## # A tibble: 12 x 4 ## # Groups: com, dept [?] ## com dept grp n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 G1 10 ## 2 C1 D1 G2 6 ## 3 C1 D2 G1 7 ## 4 C1 D2 G2 11 ## 5 C1 D3 G1 11 ## 6 C1 D3 G2 10 ## 7 C2 D1 G1 7 ## 8 C2 D1 G2 8 ## 9 C2 D2 G1 9 ## 10 C2 D2 G2 9 ## 11 C2 D3 G1 4 ## 12 C2 D3 G2 8 my.df %&gt;% group_by(com, dept, grp ) %&gt;% tally %&gt;% spread(grp,n) ## # A tibble: 6 x 4 ## # Groups: com, dept [6] ## com dept G1 G2 ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 C1 D1 10 6 ## 2 C1 D2 7 11 ## 3 C1 D3 11 10 ## 4 C2 D1 7 8 ## 5 C2 D2 9 9 ## 6 C2 D3 4 8 4.3.4 Four Dimension Data When table contain three or more dimension, use ftable (flat table) to put multi dimension table into one flat output. Last dimension is always presented at column t4 = table( my.df$com, my.df$dept, my.df$grp, my.df$team ) # last dimension is team f4 = ftable( t4 ) f4 ## T1 T2 ## ## C1 D1 G1 4 6 ## G2 3 3 ## D2 G1 5 2 ## G2 6 5 ## D3 G1 4 7 ## G2 6 4 ## C2 D1 G1 4 3 ## G2 5 3 ## D2 G1 5 4 ## G2 5 4 ## D3 G1 1 3 ## G2 4 4 4.3.4.1 dplyr The result of dplyr on multi-level of grouping is similar to flatten table using ftable() my.df %&gt;% group_by(com, dept, grp, team ) %&gt;% summarize(freq=n()) ## # A tibble: 24 x 5 ## # Groups: com, dept, grp [?] ## com dept grp team freq ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 G1 T1 4 ## 2 C1 D1 G1 T2 6 ## 3 C1 D1 G2 T1 3 ## 4 C1 D1 G2 T2 3 ## 5 C1 D2 G1 T1 5 ## 6 C1 D2 G1 T2 2 ## 7 C1 D2 G2 T1 6 ## 8 C1 D2 G2 T2 5 ## 9 C1 D3 G1 T1 4 ## 10 C1 D3 G1 T2 7 ## # ... with 14 more rows 4.3.5 Making Table Proportion prop.table converts table or ftable object into proportion. It can calculate table-wise, column-wise or row-wise proportion. prop.table (x,margin=NULL) \\(\\quad\\) x = table object \\(\\quad\\) margin = NULL: proportion table-wise, 1-row_wise, 2-column_wise 4.3.5.1 Proportion Table on ‘table’ object prop.table( t1 ) ## ## C1 C2 ## 0.55 0.45 prop.table( t2 ) ## ## D1 D2 D3 ## C1 0.16 0.18 0.21 ## C2 0.15 0.18 0.12 prop.table( t2, margin=1 ) ## ## D1 D2 D3 ## C1 0.2909091 0.3272727 0.3818182 ## C2 0.3333333 0.4000000 0.2666667 prop.table( t2, margin=2 ) ## ## D1 D2 D3 ## C1 0.5161290 0.5000000 0.6363636 ## C2 0.4838710 0.5000000 0.3636364 4.3.5.2 Proportion Table on ‘ftable’ object prop.table( f3 ) ## G1 G2 ## ## C1 D1 0.10 0.06 ## D2 0.07 0.11 ## D3 0.11 0.10 ## C2 D1 0.07 0.08 ## D2 0.09 0.09 ## D3 0.04 0.08 prop.table( f4 ) ## T1 T2 ## ## C1 D1 G1 0.04 0.06 ## G2 0.03 0.03 ## D2 G1 0.05 0.02 ## G2 0.06 0.05 ## D3 G1 0.04 0.07 ## G2 0.06 0.04 ## C2 D1 G1 0.04 0.03 ## G2 0.05 0.03 ## D2 G1 0.05 0.04 ## G2 0.05 0.04 ## D3 G1 0.01 0.03 ## G2 0.04 0.04 prop.table( f3, margin=1 ) ## G1 G2 ## ## C1 D1 0.6250000 0.3750000 ## D2 0.3888889 0.6111111 ## D3 0.5238095 0.4761905 ## C2 D1 0.4666667 0.5333333 ## D2 0.5000000 0.5000000 ## D3 0.3333333 0.6666667 prop.table( f4, margin=1 ) ## T1 T2 ## ## C1 D1 G1 0.4000000 0.6000000 ## G2 0.5000000 0.5000000 ## D2 G1 0.7142857 0.2857143 ## G2 0.5454545 0.4545455 ## D3 G1 0.3636364 0.6363636 ## G2 0.6000000 0.4000000 ## C2 D1 G1 0.5714286 0.4285714 ## G2 0.6250000 0.3750000 ## D2 G1 0.5555556 0.4444444 ## G2 0.5555556 0.4444444 ## D3 G1 0.2500000 0.7500000 ## G2 0.5000000 0.5000000 prop.table( f3, margin=2 ) ## G1 G2 ## ## C1 D1 0.20833333 0.11538462 ## D2 0.14583333 0.21153846 ## D3 0.22916667 0.19230769 ## C2 D1 0.14583333 0.15384615 ## D2 0.18750000 0.17307692 ## D3 0.08333333 0.15384615 prop.table( f4, margin=2 ) ## T1 T2 ## ## C1 D1 G1 0.07692308 0.12500000 ## G2 0.05769231 0.06250000 ## D2 G1 0.09615385 0.04166667 ## G2 0.11538462 0.10416667 ## D3 G1 0.07692308 0.14583333 ## G2 0.11538462 0.08333333 ## C2 D1 G1 0.07692308 0.06250000 ## G2 0.09615385 0.06250000 ## D2 G1 0.09615385 0.08333333 ## G2 0.09615385 0.08333333 ## D3 G1 0.01923077 0.06250000 ## G2 0.07692308 0.08333333 4.3.6 Adding Margin Info To Table addmargins (x, margin=NULL) \\(\\quad\\) x = table or ftable object \\(\\quad\\) margin = NULL: row and column-sum, 1-col_sum, 2-row_sum 4.3.6.1 Margin Info on ‘table’ object addmargins( t2) ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 addmargins( t2,margin=1 ) ## ## D1 D2 D3 ## C1 16 18 21 ## C2 15 18 12 ## Sum 31 36 33 addmargins( t2,margin=2 ) ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 addmargins( t3 ) ## , , = G1 ## ## ## D1 D2 D3 Sum ## C1 10 7 11 28 ## C2 7 9 4 20 ## Sum 17 16 15 48 ## ## , , = G2 ## ## ## D1 D2 D3 Sum ## C1 6 11 10 27 ## C2 8 9 8 25 ## Sum 14 20 18 52 ## ## , , = Sum ## ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 addmargins( t4 ) ## , , = G1, = T1 ## ## ## D1 D2 D3 Sum ## C1 4 5 4 13 ## C2 4 5 1 10 ## Sum 8 10 5 23 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 Sum ## C1 3 6 6 15 ## C2 5 5 4 14 ## Sum 8 11 10 29 ## ## , , = Sum, = T1 ## ## ## D1 D2 D3 Sum ## C1 7 11 10 28 ## C2 9 10 5 24 ## Sum 16 21 15 52 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 Sum ## C1 6 2 7 15 ## C2 3 4 3 10 ## Sum 9 6 10 25 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 Sum ## C1 3 5 4 12 ## C2 3 4 4 11 ## Sum 6 9 8 23 ## ## , , = Sum, = T2 ## ## ## D1 D2 D3 Sum ## C1 9 7 11 27 ## C2 6 8 7 21 ## Sum 15 15 18 48 ## ## , , = G1, = Sum ## ## ## D1 D2 D3 Sum ## C1 10 7 11 28 ## C2 7 9 4 20 ## Sum 17 16 15 48 ## ## , , = G2, = Sum ## ## ## D1 D2 D3 Sum ## C1 6 11 10 27 ## C2 8 9 8 25 ## Sum 14 20 18 52 ## ## , , = Sum, = Sum ## ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 4.3.6.2 Margin Info on ‘ftable’ object addmargins( f3 ) ## Sum ## 10 6 16 ## 7 11 18 ## 11 10 21 ## 7 8 15 ## 9 9 18 ## 4 8 12 ## Sum 48 52 100 addmargins( f4 ) ## Sum ## 4 6 10 ## 3 3 6 ## 5 2 7 ## 6 5 11 ## 4 7 11 ## 6 4 10 ## 4 3 7 ## 5 3 8 ## 5 4 9 ## 5 4 9 ## 1 3 4 ## 4 4 8 ## Sum 52 48 100 4.3.7 Proportion Table with Margin First to obtain the proportion table, then only add the margin. addmargins( prop.table( t2 )) # add both column and row margin ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( t2 ), 1) # add column margin ## ## D1 D2 D3 ## C1 0.16 0.18 0.21 ## C2 0.15 0.18 0.12 ## Sum 0.31 0.36 0.33 addmargins( prop.table( t2 ), 2) # add row margin ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 addmargins( prop.table( t3 )) ## , , = G1 ## ## ## D1 D2 D3 Sum ## C1 0.10 0.07 0.11 0.28 ## C2 0.07 0.09 0.04 0.20 ## Sum 0.17 0.16 0.15 0.48 ## ## , , = G2 ## ## ## D1 D2 D3 Sum ## C1 0.06 0.11 0.10 0.27 ## C2 0.08 0.09 0.08 0.25 ## Sum 0.14 0.20 0.18 0.52 ## ## , , = Sum ## ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( t4 )) ## , , = G1, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.04 0.05 0.04 0.13 ## C2 0.04 0.05 0.01 0.10 ## Sum 0.08 0.10 0.05 0.23 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.03 0.06 0.06 0.15 ## C2 0.05 0.05 0.04 0.14 ## Sum 0.08 0.11 0.10 0.29 ## ## , , = Sum, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.07 0.11 0.10 0.28 ## C2 0.09 0.10 0.05 0.24 ## Sum 0.16 0.21 0.15 0.52 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.06 0.02 0.07 0.15 ## C2 0.03 0.04 0.03 0.10 ## Sum 0.09 0.06 0.10 0.25 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.03 0.05 0.04 0.12 ## C2 0.03 0.04 0.04 0.11 ## Sum 0.06 0.09 0.08 0.23 ## ## , , = Sum, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.09 0.07 0.11 0.27 ## C2 0.06 0.08 0.07 0.21 ## Sum 0.15 0.15 0.18 0.48 ## ## , , = G1, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.10 0.07 0.11 0.28 ## C2 0.07 0.09 0.04 0.20 ## Sum 0.17 0.16 0.15 0.48 ## ## , , = G2, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.06 0.11 0.10 0.27 ## C2 0.08 0.09 0.08 0.25 ## Sum 0.14 0.20 0.18 0.52 ## ## , , = Sum, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( f3 )) ## Sum ## 0.10 0.06 0.16 ## 0.07 0.11 0.18 ## 0.11 0.10 0.21 ## 0.07 0.08 0.15 ## 0.09 0.09 0.18 ## 0.04 0.08 0.12 ## Sum 0.48 0.52 1.00 addmargins( prop.table( f4 )) ## Sum ## 0.04 0.06 0.10 ## 0.03 0.03 0.06 ## 0.05 0.02 0.07 ## 0.06 0.05 0.11 ## 0.04 0.07 0.11 ## 0.06 0.04 0.10 ## 0.04 0.03 0.07 ## 0.05 0.03 0.08 ## 0.05 0.04 0.09 ## 0.05 0.04 0.09 ## 0.01 0.03 0.04 ## 0.04 0.04 0.08 ## Sum 0.52 0.48 1.00 "],
["4-4-data-aggregation.html", "4.4 Data Aggregation", " 4.4 Data Aggregation This chapter explore multiple methods to group data and computes value within groups: tapply aggregate (10x slower than apply) dplyr and tidyr, a much intuitive tools 4.4.1 Single Dimension 4.4.1.1 Base R 4.4.1.1.1 tapply tapply ( X, INDEX, FUN, na.rm = FALSE ) \\(\\quad\\) X = value vector \\(\\quad\\) INDEX = vector of groups data (can be factor, number or string) \\(\\quad\\) FUN = function to apply on X, according to group specified in INDEX \\(\\quad\\) na.rm = ignore &lt;NA&gt; values X and INDEX must have the same length tapply will divide the value vector (X) into groups (base on INDEX), and perform computation (FUN) on each group If there are &lt;NA&gt; in the vector X, some FUN may fail to return value, such as mean, sum. So it is essential to specify na.rm = TRUE in these cases Group identifier will be used as column name (accessible through names()) t1 = tapply(my.df$value1, my.df$com, mean) t1 names( t1 ) ## C1 C2 ## 50.02603 50.55429 ## [1] &quot;C1&quot; &quot;C2&quot; FUN That Returns Non-Vector - output is list t2 = tapply(my.df$value1, my.df$com, FUN=summary) t2 ## $C1 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 38.28 47.44 49.56 50.03 52.28 60.25 ## ## $C2 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 41.18 46.75 51.29 50.55 54.07 59.05 names( t2 ) ## [1] &quot;C1&quot; &quot;C2&quot; 4.4.1.2 dplyr my.df %&gt;% group_by(com) %&gt;% summarize(v1_avg=mean(value1)) ## # A tibble: 2 x 2 ## com v1_avg ## &lt;chr&gt; &lt;dbl&gt; ## 1 C1 50.0 ## 2 C2 50.6 4.4.2 Two Dimension 4.4.2.1 Base R 4.4.2.1.1 tapply Wrap multiple categorical alike variables in a list for multi level grouping t3 = tapply(my.df$value1, list(my.df$com, my.df$dept), mean) t3 rownames(t3) colnames(t3) dim(t3) is.matrix(t3) ## D1 D2 D3 ## C1 49.52605 51.11388 49.47453 ## C2 49.18417 51.68186 50.57559 ## [1] &quot;C1&quot; &quot;C2&quot; ## [1] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## [1] 2 3 ## [1] TRUE 4.4.2.1.2 dplyr my.df %&gt;% group_by(com,dept) %&gt;% summarize(v1_avg=mean(value1)) my.df %&gt;% group_by(com,dept) %&gt;% summarize(v1_avg=mean(value1)) %&gt;% spread(dept,v1_avg) ## # A tibble: 6 x 3 ## # Groups: com [?] ## com dept v1_avg ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 C1 D1 49.5 ## 2 C1 D2 51.1 ## 3 C1 D3 49.5 ## 4 C2 D1 49.2 ## 5 C2 D2 51.7 ## 6 C2 D3 50.6 ## # A tibble: 2 x 4 ## # Groups: com [2] ## com D1 D2 D3 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 49.5 51.1 49.5 ## 2 C2 49.2 51.7 50.6 4.4.3 Three Dimension 4.4.3.1 Base R 4.4.3.1.1 tapply t4 = tapply(my.df$value1, list(my.df$com, my.df$dept, my.df$grp), mean) t4 rownames(t4) colnames(t4) dim(t4) is.matrix(t4) ## , , G1 ## ## D1 D2 D3 ## C1 49.55384 53.06535 50.41120 ## C2 49.31321 52.11709 53.92199 ## ## , , G2 ## ## D1 D2 D3 ## C1 49.47973 49.87203 48.44419 ## C2 49.07126 51.24664 48.90239 ## ## [1] &quot;C1&quot; &quot;C2&quot; ## [1] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## [1] 2 3 2 ## [1] FALSE 4.4.3.2 dplyr my.df %&gt;% group_by(com,dept,grp) %&gt;% summarize(v1_avg=mean(value1)) my.df %&gt;% group_by(com,dept,grp) %&gt;% summarize(v1_avg=mean(value1)) %&gt;% spread(dept,v1_avg) ## # A tibble: 12 x 4 ## # Groups: com, dept [?] ## com dept grp v1_avg ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 C1 D1 G1 49.6 ## 2 C1 D1 G2 49.5 ## 3 C1 D2 G1 53.1 ## 4 C1 D2 G2 49.9 ## 5 C1 D3 G1 50.4 ## 6 C1 D3 G2 48.4 ## 7 C2 D1 G1 49.3 ## 8 C2 D1 G2 49.1 ## 9 C2 D2 G1 52.1 ## 10 C2 D2 G2 51.2 ## 11 C2 D3 G1 53.9 ## 12 C2 D3 G2 48.9 ## # A tibble: 4 x 5 ## # Groups: com [2] ## com grp D1 D2 D3 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 G1 49.6 53.1 50.4 ## 2 C1 G2 49.5 49.9 48.4 ## 3 C2 G1 49.3 52.1 53.9 ## 4 C2 G2 49.1 51.2 48.9 4.4.4 aggretate - base R Aggregate is a very useful base R function and provides quick way to group data and values: Input in list/data.frame, computes and output new data.frame. It groups categorical variable(s) and compute value variable(s) based on function FUN. FUN can be min, max, mean, sd, sum or length (frequency count). ONLY ONE function is supported, and it applies to all value variables !!! 4.4.4.1 Basic Syntax (formula method) - data source is data.frame The formula method use ‘data’ parameter and therefore apply for single data source only. The objective is simplicy and without flexibility to customize column names aggregate (data = df, formula, FUN = function) \\(\\quad\\) Formula in the form: value~categorical 4.4.4.2 One value variable ~ one categorical variable aggregate (data = my.df, value1 ~ grp, FUN = length) ## grp value1 ## 1 G1 48 ## 2 G2 52 4.4.4.3 One value variable ~ multiple categorical variables aggregate (data = my.df, value1 ~ grp + dept, FUN = length) ## grp dept value1 ## 1 G1 D1 17 ## 2 G2 D1 14 ## 3 G1 D2 16 ## 4 G2 D2 20 ## 5 G1 D3 15 ## 6 G2 D3 18 4.4.4.4 Multiple value variables ~ one categorical variable, use cbind() aggregate (data = my.df, cbind(value1,value2) ~ grp, FUN = length) ## grp value1 value2 ## 1 G1 48 48 ## 2 G2 52 52 4.4.4.5 multiple value variables ~ multiple categorical variable aggregate (data = my.df, cbind(value1,value2) ~ grp + dept, FUN = length) ## grp dept value1 value2 ## 1 G1 D1 17 17 ## 2 G2 D1 14 14 ## 3 G1 D2 16 16 ## 4 G2 D2 20 20 ## 5 G1 D3 15 15 ## 6 G2 D3 18 18 4.4.4.6 ALL value variables ~ multiple categorical variable, use dot notation Change from FUN=length to sum results in error because sum() cannot be applied to non-numerical variable ‘team’ aggregate (data = my.df, . ~ grp + dept, FUN = length) ## grp dept com team prd value1 value2 value3 ## 1 G1 D1 17 17 17 17 17 17 ## 2 G2 D1 14 14 14 14 14 14 ## 3 G1 D2 16 16 16 16 16 16 ## 4 G2 D2 20 20 20 20 20 20 ## 5 G1 D3 15 15 15 15 15 15 ## 6 G2 D3 18 18 18 18 18 18 4.4.4.7 Advance Syntax (by method) - data source is either list or data.frame The advantage of ’by method’ are: Can use list/data.frame subset method to choose column to display, hence flexible Can customize output column names (list subset method only) Flexibility to use multiple data sources, hence ‘data’ is not used and has no effect if specified Using list subseting: column name is not preserved, hence must specify meaningful column names. If not supplied, generic names and undesirable column names derived from data value will be used as column name aggregate (x = list(…value_variables…), by = list(…categorical_variables…), FUN = function) aggregate (x = list( v1_mean = my.df$value1, my.df$value2 ), by = list( my.df$grp, DEPT = my.df$dept), FUN=mean) ## Group.1 DEPT v1_mean ## 1 G1 D1 49.45476 ## 2 G2 D1 49.24632 ## 3 G1 D2 52.53196 ## 4 G2 D2 50.49061 ## 5 G1 D3 51.34741 ## 6 G2 D3 48.64784 ## c.13.0518915454923..21.6874152709086..17.6486745817329..19.3218380413155.. ## 1 19.75117 ## 2 19.15763 ## 3 20.32423 ## 4 20.03524 ## 5 18.40269 ## 6 20.73220 Using data.frame subseting: column names are preserved and no option to change. Notice attempt below to change the column name does not succeed aggregate( x = df[,c(…)], by = df[,c(…)]), FUN = function) aggregate( x = df[, p:q], by = df[,s:t]), FUN = function) aggregate(x=my.df[, c(v1_mean=&#39;value1&#39;, &#39;value2&#39;)], by=my.df[,c(GRP=&#39;grp&#39;, &#39;dept&#39;)], FUN=mean) ## grp dept value1 value2 ## 1 G1 D1 49.45476 19.75117 ## 2 G2 D1 49.24632 19.15763 ## 3 G1 D2 52.53196 20.32423 ## 4 G2 D2 50.49061 20.03524 ## 5 G1 D3 51.34741 18.40269 ## 6 G2 D3 48.64784 20.73220 # aggregate(x = my.df[, 4:5], by = my.df[, 1:2], FUN = mean) # produce similar result as above 4.4.5 dplyr 4.4.5.1 Grouping Grouping returns all rows, with internal grouping structure Display of tibble rows truncates automatically if too many rows. Use print(tbl_df(my.tbl), n=40) to display more rows (quite troublesome, but look at all the other benefits) The internal grouping structure can be used for subsequent summarization To get the row numbers for each group, add additional column with mutate of row_number() d.df = my.df %&gt;% group_by(com,dept, grp) %&gt;% arrange(com,dept,grp) %&gt;% mutate(idx = row_number()) print(tbl_df(d.df),n=18) ## # A tibble: 100 x 9 ## com dept grp team prd value1 value2 value3 idx ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 C1 D1 G1 T1 P4 57.4 25.7 3.53 1 ## 2 C1 D1 G1 T2 P1 43.9 17.4 3.80 2 ## 3 C1 D1 G1 T1 P1 51.9 19.9 4.11 3 ## 4 C1 D1 G1 T2 P2 51.6 19.0 3.83 4 ## 5 C1 D1 G1 T2 P3 46.5 18.3 3.31 5 ## 6 C1 D1 G1 T2 P4 41.2 17.7 7.24 6 ## 7 C1 D1 G1 T2 P4 50.1 21.3 6.78 7 ## 8 C1 D1 G1 T1 P3 49.8 13.6 6.04 8 ## 9 C1 D1 G1 T2 P1 47.5 19.1 4.64 9 ## 10 C1 D1 G1 T1 P4 55.6 16.2 4.97 10 ## 11 C1 D1 G2 T1 P4 52.2 13.1 5.36 1 ## 12 C1 D1 G2 T1 P5 51.7 18.5 3.70 2 ## 13 C1 D1 G2 T1 P4 44.1 20.9 3.73 3 ## 14 C1 D1 G2 T2 P4 45.2 20.1 3.78 4 ## 15 C1 D1 G2 T2 P4 48.9 16.2 4.59 5 ## 16 C1 D1 G2 T2 P5 54.8 20.5 4.35 6 ## 17 C1 D2 G1 T1 P5 60.2 17.5 4.96 1 ## 18 C1 D2 G1 T1 P5 48.8 20.9 4.16 2 ## # ... with 82 more rows Verify group levels in attr(*, &quot;vars&quot;) attr(d.df, &#39;vars&#39;) ## [1] &quot;com&quot; &quot;dept&quot; &quot;grp&quot; 4.4.5.2 Frequency Counting count() groups and provide additional column n, which counts the number of rows within the group my.df %&gt;% count(com, dept, prd) ## # A tibble: 29 x 4 ## com dept prd n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 P1 3 ## 2 C1 D1 P2 1 ## 3 C1 D1 P3 2 ## 4 C1 D1 P4 8 ## 5 C1 D1 P5 2 ## 6 C1 D2 P2 4 ## 7 C1 D2 P3 6 ## 8 C1 D2 P4 4 ## 9 C1 D2 P5 4 ## 10 C1 D3 P1 5 ## # ... with 19 more rows count() is shorthand for group_by and summarize my.df %&gt;% group_by(com, dept, prd) %&gt;% summarize(count = n()) ## # A tibble: 29 x 4 ## # Groups: com, dept [?] ## com dept prd count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 P1 3 ## 2 C1 D1 P2 1 ## 3 C1 D1 P3 2 ## 4 C1 D1 P4 8 ## 5 C1 D1 P5 2 ## 6 C1 D2 P2 4 ## 7 C1 D2 P3 6 ## 8 C1 D2 P4 4 ## 9 C1 D2 P5 4 ## 10 C1 D3 P1 5 ## # ... with 19 more rows summarize() reduce grouping level by one my.df %&gt;% group_by(com, dept, grp)%&gt;% attr(&#39;vars&#39;) my.df %&gt;% group_by(com, dept, grp) %&gt;% summarize(n()) %&gt;% attr(&#39;vars&#39;) ## [1] &quot;com&quot; &quot;dept&quot; &quot;grp&quot; ## [1] &quot;com&quot; &quot;dept&quot; BUT count() reset grouping entirely (no grouping) !!! my.df %&gt;% count(com, dept, grp) %&gt;% attr(&#39;vars&#39;) ## NULL 4.4.5.3 Summarization 4.4.5.3.1 summarize: Apply Multiple Functions to Multiple Columns Different functions can be applied to different variables, each return a new column my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise( avg_value1 = mean(value1), min_value2 = min(value2), max_value3 = max(value3), n.team = n_distinct(team), count = n()) ## # A tibble: 29 x 8 ## # Groups: com, dept [?] ## com dept prd avg_value1 min_value2 max_value3 n.team count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 C1 D1 P1 47.8 17.4 4.64 2 3 ## 2 C1 D1 P2 51.6 19.0 3.83 1 1 ## 3 C1 D1 P3 48.1 13.6 6.04 2 2 ## 4 C1 D1 P4 49.3 13.1 7.24 2 8 ## 5 C1 D1 P5 53.2 18.5 4.35 2 2 ## 6 C1 D2 P2 48.2 16.3 5.98 2 4 ## 7 C1 D2 P3 50.3 14.2 5.71 2 6 ## 8 C1 D2 P4 51.5 12.0 6.21 2 4 ## 9 C1 D2 P5 54.9 17.5 4.96 2 4 ## 10 C1 D3 P1 48.2 16.3 6.47 2 5 ## # ... with 19 more rows 4.4.5.3.2 summarize_at: Apply Function(s) To Multiple Columns summarize_at ( vars(...), funs(...) ), ... \\(\\quad\\) Use vars() to specify multiple variables: vars(7:9), vars(7,8,9), vars('col1','col3','col5'), vars(col1:col3) \\(\\quad\\) Use funs() to specify multiple functions: funs(func1,func2,func3) \\(\\quad\\) ... : additional parameters to be supplied to funs Pick variables by their names my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_at(vars(&#39;value2&#39;, &#39;value3&#39;), mean, na.rm=T) ## # A tibble: 29 x 5 ## # Groups: com, dept [?] ## com dept prd value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 18.8 4.18 ## 2 C1 D1 P2 19.0 3.83 ## 3 C1 D1 P3 15.9 4.68 ## 4 C1 D1 P4 18.9 5.00 ## 5 C1 D1 P5 19.5 4.03 ## 6 C1 D2 P2 20.1 4.69 ## 7 C1 D2 P3 20.4 4.78 ## 8 C1 D2 P4 18.4 5.49 ## 9 C1 D2 P5 19.8 4.29 ## 10 C1 D3 P1 18.6 5.57 ## # ... with 19 more rows Pick variables by their index number my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_at(vars(7,8), mean) ## # A tibble: 29 x 5 ## # Groups: com, dept [?] ## com dept prd value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 18.8 4.18 ## 2 C1 D1 P2 19.0 3.83 ## 3 C1 D1 P3 15.9 4.68 ## 4 C1 D1 P4 18.9 5.00 ## 5 C1 D1 P5 19.5 4.03 ## 6 C1 D2 P2 20.1 4.69 ## 7 C1 D2 P3 20.4 4.78 ## 8 C1 D2 P4 18.4 5.49 ## 9 C1 D2 P5 19.8 4.29 ## 10 C1 D3 P1 18.6 5.57 ## # ... with 19 more rows PIck range of variables by column name range my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_at(vars(value2:value3),mean) ## # A tibble: 29 x 5 ## # Groups: com, dept [?] ## com dept prd value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 18.8 4.18 ## 2 C1 D1 P2 19.0 3.83 ## 3 C1 D1 P3 15.9 4.68 ## 4 C1 D1 P4 18.9 5.00 ## 5 C1 D1 P5 19.5 4.03 ## 6 C1 D2 P2 20.1 4.69 ## 7 C1 D2 P3 20.4 4.78 ## 8 C1 D2 P4 18.4 5.49 ## 9 C1 D2 P5 19.8 4.29 ## 10 C1 D3 P1 18.6 5.57 ## # ... with 19 more rows Pick range of variables by column index range my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_at(vars(7:8),mean) ## # A tibble: 29 x 5 ## # Groups: com, dept [?] ## com dept prd value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 18.8 4.18 ## 2 C1 D1 P2 19.0 3.83 ## 3 C1 D1 P3 15.9 4.68 ## 4 C1 D1 P4 18.9 5.00 ## 5 C1 D1 P5 19.5 4.03 ## 6 C1 D2 P2 20.1 4.69 ## 7 C1 D2 P3 20.4 4.78 ## 8 C1 D2 P4 18.4 5.49 ## 9 C1 D2 P5 19.8 4.29 ## 10 C1 D3 P1 18.6 5.57 ## # ... with 19 more rows Multiple Functions to Multiple Columns my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_at(vars(&#39;value1&#39;,&#39;value2&#39;),funs(mean,sd), na.rm=T) ## # A tibble: 29 x 7 ## # Groups: com, dept [?] ## com dept prd value1_mean value2_mean value1_sd value2_sd ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 47.8 18.8 4.03 1.29 ## 2 C1 D1 P2 51.6 19.0 NaN NaN ## 3 C1 D1 P3 48.1 15.9 2.34 3.32 ## 4 C1 D1 P4 49.3 18.9 5.67 3.91 ## 5 C1 D1 P5 53.2 19.5 2.18 1.45 ## 6 C1 D2 P2 48.2 20.1 1.37 3.70 ## 7 C1 D2 P3 50.3 20.4 3.93 3.76 ## 8 C1 D2 P4 51.5 18.4 4.90 4.68 ## 9 C1 D2 P5 54.9 19.8 5.32 1.85 ## 10 C1 D3 P1 48.2 18.6 6.12 1.44 ## # ... with 19 more rows 4.4.5.3.3 summarize_all: Apply Function(s) to ALL Columns This apply function(s) to all non-grouped variables summarize_all ( funs(...) ), ... \\(\\quad\\) Use funs() to specify multiple functions: funs(func1,func2,func3) \\(\\quad\\) ... : additional parameters to be supplied to funs Notice that each column whin the group will be summarized with one more functions. This includes columns which are NOT numeric, resulting warnings and NA. Single Function to All Variables If only one function, funs() is not required. Notice below non-grouped variable prd has been ‘mean’ but produced NA since it is non-numeric my.df %&gt;% group_by(com, dept, grp, team) %&gt;% summarise_all(mean, na.rm=T) ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## Warning in mean.default(prd, na.rm = TRUE): argument is not numeric or ## logical: returning NA ## # A tibble: 24 x 8 ## # Groups: com, dept, grp [?] ## com dept grp team prd value1 value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 G1 T1 NA 53.7 18.8 4.66 ## 2 C1 D1 G1 T2 NA 46.8 18.8 4.93 ## 3 C1 D1 G2 T1 NA 49.3 17.5 4.27 ## 4 C1 D1 G2 T2 NA 49.6 18.9 4.24 ## 5 C1 D2 G1 T1 NA 54.4 19.4 4.93 ## 6 C1 D2 G1 T2 NA 49.8 21.8 3.82 ## 7 C1 D2 G2 T1 NA 48.9 18.7 5.03 ## 8 C1 D2 G2 T2 NA 51.0 20.7 4.82 ## 9 C1 D3 G1 T1 NA 51.8 19.7 5.34 ## 10 C1 D3 G1 T2 NA 49.6 19.1 5.57 ## # ... with 14 more rows Multiple Functions to All Variables Use funs() to supply multiple functions my.df %&gt;% group_by(com, dept, grp,team, prd) %&gt;% summarise_all(funs(mean,sd), na.rm=T) ## # A tibble: 66 x 11 ## # Groups: com, dept, grp, team [?] ## com dept grp team prd value1_mean value2_mean value3_mean ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 G1 T1 P1 51.9 19.9 4.11 ## 2 C1 D1 G1 T1 P3 49.8 13.6 6.04 ## 3 C1 D1 G1 T1 P4 56.5 21.0 4.25 ## 4 C1 D1 G1 T2 P1 45.7 18.3 4.22 ## 5 C1 D1 G1 T2 P2 51.6 19.0 3.83 ## 6 C1 D1 G1 T2 P3 46.5 18.3 3.31 ## 7 C1 D1 G1 T2 P4 45.6 19.5 7.01 ## 8 C1 D1 G2 T1 P4 48.1 17.0 4.55 ## 9 C1 D1 G2 T1 P5 51.7 18.5 3.70 ## 10 C1 D1 G2 T2 P4 47.1 18.1 4.18 ## # ... with 56 more rows, and 3 more variables: value1_sd &lt;dbl&gt;, ## # value2_sd &lt;dbl&gt;, value3_sd &lt;dbl&gt; 4.4.5.3.4 summarize_if: Apply Function(s) to All Matching Columns Single Function To All Matching Columns my.df %&gt;% group_by(com, dept) %&gt;% summarise_if(is.numeric, mean, na.rm=T) ## # A tibble: 6 x 5 ## # Groups: com [?] ## com dept value1 value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 49.5 18.6 4.61 ## 2 C1 D2 51.1 19.8 4.81 ## 3 C1 D3 49.5 19.6 4.96 ## 4 C2 D1 49.2 20.4 5.40 ## 5 C2 D2 51.7 20.6 5.40 ## 6 C2 D3 50.6 19.8 5.11 Multiple Functions To All Matching Columns Any of the above summarize can combine with funs() to specify multiple functions. my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_if(is.numeric, funs(mean,sd)) ## # A tibble: 29 x 9 ## # Groups: com, dept [?] ## com dept prd value1_mean value2_mean value3_mean value1_sd ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 47.8 18.8 4.18 4.03 ## 2 C1 D1 P2 51.6 19.0 3.83 NaN ## 3 C1 D1 P3 48.1 15.9 4.68 2.34 ## 4 C1 D1 P4 49.3 18.9 5.00 5.67 ## 5 C1 D1 P5 53.2 19.5 4.03 2.18 ## 6 C1 D2 P2 48.2 20.1 4.69 1.37 ## 7 C1 D2 P3 50.3 20.4 4.78 3.93 ## 8 C1 D2 P4 51.5 18.4 5.49 4.90 ## 9 C1 D2 P5 54.9 19.8 4.29 5.32 ## 10 C1 D3 P1 48.2 18.6 5.57 6.12 ## # ... with 19 more rows, and 2 more variables: value2_sd &lt;dbl&gt;, ## # value3_sd &lt;dbl&gt; 4.4.5.3.5 Summarize Reduce The Grouping Level by One Each call to group_by() will reset group level Each call to summarize() will reduce group level by one my.df %&gt;% group_by(com,dept,grp) %&gt;% attr(&#39;vars&#39;) my.df %&gt;% group_by(com,dept,grp) %&gt;% summarize(n()) %&gt;% attr(&#39;vars&#39;) my.df %&gt;% group_by(com,dept,grp) %&gt;% summarize(n()) %&gt;% summarize(n()) %&gt;% attr(&#39;vars&#39;) ## [1] &quot;com&quot; &quot;dept&quot; &quot;grp&quot; ## [1] &quot;com&quot; &quot;dept&quot; ## [1] &quot;com&quot; 4.4.5.4 In-Group Row Numbering Summarize reduce group level by one, hence n() will return the rows within the new group. Example below group with three levels (com, dept,prd), however, after summarize, n() returns the number of rows within (com,dept) group. row_number() dynamically assign sequential row number within the group my.df %&gt;% group_by(com,dept) %&gt;% summarize(avg.value1=mean(value1)) %&gt;% mutate (rnum = row_number()) ## # A tibble: 6 x 4 ## # Groups: com [2] ## com dept avg.value1 rnum ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 C1 D1 49.5 1 ## 2 C1 D2 51.1 2 ## 3 C1 D3 49.5 3 ## 4 C2 D1 49.2 1 ## 5 C2 D2 51.7 2 ## 6 C2 D3 50.6 3 Alternatively, mutate with 1:n() will return the same result as above. n() is the total number of rows within group, 1:n() will return a sequential integer number my.df %&gt;% group_by(com,dept) %&gt;% summarize(avg.value1=mean(value1)) %&gt;% mutate (rnum = 1:n()) ## # A tibble: 6 x 4 ## # Groups: com [2] ## com dept avg.value1 rnum ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 C1 D1 49.5 1 ## 2 C1 D2 51.1 2 ## 3 C1 D3 49.5 3 ## 4 C2 D1 49.2 1 ## 5 C2 D2 51.7 2 ## 6 C2 D3 50.6 3 4.4.5.5 In-Group Row Selection 4.4.5.5.1 Top-N Selection Example below select highest occurance of prd within the group of (com,dept). It is based on the principe that count reduce group levels by one, then selection is based on rows within the new group top_n (n,wt) \\(\\quad\\) n : number of rows to return \\(\\quad\\) wt: column to use, default order using last column my.df %&gt;% group_by(com,dept,prd) %&gt;% summarize(t1=sum(value1), t2=sum(value2)) ## # A tibble: 29 x 5 ## # Groups: com, dept [?] ## com dept prd t1 t2 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 143. 56.4 ## 2 C1 D1 P2 51.6 19.0 ## 3 C1 D1 P3 96.3 31.8 ## 4 C1 D1 P4 395. 151. ## 5 C1 D1 P5 106. 39.0 ## 6 C1 D2 P2 193. 80.6 ## 7 C1 D2 P3 302. 123. ## 8 C1 D2 P4 206. 73.4 ## 9 C1 D2 P5 220. 79.2 ## 10 C1 D3 P1 241. 92.8 ## # ... with 19 more rows my.df %&gt;% group_by(com,dept,prd) %&gt;% summarize(t1=sum(value1), t2=sum(value2)) %&gt;% top_n(n=1, wt=t2) ## # A tibble: 6 x 5 ## # Groups: com, dept [6] ## com dept prd t1 t2 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P4 395. 151. ## 2 C1 D2 P3 302. 123. ## 3 C1 D3 P4 385. 157. ## 4 C2 D1 P1 240. 108. ## 5 C2 D2 P3 315. 128. ## 6 C2 D3 P4 211. 79.5 "],
["4-5-r-with-sql-emulation.html", "4.5 R with SQL Emulation", " 4.5 R with SQL Emulation Running SQL statement on existing data.frame are useful to derive summarization and aggregation for someone who are familiar with SQL. 4.5.1 Library sqldf library is required. It has dependency on gsubfn, proto and RSQLite packages. library(sqldf) 4.5.2 Run The Code R data.frame variable is specified in ‘FROM’ clause. Note that . is a SQL operator, any variable with ‘.’ must be contained within single quote. sqldf(&quot; SELECT com, dept, count(*) AS qty, AVG(value1) AS v1_mean, SUM(value2) AS v2_sum FROM &#39;my.df&#39; GROUP BY com, dept &quot;) ## com dept qty v1_mean v2_sum ## 1 C1 D1 16 49.52605 297.2627 ## 2 C1 D2 18 51.11388 355.7833 ## 3 C1 D3 21 49.47453 411.6937 ## 4 C2 D1 15 49.18417 306.7140 ## 5 C2 D2 18 51.68186 370.1092 ## 6 C2 D3 12 50.57559 237.5263 "]
]
