[
["5-data-preprocessing.html", "Chapter 5 Data Preprocessing ", " Chapter 5 Data Preprocessing "],
["5-1-library.html", "5.1 Library", " 5.1 Library library(&#39;lubridate&#39;) "],
["5-2-sample-data.html", "5.2 Sample Data", " 5.2 Sample Data my.df &lt;- read.csv ( file=&quot;./datasets/import_sample.csv&quot;, na.strings=c(&#39;NA&#39;,&#39;NULL&#39;,&#39;&#39;), stringsAsFactors = FALSE, encoding=&quot;UTF-8&quot;) my.df ## X X.1 dept gender weight height date_birth amount date_last ## 1 1 ID101 D1 Male 35.00000 173 1/7/1973 100 2/29/2016 ## 2 2 ID102 D2 Female 37.10000 164 28/2/1980 121 4/1/2017 ## 3 3 ID103 D3 Female 43.12000 178 31/12/1978 152 10/31/2015 ## 4 4 ID104 D1 Male 38.12300 182 12/1/1997 133 11/1/2016 ## 5 5 ID105 D1 Male 54.12340 159 2/1/1982 143 9/30/2016 ## 6 NA ID106 D3 Female 34.12345 166 26/7/1973 155 11/27/2015 ## 7 7 ID107 D2 Male 49.12346 153 21/8/1985 117 3/31/2017 ## 8 8 ID108 D3 Female 75.10000 151 9/8/1983 135 2/1/2015 ## 9 9 ID109 D2 Male 52.10000 169 &lt;NA&gt; 128 &lt;NA&gt; ## 10 10 ID110 D3 &lt;NA&gt; 88.80000 171 &lt;NA&gt; 141 &lt;NA&gt; ## date.first ## 1 2013-07-31 ## 2 2013-08-31 ## 3 2014-12-31 ## 4 2015-02-28 ## 5 2012-06-15 ## 6 2013-04-28 ## 7 2014-03-01 ## 8 &lt;NA&gt; ## 9 &lt;NA&gt; ## 10 &lt;NA&gt; str(my.df) ## &#39;data.frame&#39;: 10 obs. of 10 variables: ## $ X : int 1 2 3 4 5 NA 7 8 9 10 ## $ X.1 : chr &quot;ID101&quot; &quot;ID102&quot; &quot;ID103&quot; &quot;ID104&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; &quot;D1&quot; ... ## $ gender : chr &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; ... ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 151 169 171 ## $ date_birth: chr &quot;1/7/1973&quot; &quot;28/2/1980&quot; &quot;31/12/1978&quot; &quot;12/1/1997&quot; ... ## $ amount : int 100 121 152 133 143 155 117 135 128 141 ## $ date_last : chr &quot;2/29/2016&quot; &quot;4/1/2017&quot; &quot;10/31/2015&quot; &quot;11/1/2016&quot; ... ## $ date.first: chr &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; ... "],
["5-3-column-manipulation.html", "5.3 Column Manipulation", " 5.3 Column Manipulation 5.3.1 Duplicating Columns Duplicate single column using $ selector my.df$Z1 = my.df$X my.df$Z2 = my.df$X str(my.df) ## &#39;data.frame&#39;: 10 obs. of 12 variables: ## $ X : int 1 2 3 4 5 NA 7 8 9 10 ## $ X.1 : chr &quot;ID101&quot; &quot;ID102&quot; &quot;ID103&quot; &quot;ID104&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; &quot;D1&quot; ... ## $ gender : chr &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; ... ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 151 169 171 ## $ date_birth: chr &quot;1/7/1973&quot; &quot;28/2/1980&quot; &quot;31/12/1978&quot; &quot;12/1/1997&quot; ... ## $ amount : int 100 121 152 133 143 155 117 135 128 141 ## $ date_last : chr &quot;2/29/2016&quot; &quot;4/1/2017&quot; &quot;10/31/2015&quot; &quot;11/1/2016&quot; ... ## $ date.first: chr &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; ... ## $ Z1 : int 1 2 3 4 5 NA 7 8 9 10 ## $ Z2 : int 1 2 3 4 5 NA 7 8 9 10 5.3.2 Delete Columns Delete single column using $ column selector, setting to NULL. my.df$Z1 = NULL Delete multiple columns using multiple columns selector [,vector], with vector containing column numbers or names, setting to NULL. my.df[,c(&#39;X&#39;,&#39;Z2&#39;)] = NULL str(my.df) ## &#39;data.frame&#39;: 10 obs. of 9 variables: ## $ X.1 : chr &quot;ID101&quot; &quot;ID102&quot; &quot;ID103&quot; &quot;ID104&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; &quot;D1&quot; ... ## $ gender : chr &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; ... ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 151 169 171 ## $ date_birth: chr &quot;1/7/1973&quot; &quot;28/2/1980&quot; &quot;31/12/1978&quot; &quot;12/1/1997&quot; ... ## $ amount : int 100 121 152 133 143 155 117 135 128 141 ## $ date_last : chr &quot;2/29/2016&quot; &quot;4/1/2017&quot; &quot;10/31/2015&quot; &quot;11/1/2016&quot; ... ## $ date.first: chr &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; ... 5.3.3 Renaming Columns colnames returns vector of names attribute of data.frame. attributes(my.df) colnames(my.df) ## $names ## [1] &quot;X.1&quot; &quot;dept&quot; &quot;gender&quot; &quot;weight&quot; &quot;height&quot; ## [6] &quot;date_birth&quot; &quot;amount&quot; &quot;date_last&quot; &quot;date.first&quot; ## ## $row.names ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $class ## [1] &quot;data.frame&quot; ## ## [1] &quot;X.1&quot; &quot;dept&quot; &quot;gender&quot; &quot;weight&quot; &quot;height&quot; ## [6] &quot;date_birth&quot; &quot;amount&quot; &quot;date_last&quot; &quot;date.first&quot; Use colnames to rename single or multiple columns. Use [] to select the specific column(s). colnames(my.df)[c(1,9)] = c(&#39;id&#39;,&#39;date_first&#39;) colnames(my.df) ## [1] &quot;id&quot; &quot;dept&quot; &quot;gender&quot; &quot;weight&quot; &quot;height&quot; ## [6] &quot;date_birth&quot; &quot;amount&quot; &quot;date_last&quot; &quot;date_first&quot; "],
["5-4-missing-data.html", "5.4 Missing Data", " 5.4 Missing Data 5.4.1 Detecting Complete/Incomplete Vector/Row complete.cases returns logical vector for elements that doesn’t contain , with TRUE. It can be applied to both vector or data.frame. complete.cases(my.df$date_birth) # vector example complete.cases(my.df) # data.frame example ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE Negate complete.cases resulting TRUE for rows containing . !complete.cases(my.df$date_birth) # vector example !complete.cases(my.df) # data.frame example ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE Result from complete.cases is useful to retrieve incomplete rows for further investigation. my.df[!complete.cases(my.df),] ## id dept gender weight height date_birth amount date_last date_first ## 8 ID108 D3 Female 75.1 151 9/8/1983 135 2/1/2015 &lt;NA&gt; ## 9 ID109 D2 Male 52.1 169 &lt;NA&gt; 128 &lt;NA&gt; &lt;NA&gt; ## 10 ID110 D3 &lt;NA&gt; 88.8 171 &lt;NA&gt; 141 &lt;NA&gt; &lt;NA&gt; 5.4.2 Removing Missing Data na.omit returns data with removed. The advantage of this method compare to complete.cases are: - simpler syntax, filtering using [rows,] not require - additonal attribute, accessible through na.action(), providing information on element number removed Remove Missing elements with in rows na.omit(my.df$date_birth) # vector example ## [1] &quot;1/7/1973&quot; &quot;28/2/1980&quot; &quot;31/12/1978&quot; &quot;12/1/1997&quot; &quot;2/1/1982&quot; ## [6] &quot;26/7/1973&quot; &quot;21/8/1985&quot; &quot;9/8/1983&quot; ## attr(,&quot;na.action&quot;) ## [1] 9 10 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; str(na.omit(my.df$date_birth)) ## atomic [1:8] 1/7/1973 28/2/1980 31/12/1978 12/1/1997 ... ## - attr(*, &quot;na.action&quot;)=Class &#39;omit&#39; int [1:2] 9 10 Remove missing rows with # my.df[complete.cases(my.df),] # longer method which is less elegant my.df = na.omit(my.df) # data.frame example na.action(my.df) # number of rows removed ## 8 9 10 ## 8 9 10 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; "],
["5-5-string-manipulation.html", "5.5 String Manipulation", " 5.5 String Manipulation 5.5.1 Extration 5.5.2 Removal 5.5.3 Concatenation "],
["5-6-date-manipulation.html", "5.6 Date Manipulation", " 5.6 Date Manipulation 5.6.1 Parsing Date The example below demonstrates conversion of date columns from formated string. Before Conversion, verify that all dates column are actually chr. str(my.df) ## &#39;data.frame&#39;: 7 obs. of 9 variables: ## $ id : chr &quot;ID101&quot; &quot;ID102&quot; &quot;ID103&quot; &quot;ID104&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; &quot;D1&quot; ... ## $ gender : chr &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; ... ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 ## $ date_birth: chr &quot;1/7/1973&quot; &quot;28/2/1980&quot; &quot;31/12/1978&quot; &quot;12/1/1997&quot; ... ## $ amount : int 100 121 152 133 143 155 117 ## $ date_last : chr &quot;2/29/2016&quot; &quot;4/1/2017&quot; &quot;10/31/2015&quot; &quot;11/1/2016&quot; ... ## $ date_first: chr &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; ... ## - attr(*, &quot;na.action&quot;)=Class &#39;omit&#39; Named int [1:3] 8 9 10 ## .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;8&quot; &quot;9&quot; &quot;10&quot; Two ways to convert string to date: as.Date can convert vector into date data type. A format parameter has to be specified to match the source format. If not as.Date will try default of “%Y-%m-%d” then “%Y/%m/%d” lubridate::dmy, mdy, ymd - this is more elegant because manual format is not required, however, it converts only string data. If the data source is factor, use as.Date() instead In both methods, unmatched rows with unrecognized format will throw an error. my.df$date_birth = as.Date( my.df$date_birth, format = &quot;%d/%m/%Y&quot; ) # base R my.df$date_last = mdy( my.df$date_last ) # lubridate my.df$date_first = ymd( my.df$date_first ) # lubridate str(my.df) ## &#39;data.frame&#39;: 7 obs. of 9 variables: ## $ id : chr &quot;ID101&quot; &quot;ID102&quot; &quot;ID103&quot; &quot;ID104&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; &quot;D1&quot; ... ## $ gender : chr &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; ... ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 ## $ date_birth: Date, format: &quot;1973-07-01&quot; &quot;1980-02-28&quot; ... ## $ amount : int 100 121 152 133 143 155 117 ## $ date_last : Date, format: &quot;2016-02-29&quot; &quot;2017-04-01&quot; ... ## $ date_first: Date, format: &quot;2013-07-31&quot; &quot;2013-08-31&quot; ... ## - attr(*, &quot;na.action&quot;)=Class &#39;omit&#39; Named int [1:3] 8 9 10 ## .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;8&quot; &quot;9&quot; &quot;10&quot; 5.6.2 Days/Months/Year Different 5.6.2.1 Days Difference my.df$date_last my.df$date_first my.df$date_last - my.df$date_first ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; ## [1] &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; &quot;2012-06-15&quot; ## [6] &quot;2013-04-28&quot; &quot;2014-03-01&quot; ## Time differences in days ## [1] 943 1309 304 612 1568 943 1126 5.6.2.2 Months Difference Combination of lubridate::interval and lubridate operator provides a integer vector of months elapsed between two date: - The result can be negative if first date parameter &gt; second date parameter - lubridate ‘intelligently’ knows interval is from end of month to end of month interval interval( ymd(&#39;2016-03-30&#39;), ymd(&#39;2016-04-29&#39;) ) %/% months(1) # end day no. &lt; begining day no. interval( ymd(&#39;2016-03-30&#39;), ymd(&#39;2016-04-30&#39;) ) %/% months(1) # end day no. == beginning day no. interval( ymd(&#39;2016-03-31&#39;), ymd(&#39;2016-04-30&#39;) ) %/% months(1) # end of month to end of month ## [1] 0 ## [1] 1 ## [1] 1 Apply this to data frame / vector. my.df$date_first my.df$date_last interval( my.df$date_first, my.df$date_last ) %/% months(1) ## [1] &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; &quot;2012-06-15&quot; ## [6] &quot;2013-04-28&quot; &quot;2014-03-01&quot; ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; ## [1] 31 43 10 20 51 30 36 5.6.2.3 Years Difference Use lubridate::year function to find the year (integer) of a given date. Difference of the year() results from the birthdate and current date is the Age. year(now()) - year(my.df$date_birth) ## [1] 44 37 39 20 35 44 32 However in insurance industry, only a full year is considred for age. interval( ymd(&#39;2016-02-29&#39;), ymd(&#39;2017-02-27&#39;) ) %/% years(1) # a day short for a year interval( ymd(&#39;2016-02-29&#39;), ymd(&#39;2017-02-28&#39;) ) %/% years(1) # EoM to EoM ## [1] 0 ## [1] 1 Apply this to data frame / vector. my.df$date_first my.df$date_last interval( my.df$date_first, my.df$date_last ) %/% years(1) ## [1] &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; &quot;2012-06-15&quot; ## [6] &quot;2013-04-28&quot; &quot;2014-03-01&quot; ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; ## [1] 2 3 0 1 4 2 3 5.6.3 Days/Monhts/Years Later Adding days is as simple as add number of days to the date variables. my.df$date_last ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; Adding month(s) is tricky on the last day of month. Use lubridate operator for correct solution, because it takes cares of last day of month including February of leap years. my.df$date_last my.df$date_last + months(1) # 1 month later, bad solution, can result in &lt;NA&gt; my.df$date_last %m+% months(1) # 1 month later, good solution ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; ## [1] &quot;2016-03-29&quot; &quot;2017-05-01&quot; NA &quot;2016-12-01&quot; &quot;2016-10-30&quot; ## [6] &quot;2015-12-27&quot; NA ## [1] &quot;2016-03-29&quot; &quot;2017-05-01&quot; &quot;2015-11-30&quot; &quot;2016-12-01&quot; &quot;2016-10-30&quot; ## [6] &quot;2015-12-27&quot; &quot;2017-04-30&quot; Adding year(s) is similar to adding month(s) above. my.df$date_last my.df$date_last + years(1) # 1 month later, bad solution my.df$date_last %m+% years(1) # 1 month later, good solution ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; ## [1] NA &quot;2018-04-01&quot; &quot;2016-10-31&quot; &quot;2017-11-01&quot; &quot;2017-09-30&quot; ## [6] &quot;2016-11-27&quot; &quot;2018-03-31&quot; ## [1] &quot;2017-02-28&quot; &quot;2018-04-01&quot; &quot;2016-10-31&quot; &quot;2017-11-01&quot; &quot;2017-09-30&quot; ## [6] &quot;2016-11-27&quot; &quot;2018-03-31&quot; 5.6.4 Last Day of Month libridate::ceiling_date rounds up the date to the nearest unit. When rounding up a date to the **next nearest month*, it results the first day of next month. my.df$date_last ceiling_date(my.df$date_last, &quot;month&quot;) ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; ## [1] &quot;2016-03-01&quot; &quot;2017-05-01&quot; &quot;2015-11-01&quot; &quot;2016-12-01&quot; &quot;2016-10-01&quot; ## [6] &quot;2015-12-01&quot; &quot;2017-04-01&quot; Substracting this date by one will return last day of the month. ceiling_date(my.df$date_last, &quot;month&quot;) - days(1) ## [1] &quot;2016-02-29&quot; &quot;2017-04-30&quot; &quot;2015-10-31&quot; &quot;2016-11-30&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-30&quot; &quot;2017-03-31&quot; "],
["5-7-number-manipulation.html", "5.7 Number Manipulation", " 5.7 Number Manipulation 5.7.1 Sample Data Scaling section will use sample data generated as below: set.seed(1234) my.df = data.frame( id = paste(&#39;ID_&#39;, 1:5, sep = &#39;&#39;), value1 = sample(50:100, 5), value2 = sample(10:50, 5), stringsAsFactors = F ) my.df ## id value1 value2 ## 1 ID_1 55 36 ## 2 ID_2 81 10 ## 3 ID_3 79 19 ## 4 ID_4 98 35 ## 5 ID_5 90 29 5.7.2 Z-Score Scaling scale apply transformation column-wise, for columns within matrix or dataframe scale return a matrix scale (x, center=T, scale=T) # default S-Score transformation \\(\\quad\\) center = T (default) means value minus with mean \\(\\quad\\) scale = T (default) means value divide by sd \\(\\quad\\) \\(\\quad\\) output scaled:center --&gt; mean \\(\\quad\\) \\(\\quad\\) output scaled:scale --&gt; sd scale( my.df[,2:3] ) ## value1 value2 ## [1,] -1.58066858 0.9170971 ## [2,] 0.02469795 -1.4206014 ## [3,] -0.09879179 -0.6113981 ## [4,] 1.07436067 0.8271856 ## [5,] 0.58040174 0.2877167 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 80.6 25.8 ## attr(,&quot;scaled:scale&quot;) ## value1 value2 ## 16.19568 11.12205 scale( my.df[,2:3], scale=F ) ## value1 value2 ## [1,] -25.6 10.2 ## [2,] 0.4 -15.8 ## [3,] -1.6 -6.8 ## [4,] 17.4 9.2 ## [5,] 9.4 3.2 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 80.6 25.8 5.7.3 Min Max Scaling Min-Max scaling will transform all numbers between 0 and 1. Easiest way to perform this transformation is to write a function then apply. min_max = function(x){(x-min(x))/(max(x)-min(x))} apply( my.df[,2:3], MARGIN = 2, FUN = min_max ) ## 2 means column-wise ## value1 value2 ## [1,] 0.0000000 1.0000000 ## [2,] 0.6046512 0.0000000 ## [3,] 0.5581395 0.3461538 ## [4,] 1.0000000 0.9615385 ## [5,] 0.8139535 0.7307692 "],
["5-8-artificial-grouping.html", "5.8 Artificial Grouping", " 5.8 Artificial Grouping Artificial group can be created based on existing numeric data. Such as age_group based on age. 5.8.1 Grouping with Numeric Breakpoints Simulate data with x,y,z variables. p simulates priority scoring. x = rnorm(10, mean = 10) y = rnorm(10, mean = 10) p = x * y Articial groups is created first by identifying the number of groups, generate the break points vector, then cut the data base on break points and return factor as output. Automatically calculate breakpoints by distributing numbers into the min-max range, in low to high order: num_groups = 4 breakPoints = seq(min(p), max(p), length.out = num_groups + 1) breakPoints ## [1] 85.59917 92.47633 99.35348 106.23063 113.10779 cut ( x, breaks, right = TRUE, include.lowest = FALSE) \\(\\quad\\) x: numeric vector to be cutted \\(\\quad\\) breaks: numeric vector ranging from low to high (in order) \\(\\quad\\) include.lowest: FALSE - ommit element matching lowest number in breaks \\(\\quad\\) right: TRUE - close end on right;open end on left The result from cut is factor based on order from breakPoints. Therefore, once convert into numeric, the group number is in order of low to high accoriding to breakPoints. Verify that group (g) has been assigned for each priority (p). g = as.numeric( cut( p, breakPoints, include.lowest=TRUE)) data.frame(p,g) ## p g ## 1 103.90189 3 ## 2 89.43620 1 ## 3 85.91982 1 ## 4 86.45631 1 ## 5 113.10779 4 ## 6 96.50497 2 ## 7 85.59917 1 ## 8 88.17396 1 ## 9 105.27011 3 ## 10 101.99212 3 5.8.2 Grouping based on Custom Criteria ??? -->"]
]
