[
["index.html", "Business and Technical Analytics with R Preface", " Business and Technical Analytics with R Yong Keh Soon 2017-06-05 Preface "],
["1-fundamentals.html", "Chapter 1 R Fundamentals ", " Chapter 1 R Fundamentals "],
["1-1-package-management.html", "1.1 Package Management", " 1.1 Package Management Use installed.packages() : return matrix to list all installed package 1.1.1 Packages Listing Below are the column names and number for filtering purpose dimnames( installed.packages() ) [2] ## [[1]] ## [1] &quot;Package&quot; &quot;LibPath&quot; ## [3] &quot;Version&quot; &quot;Priority&quot; ## [5] &quot;Depends&quot; &quot;Imports&quot; ## [7] &quot;LinkingTo&quot; &quot;Suggests&quot; ## [9] &quot;Enhances&quot; &quot;License&quot; ## [11] &quot;License_is_FOSS&quot; &quot;License_restricts_use&quot; ## [13] &quot;OS_type&quot; &quot;MD5sum&quot; ## [15] &quot;NeedsCompilation&quot; &quot;Built&quot; Perform filter based on dimension names when necessary. Set priority = ‘NA’ will filter out all base R packages installed.packages( priority=&#39;NA&#39; ) [,c(3,2)] ## Version LibPath ## abind &quot;1.4-5&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## assertthat &quot;0.2.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## backports &quot;1.1.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## base64enc &quot;0.1-3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## BH &quot;1.62.0-1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## bitops &quot;1.0-6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## bookdown &quot;0.4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## broom &quot;0.4.2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## car &quot;2.1-4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## caret &quot;6.0-76&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## caTools &quot;1.17.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## cellranger &quot;1.1.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## colorspace &quot;1.3-2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## colourpicker &quot;0.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## curl &quot;2.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## data.table &quot;1.10.4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## DBI &quot;0.6-1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## dendextend &quot;1.5.2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## DEoptimR &quot;1.0-8&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## dichromat &quot;2.0-0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## digest &quot;0.6.12&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## diptest &quot;0.75-7&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## dplyr &quot;0.5.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## ellipse &quot;0.3-8&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## evaluate &quot;0.10&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## factoextra &quot;1.0.4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## FactoMineR &quot;1.35&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## flashClust &quot;1.01-2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## flexclust &quot;1.3-4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## flexmix &quot;2.3-14&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## forcats &quot;0.2.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## foreach &quot;1.4.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## formatR &quot;1.5&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## fpc &quot;2.1-10&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## gcookbook &quot;1.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## GGally &quot;1.3.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## ggExtra &quot;0.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## ggplot2 &quot;2.2.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## ggpubr &quot;0.1.2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## ggrepel &quot;0.6.5&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## ggsci &quot;2.4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## gridExtra &quot;2.2.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## gtable &quot;0.2.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## haven &quot;1.0.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## highr &quot;0.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## hms &quot;0.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## htmltools &quot;0.3.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## htmlwidgets &quot;0.8&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## httpuv &quot;1.3.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## httr &quot;1.2.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## iterators &quot;1.0.8&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## jsonlite &quot;1.4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## kernlab &quot;0.9-25&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## knitr &quot;1.16&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## labeling &quot;0.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## lazyeval &quot;0.2.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## leaps &quot;3.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## lme4 &quot;1.1-13&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## lubridate &quot;1.6.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## magrittr &quot;1.5&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## markdown &quot;0.8&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## MatrixModels &quot;0.4-1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## mclust &quot;5.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## mime &quot;0.5&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## miniUI &quot;0.1.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## minqa &quot;1.2.4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## mnormt &quot;1.5-5&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## ModelMetrics &quot;1.1.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## modelr &quot;0.1.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## modeltools &quot;0.2-21&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## munsell &quot;0.4.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## mvtnorm &quot;1.0-6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## NbClust &quot;3.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## nloptr &quot;1.0.4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## openssl &quot;0.9.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## pbkrtest &quot;0.4-7&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## plyr &quot;1.8.4&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## prabclus &quot;2.2-6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## prettyunits &quot;1.0.2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## progress &quot;1.1.2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## psych &quot;1.7.5&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## purrr &quot;0.2.2.2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## quantreg &quot;5.33&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## R6 &quot;2.2.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## rattle &quot;4.1.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## RColorBrewer &quot;1.1-2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## Rcpp &quot;0.12.11&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## RcppEigen &quot;0.3.3.3.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## readr &quot;1.1.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## readxl &quot;1.0.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## rematch &quot;1.0.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## reshape &quot;0.8.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## reshape2 &quot;1.4.2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## rlang &quot;0.1.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## rmarkdown &quot;1.5&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## robustbase &quot;0.92-7&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## rprojroot &quot;1.2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## rstudioapi &quot;0.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## rvest &quot;0.3.2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## scales &quot;0.4.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## scatterplot3d &quot;0.3-40&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## selectr &quot;0.3-1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## servr &quot;0.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## shiny &quot;1.0.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## shinyjs &quot;0.9&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## sourcetools &quot;0.1.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## SparseM &quot;1.77&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## stringi &quot;1.1.5&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## stringr &quot;1.2.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## tibble &quot;1.3.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## tidyr &quot;0.6.3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## tidyverse &quot;1.1.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## trimcluster &quot;0.1-2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## viridis &quot;0.4.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## viridisLite &quot;0.2.0&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## whisker &quot;0.3-2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## xml2 &quot;1.1.1&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## xtable &quot;1.8-2&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## yaml &quot;2.1.14&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## translations &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; Set priority = ‘high’ will display all base R packages installed.packages( priority=&#39;high&#39; ) [,c(3,2)] ## Version LibPath ## boot &quot;1.3-19&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## cluster &quot;2.0.6&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## foreign &quot;0.8-68&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## lattice &quot;0.20-35&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## MASS &quot;7.3-47&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## Matrix &quot;1.2-10&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## rpart &quot;4.1-11&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## survival &quot;2.41-3&quot; &quot;C:/Users/YKS-NIC/Documents/R/win-library/3.3&quot; ## base &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## boot &quot;1.3-18&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## class &quot;7.3-14&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## cluster &quot;2.0.5&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## codetools &quot;0.2-15&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## compiler &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## datasets &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## foreign &quot;0.8-67&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## graphics &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## grDevices &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## grid &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## KernSmooth &quot;2.23-15&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## lattice &quot;0.20-34&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## MASS &quot;7.3-45&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## Matrix &quot;1.2-8&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## methods &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## mgcv &quot;1.8-17&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## nlme &quot;3.1-131&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## nnet &quot;7.3-12&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## parallel &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## rpart &quot;4.1-10&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## spatial &quot;7.3-11&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## splines &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## stats &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## stats4 &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## survival &quot;2.40-1&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## tcltk &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## tools &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; ## utils &quot;3.3.3&quot; &quot;C:/Program Files/R/R-3.3.3/library&quot; 1.1.2 Package Install / Remove install.packages( c(&#39;ggplot&#39;, &#39;ggExtra&#39;)) 1.1.3 Package Update old.packages() ## list all old packages, their old version and available new version update.packages() ## need to input y/n/c for each old package to update update.packages( ask=FALSE ) ## automatically update all packages without asking "],
["1-2-data-types.html", "1.2 Data Types", " 1.2 Data Types 1.2.1 String 1.2.1.1 String Comparison 1.2.1.2 String Manipulations Splitting Combining Extracting 1.2.2 Dates Manipulation 1.2.2.1 Formatting 1.2.2.2 Dates Comparison 1.2.2.3 Dates Manipulation Days Between First Day of the Month Last Day of the Month Days/Months/Years After "],
["1-3-conditioinal-decision.html", "1.3 Conditioinal Decision", " 1.3 Conditioinal Decision "],
["1-4-looping.html", "1.4 Looping", " 1.4 Looping "],
["1-5-apply-family.html", "1.5 Apply Family", " 1.5 Apply Family 1.5.1 Overview Apply and its family is a useful function 1.5.2 apply 1.5.3 sapply 1.5.4 tapply -->"],
["2-data-generation.html", "Chapter 2 Data Generation", " Chapter 2 Data Generation Here is a review of existing methods. "],
["2-1-sequential-number.html", "2.1 Sequential Number", " 2.1 Sequential Number 2.1.1 Using : : return vector Produce sequantial integer with fix incremental or decremental by 1 Incremental 3:6 # incremental integer 1.25:9.25 # incremental decimal c(3:6, 4.25:8.25) # combination of multiple sequence ## [1] 3 4 5 6 ## [1] 1.25 2.25 3.25 4.25 5.25 6.25 7.25 8.25 9.25 ## [1] 3.00 4.00 5.00 6.00 4.25 5.25 6.25 7.25 8.25 Decremental 6:3 # decremental integer 9.25: 1.25 # decremental decimal ## [1] 6 5 4 3 ## [1] 9.25 8.25 7.25 6.25 5.25 4.25 3.25 2.25 1.25 2.1.2 Using seq : return vector Improvement from :, seq allows specifying incremental steps with by=. seq( from, to ) seq( from, to, by = ) seq( from, to, length.out = ) # potentially return decimal Incremental seq (3, 12) # default increment by=1 seq (3, 12, by = 4) # increment of integer seq (3.25, 12.25, by = 2.25) # increment of decimal ## [1] 3 4 5 6 7 8 9 10 11 12 ## [1] 3 7 11 ## [1] 3.25 5.50 7.75 10.00 12.25 Decremental - from must be larger than to, and by has to be negative. seq (12, 3) # default decrement by=-1 seq (12, 3, by = -4) # decrement of integer seq (12.25, 3.25, by = -2.25) # decrement of decimal ## [1] 12 11 10 9 8 7 6 5 4 3 ## [1] 12 8 4 ## [1] 12.25 10.00 7.75 5.50 3.25 Equal Spreading - with length.out= Equal Spreading of Integer seq (10, 50, length.out = 9) # incremental spreding of integer seq (50, 10, length.out = 9) # decremental spreading of integer ## [1] 10 15 20 25 30 35 40 45 50 ## [1] 50 45 40 35 30 25 20 15 10 Equal Spreading of Decimal seq (10.33, 50.55, length.out = 9) # incremental spreading of decimal seq (50.55, 10.33, length.out = 9) # decremental spreading of decimal ## [1] 10.3300 15.3575 20.3850 25.4125 30.4400 35.4675 40.4950 45.5225 50.5500 ## [1] 50.5500 45.5225 40.4950 35.4675 30.4400 25.4125 20.3850 15.3575 10.3300 "],
["2-2-random-number.html", "2.2 Random Number", " 2.2 Random Number 2.2.1 Random Unified Distribution runif( n ) # default min=0, max=1 runif( n, min=, max= ) set.seed(123) runif(5) # geenrate 5 numbers within default min=0, max=1 runif(5, min=3, max=9) ## [1] 0.2875775 0.7883051 0.4089769 0.8830174 0.9404673 ## [1] 3.273339 6.168633 8.354514 6.308610 5.739688 Notice that the numbers generated are uniformly distributed. hist(runif(300, min=3, max=9)) 2.2.2 Random Normal Distribution rnorm( n ) # default mean=0, sd=1 rnorm( n, mean=, sd= ) set.seed(123) rnorm(5) # geenrate 5 numbers within default min=0, max=1 rnorm(5, mean=3, sd=1.5) ## [1] -0.56047565 -0.23017749 1.55870831 0.07050839 0.12928774 ## [1] 5.572597 3.691374 1.102408 1.969721 2.331507 Notice that the numbers generated are uniformly distributed. hist(rnorm(300, mean=3, sd=1.5)) 2.2.3 Random Binomial Distribution The code below generates ‘n’ number of observations, each observation represents resuls of success for ‘size’ number of trials, and probability for success of each trial is ‘prob’: The numbers generated has the below characteristic: Discrete number Normally distributed (see histogram), mean mean approximately at the ’prob*size’ rbinorm( n, size, prob ) rbinorm( n=, size=, prob= ) \\(\\quad\\) n = number of observations \\(\\quad\\) size = number of trials per observations \\(\\quad\\) prob = probability of success for each trial rbinom(100, 10, 0.4) ## [1] 6 6 5 3 1 3 3 6 3 3 5 6 4 5 2 3 7 5 5 4 4 5 6 4 2 4 5 2 3 4 5 6 4 4 5 ## [36] 6 6 2 4 3 6 5 2 5 3 2 6 2 5 3 1 4 2 3 4 4 5 3 4 4 5 5 5 6 7 4 4 3 4 3 ## [71] 1 5 4 2 3 4 2 2 4 3 6 3 1 6 3 4 4 3 3 4 4 4 5 5 4 4 1 0 8 2 hist(rbinom(100, 10, 0.4)) 2.2.4 Drawing From A Bag A bag has been occupied with vector x (produced using : or any other vector) sample() will draw from this bag Specifying replace=T emulate that the drwan sample will be put back to the bag for next draw R will generate error if no enough samples to draw from ( size &gt; length(x) ) sample( x=, size= ) sample( x=, size=, replace=T) # recycle number even though it is not exhausted set.seed (123) sample (10, 5) # choose 5 numbers from the &#39;bag&#39; containing 1:10 sample (3:10, 5) # choose 5 numbers from the &#39;bag&#39; containing 3:10 bag = runif(8, min=3, max=9) # define the content of the bag sample (bag, 5, replace=T) # draw from the bag, recycling numbers ## [1] 3 8 4 7 6 ## [1] 3 6 8 5 4 ## [1] 7.065424 3.252357 3.252357 8.398950 8.398950 -->"],
["3-data-simulation.html", "Chapter 3 Data Simulation ", " Chapter 3 Data Simulation "],
["3-1-linear-simulation.html", "3.1 Linear Simulation", " 3.1 Linear Simulation gen_slinear = function(n = 50, start = 0, intercept = 0, coef = 1, mean = 0, sd = 1) { par(mfrow = c(2, 2)) if (start == -1) my.df = data.frame(x = rnorm(n)) # x is normally distributed random number else my.df = data.frame(x = start:n) # x from 0 to 50 my.df$f = my.df$x * coef + intercept # y = coef * x my.df$residuals = rnorm(length(my.df$x), mean = mean, sd = sd) my.df$y = my.df$f + my.df$residuals # introduce errors plot(my.df$x, my.df$f, main = paste(&#39;Perfect Fit Line:\\nf = &#39;, coef, &#39;x + &#39;, intercept)) plot(my.df$x, my.df$y, main = &#39;Constant Normal Errors Introduced&#39;) hist(my.df$y, main = &#39;Y Distribution&#39;) hist(my.df$residuals, main = &#39;Residuals Distribution&#39;) my.df } my.slinear = gen_slinear(n = 250, start=-1, intercept = 30, coef = 2, mean = 0, sd = 10) 3.1.1 Example of Random Normal X my.slinear = gen_slinear(n = 250, start=-1, intercept = 30, coef = 2, mean = 0, sd = 10) 3.1.2 Example of Sequantial X (non-random) my.slinear = gen_slinear(n = 250, start=0, intercept = 30, coef = 2, mean = 0, sd = 10) "],
["3-2-parabola-simulation.html", "3.2 Parabola Simulation", " 3.2 Parabola Simulation gen_parabola = function(n = 50, start = -1, root1 = -0.5, root2 = 0.5, mean = 0, sd = 1) { par(mfrow = c(2, 2)) if (start == -1) my.df = data.frame(x = rnorm(n)) # x is normally distributed random number else my.df = data.frame(x = start:n) # x from 0 to 50 my.df$f = (my.df$x - root1) * (my.df$x - root2) # y=(x-20)(x-30), root at x=20 and x=30 my.df$residuals = rnorm(length(my.df$x), mean = mean, sd = sd) my.df$y = my.df$f + my.df$residuals # introduce errors plot(my.df$x, my.df$f, main = paste(&#39;Perfect Fit Line:\\nf=(x-&#39;, root1, &#39;)(x-&#39;, root2, &#39;)&#39;)) plot(my.df$x, my.df$y, main = &#39;Constant Normal Errors Introduced&#39;) hist(my.df$y, main = &#39;Y Distribution&#39;) hist(my.df$residuals, main = &#39;Residuals Distribution&#39;) my.df } 3.2.1 Example of Random Normal X my.parabola = gen_parabola(n = 250, start=-1, root1 = 0.25, root2 = .5, sd = 1000) 3.2.2 Example of Sequantial X (non-random) my.parabola = gen_parabola(n = 50, start=0, root1 = 20, root2 = 30, sd = 1000) "],
["3-3-polynomial-simulation.html", "3.3 Polynomial Simulation", " 3.3 Polynomial Simulation \\[ y = \\beta_0 + \\beta_1 x + \\beta_2 x^2 + \\beta_3 x^3 + ...+ \\beta_k x^k \\] -->"],
["4-data-summarization.html", "Chapter 4 Data Summarization", " Chapter 4 Data Summarization This capter explore manipulating table-like data, summarization and aggregation. "],
["4-1-sample-data.html", "4.1 Sample Data", " 4.1 Sample Data Sample data used simulate two categorical-alike feature, and two numeric value feature: dept is random character between ‘D1’, ‘D2’ and ‘D3’ grp is random character with randomly generated ‘G1’, ‘G2’ value1 represents numeric value, normally distributed at mean 50 value2 is numeric value, normally distributed at mean 25 set.seed(1234) my.df = data.frame( com = paste(&#39;C&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), dept = paste(&#39;D&#39;,sample(1:3, 100, replace = T),sep=&#39;&#39;), grp = paste(&#39;G&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), team = paste(&#39;T&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), value1 = rnorm(1:100, mean = 50, sd = 5), value2 = rnorm(1:100, mean = 20, sd = 3), value3 = rnorm(1:100, mean = 5, sd = 1), stringsAsFactors = F ) head(my.df) ## com dept grp team value1 value2 value3 ## 1 C1 D1 G2 T1 52.42613 18.26013 3.773185 ## 2 C2 D2 G2 T2 53.48384 17.14016 5.036153 ## 3 C2 D1 G1 T2 50.92757 19.46171 4.578607 ## 4 C2 D1 G2 T1 53.50367 23.02942 4.100636 ## 5 C2 D1 G2 T2 51.55841 20.07088 5.417441 ## 6 C2 D1 G2 T1 53.80231 18.05292 5.153445 "],
["4-2-frequency-table.html", "4.2 Frequency Table", " 4.2 Frequency Table table return table object (which is also array) that report frequency count base of categorical-alike data provided. table has the below data type characteristics. Note that only 2-dimensional table object is a matrix Dimension is.atomic is.vector is.matrix is.array is.table t1 T F F T T t2 T F T T T t3 T F F T T t4 T F F T T ftable is technically a matrix with two dimensional data (it flatten multiple dimension data). It has below data type characteristic. Dimension is.atomic is.vector is.matrix is.array is.table 1 T F T T F 2 T F T T F 3 T F T T F 4 T F T T F 4.2.1 Single Dimension Data t1 = table( my.df$com ) t1 ## ## C1 C2 ## 55 45 str(t1) ## &#39;table&#39; int [1:2(1d)] 55 45 ## - attr(*, &quot;dimnames&quot;)=List of 1 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; 4.2.2 Two Dimension Data t2 = table( my.df$com, my.df$dept ) t2 ## ## D1 D2 D3 ## C1 16 18 21 ## C2 15 18 12 str(t2) ## &#39;table&#39; int [1:2, 1:3] 16 15 18 18 21 12 ## - attr(*, &quot;dimnames&quot;)=List of 2 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; 4.2.3 Three Dimension Data When table contain three or more dimension, use ftable (flat table) to put multi dimension table into one flat output t3 = table( my.df$com, my.df$dept, my.df$grp ) t3 ## , , = G1 ## ## ## D1 D2 D3 ## C1 10 7 11 ## C2 7 9 4 ## ## , , = G2 ## ## ## D1 D2 D3 ## C1 6 11 10 ## C2 8 9 8 str(t3) ## &#39;table&#39; int [1:2, 1:3, 1:2] 10 7 7 9 11 4 6 8 11 9 ... ## - attr(*, &quot;dimnames&quot;)=List of 3 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; f3 = ftable( t3 ) f3 ## G1 G2 ## ## C1 D1 10 6 ## D2 7 11 ## D3 11 10 ## C2 D1 7 8 ## D2 9 9 ## D3 4 8 str(f3) ## &#39;ftable&#39; int [1:6, 1:2] 10 7 11 7 9 4 6 11 10 8 ... ## - attr(*, &quot;row.vars&quot;)=List of 2 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## - attr(*, &quot;col.vars&quot;)=List of 1 ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; 4.2.4 Four Dimension Data When table contain three or more dimension, use ftable (flat table) to put multi dimension table into one flat output t4 = table( my.df$com, my.df$dept, my.df$grp, my.df$team ) t4 ## , , = G1, = T1 ## ## ## D1 D2 D3 ## C1 4 5 4 ## C2 4 5 1 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 ## C1 3 6 6 ## C2 5 5 4 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 ## C1 6 2 7 ## C2 3 4 3 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 ## C1 3 5 4 ## C2 3 4 4 str(t4) ## &#39;table&#39; int [1:2, 1:3, 1:2, 1:2] 4 4 5 5 4 1 3 5 6 5 ... ## - attr(*, &quot;dimnames&quot;)=List of 4 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; ## ..$ : chr [1:2] &quot;T1&quot; &quot;T2&quot; f4 = ftable( t4 ) f4 ## T1 T2 ## ## C1 D1 G1 4 6 ## G2 3 3 ## D2 G1 5 2 ## G2 6 5 ## D3 G1 4 7 ## G2 6 4 ## C2 D1 G1 4 3 ## G2 5 3 ## D2 G1 5 4 ## G2 5 4 ## D3 G1 1 3 ## G2 4 4 str(f4) ## &#39;ftable&#39; int [1:12, 1:2] 4 3 5 6 4 6 4 5 5 5 ... ## - attr(*, &quot;row.vars&quot;)=List of 3 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; ## - attr(*, &quot;col.vars&quot;)=List of 1 ## ..$ : chr [1:2] &quot;T1&quot; &quot;T2&quot; 4.2.5 Proportion Table prop.table converts table or ftable object into proportion. 4.2.5.1 Proportion Table on ‘table’ object pt1 = prop.table( t1 ) pt2 = prop.table( t2 ) pt1 ## ## C1 C2 ## 0.55 0.45 pt2 ## ## D1 D2 D3 ## C1 0.16 0.18 0.21 ## C2 0.15 0.18 0.12 4.2.5.2 Proportion Table on ‘ftable’ object pf3 = prop.table( f3 ) pf4 = prop.table( f4 ) pf3 ## G1 G2 ## ## C1 D1 0.10 0.06 ## D2 0.07 0.11 ## D3 0.11 0.10 ## C2 D1 0.07 0.08 ## D2 0.09 0.09 ## D3 0.04 0.08 pf4 ## T1 T2 ## ## C1 D1 G1 0.04 0.06 ## G2 0.03 0.03 ## D2 G1 0.05 0.02 ## G2 0.06 0.05 ## D3 G1 0.04 0.07 ## G2 0.06 0.04 ## C2 D1 G1 0.04 0.03 ## G2 0.05 0.03 ## D2 G1 0.05 0.04 ## G2 0.05 0.04 ## D3 G1 0.01 0.03 ## G2 0.04 0.04 4.2.6 Adding Margin Info 4.2.6.1 Margin Info on ‘table’ object addmargins( t2 ) ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 addmargins( t3 ) ## , , = G1 ## ## ## D1 D2 D3 Sum ## C1 10 7 11 28 ## C2 7 9 4 20 ## Sum 17 16 15 48 ## ## , , = G2 ## ## ## D1 D2 D3 Sum ## C1 6 11 10 27 ## C2 8 9 8 25 ## Sum 14 20 18 52 ## ## , , = Sum ## ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 addmargins( t4 ) ## , , = G1, = T1 ## ## ## D1 D2 D3 Sum ## C1 4 5 4 13 ## C2 4 5 1 10 ## Sum 8 10 5 23 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 Sum ## C1 3 6 6 15 ## C2 5 5 4 14 ## Sum 8 11 10 29 ## ## , , = Sum, = T1 ## ## ## D1 D2 D3 Sum ## C1 7 11 10 28 ## C2 9 10 5 24 ## Sum 16 21 15 52 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 Sum ## C1 6 2 7 15 ## C2 3 4 3 10 ## Sum 9 6 10 25 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 Sum ## C1 3 5 4 12 ## C2 3 4 4 11 ## Sum 6 9 8 23 ## ## , , = Sum, = T2 ## ## ## D1 D2 D3 Sum ## C1 9 7 11 27 ## C2 6 8 7 21 ## Sum 15 15 18 48 ## ## , , = G1, = Sum ## ## ## D1 D2 D3 Sum ## C1 10 7 11 28 ## C2 7 9 4 20 ## Sum 17 16 15 48 ## ## , , = G2, = Sum ## ## ## D1 D2 D3 Sum ## C1 6 11 10 27 ## C2 8 9 8 25 ## Sum 14 20 18 52 ## ## , , = Sum, = Sum ## ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 4.2.6.2 Margin Info on ‘ftable’ object addmargins( f3 ) ## Sum ## 10 6 16 ## 7 11 18 ## 11 10 21 ## 7 8 15 ## 9 9 18 ## 4 8 12 ## Sum 48 52 100 addmargins( f4 ) ## Sum ## 4 6 10 ## 3 3 6 ## 5 2 7 ## 6 5 11 ## 4 7 11 ## 6 4 10 ## 4 3 7 ## 5 3 8 ## 5 4 9 ## 5 4 9 ## 1 3 4 ## 4 4 8 ## Sum 52 48 100 4.2.7 Proportion Table with Margin First to obtain the proportion table, then only add the margin. addmargins( prop.table( t2 )) ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( t3 )) ## , , = G1 ## ## ## D1 D2 D3 Sum ## C1 0.10 0.07 0.11 0.28 ## C2 0.07 0.09 0.04 0.20 ## Sum 0.17 0.16 0.15 0.48 ## ## , , = G2 ## ## ## D1 D2 D3 Sum ## C1 0.06 0.11 0.10 0.27 ## C2 0.08 0.09 0.08 0.25 ## Sum 0.14 0.20 0.18 0.52 ## ## , , = Sum ## ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( t4 )) ## , , = G1, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.04 0.05 0.04 0.13 ## C2 0.04 0.05 0.01 0.10 ## Sum 0.08 0.10 0.05 0.23 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.03 0.06 0.06 0.15 ## C2 0.05 0.05 0.04 0.14 ## Sum 0.08 0.11 0.10 0.29 ## ## , , = Sum, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.07 0.11 0.10 0.28 ## C2 0.09 0.10 0.05 0.24 ## Sum 0.16 0.21 0.15 0.52 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.06 0.02 0.07 0.15 ## C2 0.03 0.04 0.03 0.10 ## Sum 0.09 0.06 0.10 0.25 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.03 0.05 0.04 0.12 ## C2 0.03 0.04 0.04 0.11 ## Sum 0.06 0.09 0.08 0.23 ## ## , , = Sum, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.09 0.07 0.11 0.27 ## C2 0.06 0.08 0.07 0.21 ## Sum 0.15 0.15 0.18 0.48 ## ## , , = G1, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.10 0.07 0.11 0.28 ## C2 0.07 0.09 0.04 0.20 ## Sum 0.17 0.16 0.15 0.48 ## ## , , = G2, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.06 0.11 0.10 0.27 ## C2 0.08 0.09 0.08 0.25 ## Sum 0.14 0.20 0.18 0.52 ## ## , , = Sum, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( f3 )) ## Sum ## 0.10 0.06 0.16 ## 0.07 0.11 0.18 ## 0.11 0.10 0.21 ## 0.07 0.08 0.15 ## 0.09 0.09 0.18 ## 0.04 0.08 0.12 ## Sum 0.48 0.52 1.00 addmargins( prop.table( f4 )) ## Sum ## 0.04 0.06 0.10 ## 0.03 0.03 0.06 ## 0.05 0.02 0.07 ## 0.06 0.05 0.11 ## 0.04 0.07 0.11 ## 0.06 0.04 0.10 ## 0.04 0.03 0.07 ## 0.05 0.03 0.08 ## 0.05 0.04 0.09 ## 0.05 0.04 0.09 ## 0.01 0.03 0.04 ## 0.04 0.04 0.08 ## Sum 0.52 0.48 1.00 "],
["4-3-data-aggregation.html", "4.3 Data Aggregation", " 4.3 Data Aggregation This chapter explore multiple methods to group data columns and computes value within groups. 4.3.1 aggretate - base R Aggregate is a very useful base R function and provides quick way to group data and values: Input in list/data.frame, computes and output new data.frame. It groups categorical variable(s) and compute value variable(s) based on function FUN. FUN can be min, max, mean, sd, sum or length (frequency count). ONLY ONE function is supported, and it applies to all value variables !!! 4.3.1.1 Basic Syntax (formula method) - data source is data.frame The formula method use ‘data’ parameter and therefore apply for single data source only. The objective is simplicy and without flexibility to customize column names aggregate (data = df, formula, FUN = function) Formula in the form: value~categorical one value variable ~ one categorical variable aggregate (data = my.df, value1 ~ grp, FUN = length) ## grp value1 ## 1 G1 48 ## 2 G2 52 one value variable ~ multiple categorical variables aggregate (data = my.df, value1 ~ grp + dept, FUN = length) ## grp dept value1 ## 1 G1 D1 17 ## 2 G2 D1 14 ## 3 G1 D2 16 ## 4 G2 D2 20 ## 5 G1 D3 15 ## 6 G2 D3 18 multiple value variables ~ one categorical variable, use cbind() aggregate (data = my.df, cbind(value1,value2) ~ grp, FUN = length) ## grp value1 value2 ## 1 G1 48 48 ## 2 G2 52 52 multiple value variables ~ multiple categorical variable aggregate (data = my.df, cbind(value1,value2) ~ grp + dept, FUN = length) ## grp dept value1 value2 ## 1 G1 D1 17 17 ## 2 G2 D1 14 14 ## 3 G1 D2 16 16 ## 4 G2 D2 20 20 ## 5 G1 D3 15 15 ## 6 G2 D3 18 18 ALL value variables ~ multiple categorical variable, use dot notation Change from FUN=length to sum results in error because sum() cannot be applied to non-numerical variable ‘team’ aggregate (data = my.df, . ~ grp + dept, FUN = length) ## grp dept com team value1 value2 value3 ## 1 G1 D1 17 17 17 17 17 ## 2 G2 D1 14 14 14 14 14 ## 3 G1 D2 16 16 16 16 16 ## 4 G2 D2 20 20 20 20 20 ## 5 G1 D3 15 15 15 15 15 ## 6 G2 D3 18 18 18 18 18 4.3.1.2 Advance Syntax (by method) - data source is either list or data.frame The advantage of ’by method’ are: Can use list/data.frame subset method to choose column to display, hence flexible Can customize output column names (list subset method only) Flexibility to use multiple data sources, hence ‘data’ is not used and has no effect if specified Using list subseting: column name is not preserved, hence must specify meaningful column names. If not supplied, generic names and undesirable column names derived from data value will be used as column name aggregate (x = list(…value_variables…), by = list(…categorical_variables…), FUN = function) aggregate (x = list( v1_mean = my.df$value1, my.df$value2 ), by = list( my.df$grp, DEPT = my.df$dept), FUN=mean) ## Group.1 DEPT v1_mean ## 1 G1 D1 49.19603 ## 2 G2 D1 50.23397 ## 3 G1 D2 50.64011 ## 4 G2 D2 52.20157 ## 5 G1 D3 51.81631 ## 6 G2 D3 50.34312 ## c.18.2601290329418..17.1401638941593..19.4617142391631..23.0294246448329.. ## 1 19.74277 ## 2 20.99601 ## 3 19.87320 ## 4 19.65301 ## 5 19.13836 ## 6 20.54948 Using data.frame subseting: column names are preserved and no option to change. Notice attempt below to change the column name does not succeed aggregate( x = df[,c(…)], by = df[,c(…)]), FUN = function) aggregate( x = df[, p:q], by = df[,s:t]), FUN = function) aggregate(x=my.df[, c(v1_mean=&#39;value1&#39;, &#39;value2&#39;)], by=my.df[,c(GRP=&#39;grp&#39;, &#39;dept&#39;)], FUN=mean) # aggregate(x = my.df[, 4:5], by = my.df[, 1:2], FUN = mean) # produce similar result as above ## grp dept value1 value2 ## 1 G1 D1 49.19603 19.74277 ## 2 G2 D1 50.23397 20.99601 ## 3 G1 D2 50.64011 19.87320 ## 4 G2 D2 52.20157 19.65301 ## 5 G1 D3 51.81631 19.13836 ## 6 G2 D3 50.34312 20.54948 4.3.2 group_by - dplyr Package -->"],
["5-data-preprocessing.html", "Chapter 5 Data Preprocessing ", " Chapter 5 Data Preprocessing "],
["5-1-handling-missing-data.html", "5.1 Handling Missing Data", " 5.1 Handling Missing Data 5.1.1 Detecting Missing Data 5.1.2 Removing Missing Data "],
["5-2-scaling-data.html", "5.2 Scaling Data", " 5.2 Scaling Data 5.2.1 Sample Data Scaling section will use sample data generated as below: set.seed(1234) my.df = data.frame( id = paste(&#39;ID_&#39;, 1:5, sep = &#39;&#39;), value1 = sample(50:100, 5), value2 = sample(10:50, 5), stringsAsFactors = F ) my.df ## id value1 value2 ## 1 ID_1 55 36 ## 2 ID_2 81 10 ## 3 ID_3 79 19 ## 4 ID_4 98 35 ## 5 ID_5 90 29 5.2.2 Z-Score Scaling scale apply transformation column-wise, for columns within matrix or dataframe scale return a matrix scale (x, center=T, scale=T) # default S-Score transformation \\(\\quad\\) center = T (default) means value minus with mean \\(\\quad\\) scale = T (default) means value divide by sd \\(\\quad\\) \\(\\quad\\) output scaled:center --&gt; mean \\(\\quad\\) \\(\\quad\\) output scaled:scale --&gt; sd scale( my.df[,2:3] ) ## value1 value2 ## [1,] -1.58066858 0.9170971 ## [2,] 0.02469795 -1.4206014 ## [3,] -0.09879179 -0.6113981 ## [4,] 1.07436067 0.8271856 ## [5,] 0.58040174 0.2877167 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 80.6 25.8 ## attr(,&quot;scaled:scale&quot;) ## value1 value2 ## 16.19568 11.12205 scale( my.df[,2:3], scale=F ) ## value1 value2 ## [1,] -25.6 10.2 ## [2,] 0.4 -15.8 ## [3,] -1.6 -6.8 ## [4,] 17.4 9.2 ## [5,] 9.4 3.2 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 80.6 25.8 5.2.3 Min Max Scaling Min-Max scaling will transform all numbers between 0 and 1. Easiest way to perform this transformation is to write a function then apply. min_max = function(x){(x-min(x))/(max(x)-min(x))} apply( my.df[,2:3], MARGIN = 2, FUN = min_max ) ## 2 means column-wise ## value1 value2 ## [1,] 0.0000000 1.0000000 ## [2,] 0.6046512 0.0000000 ## [3,] 0.5581395 0.3461538 ## [4,] 1.0000000 0.9615385 ## [5,] 0.8139535 0.7307692 -->"],
["6-sort-and-filter-data.html", "Chapter 6 Sort and Filter Data ", " Chapter 6 Sort and Filter Data "],
["6-1-sorting-data.html", "6.1 Sorting Data", " 6.1 Sorting Data "],
["6-2-filtering-data.html", "6.2 Filtering Data", " 6.2 Filtering Data -->"],
["7-graphic-visualization.html", "Chapter 7 Graphic Visualization", " Chapter 7 Graphic Visualization This chapter compares various method to plotting using base-R and ggplot. "],
["7-1-library-used.html", "7.1 Library used", " 7.1 Library used Loading necessary library as below: Base R library already included functions: ** hist, plot, barplot, boxplot** library(ggplot2) ## ggplot, qplot "],
["7-2-sample-data-2.html", "7.2 Sample Data", " 7.2 Sample Data This chapter uses the sample data generate with below code. The idea is to simulate two categorical-alike feature, and two numeric value feature: dept is random character between ‘D1’, ‘D2’, ‘D3’, ‘D4’ and ‘D5’ grp is random character with randomly generated ‘G1’, ‘G2’ value1 represents numeric value, normally distributed at mean 50 value2 is numeric value, normally distributed at mean 25 set.seed(1234) my.df = data.frame( dept = paste(&#39;D&#39;,sample(1:5, 100, replace = T),sep=&#39;&#39;), grp = paste(&#39;G&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), value1 = rnorm(1:100, mean = 50, sd = 5), value2 = rnorm(1:100, mean = 20, sd = 3), stringsAsFactors = F ) head(my.df) ## dept grp value1 value2 ## 1 D1 G1 52.07262 21.45568 ## 2 D4 G2 47.62641 22.09031 ## 3 D4 G1 50.32997 20.55654 ## 4 D4 G1 47.48761 22.10220 ## 5 D5 G1 45.87001 20.93504 ## 6 D4 G1 50.83495 22.28139 "],
["7-3-histogram.html", "7.3 Histogram", " 7.3 Histogram 7.3.1 Single Dimension Data Require x as numerical data In hist, binwidth setting is not available, only breaks (number of bins) can be specified Default hist/ggplot/qplot number of bins is 30 In qplot, single x numerical variable default to histogram You can’t specify both bins/breaks and bindwidth together, as it implies each other par(mfrow=c(1,2)) hist (my.df$value1) # default breaks = 30 hist (my.df$value1, breaks=3) qplot (data = my.df, x=value1) qplot (data = my.df, x=value1, geom=&#39;histogram&#39;) qplot (data = my.df, x=value1, bins=15) ggplot(data = my.df, aes(x=value1)) + geom_histogram() # default bins = 30 ggplot(data = my.df, aes(x=value1)) + geom_histogram(bins = 15) ggplot(data = my.df, aes(x=value1)) + geom_histogram(binwidth = 10) 7.3.2 Two Dimension Data x = numerical data fill = categorica-alike data qplot (data = my.df, x=value1, fill=grp, geom=&#39;histogram&#39;) ggplot(data = my.df, aes(x=value1, fill=grp)) + geom_histogram() "],
["7-4-scatter-plot.html", "7.4 Scatter Plot", " 7.4 Scatter Plot 7.4.1 Two Dimension Data Use scatter plot to represent correlation between two numeric variables x = number, y = number qplot default to geom_point when two numerical value is supplied for x and y plot (my.df$value1, my.df$value2) qplot (data = my.df, x = value1, y = value2) qplot (data = my.df, x = value1, y = value2, geom=&#39;point&#39;) ggplot(data = my.df, aes(x=value1, y=value2)) + geom_point() 7.4.2 Two + One Dimension Data Base-R does not support extra dimension visualization In qplot/ggplot, the third dimension of data can be represented by assigning color parameter to the third variable Note that fill has not effect on scatter plot. fill should only be used for bar like chart eg. geom_hist or gem_bar plot (my.df$value1, my.df$value2) qplot (data = my.df, x = value1, y = value2, color = grp, geom=&#39;point&#39;) ggplot(data = my.df, aes(x=value1, y=value2, color = grp)) + geom_point() ggplot(data = my.df, aes(x=value1, y=value2, fill = grp)) + geom_point() "],
["7-5-bar-chart.html", "7.5 Bar Chart", " 7.5 Bar Chart 7.5.1 Single Dimension Data Use bar to repfresent frequency chart plot requre a factor to plot frequency chart barplot require conversion of vector into table for plotting qplot default to geom_bar when single categorical-alike feature is used par(mfrow=c(1,2)) plot(as.factor(my.df$dept)) barplot(table(my.df$dept)) qplot (data = my.df, x=dept) qplot (data = my.df, x=dept, geom=&#39;bar&#39;) ggplot(data = my.df, aes(x=dept)) + geom_bar() 7.5.2 Two + One Dimension Data Use fill to introduce extra variable visualizion in filling the bar Use color to have the extra variable represented with border color qplot (data = my.df, dept, fill = grp) qplot (data = my.df, x = dept, fill = grp, geom=&#39;bar&#39;) ggplot(data = my.df, aes(x = dept, fill = grp)) + geom_bar() ggplot(data = my.df, aes(x = dept, color= grp)) + geom_bar() 7.5.3 Reordering qplot (data = my.df, x=dept) qplot (data = my.df, x=dept, geom=&#39;bar&#39;) ggplot(data = my.df, aes(x=dept)) + geom_bar() 7.5.4 Positioning qplot does not support positioning For ggplot/qplot, default position is stack position = ‘dodge’ similar to position = position_dodge(), however the later is more flexible with ability to adjust overlapping level between sub-bar (default is 0.9) g = ggplot(data = my.df, aes(x=dept, fill=grp)) g + geom_bar(position=&#39;stack&#39;) # default position g + geom_bar(position=&#39;dodge&#39;) g + geom_bar(position=position_dodge()) # default 0.9 g + geom_bar(position=position_dodge(0.5)) g + geom_bar(position=position_dodge(1.0)) 7.5.5 In-Bar Text Labeling "],
["7-6-box-plot.html", "7.6 Box Plot", " 7.6 Box Plot 7.6.1 One Dimension Data In boxplot(), only single variable need to be supplied In ggplot/qplot, variable x and y is required. Variable y is the actual value, variable x is the group variable. Case of one dimension, use x=’’ when no grouping is desired boxplot(my.df$value1) qplot (data = my.df, x = &#39;&#39; , y = value1, geom=&#39;boxplot&#39;) ggplot (data = my.df, aes( x= &#39;&#39;, y=value1 )) + geom_boxplot() 7.6.2 Two Dimension Data In boxplot, use ~ to specify y~x, where x is grouping variable boxplot(data = my.df, value1~grp) qplot (data = my.df, x = grp , y = value1, geom=&#39;boxplot&#39;) ggplot (data = my.df, aes(x=grp, y=value1)) + geom_boxplot() 7.6.3 Two + One Dimension Data Extra dimension can be included in for x-axis In boxplot, use + to specify extra dimension In qplot/ggplot, use interaction to specify extra dimension boxplot(data = my.df, value1~grp+dept) qplot (data = my.df, x=interaction(grp,dept) , y=value1, geom=&#39;boxplot&#39;) ggplot (data = my.df, aes(x=interaction(grp,dept) , y=value1)) + geom_boxplot() "],
["7-7-pie-chart.html", "7.7 Pie Chart", " 7.7 Pie Chart -->"],
["8-statistics.html", "Chapter 8 Statistics ", " Chapter 8 Statistics "],
["8-1-sample-data-3.html", "8.1 Sample Data", " 8.1 Sample Data This chapter uses the sample data generate with below code. The idea is to simulate two categorical-alike feature, and two numeric value feature: dept is random character between ‘D1’, ‘D2’, ‘D3’, ‘D4’ and ‘D5’ grp is random character with randomly generated ‘G1’, ‘G2’ value1 represents numeric value, normally distributed at mean 50 value2 is numeric value, normally distributed at mean 25 is.matrix(state.x77) str(state.x77) dimnames(state.x77)[1] dimnames(state.x77)[2] head(state.x77) ## [1] TRUE ## num [1:50, 1:8] 3615 365 2212 2110 21198 ... ## - attr(*, &quot;dimnames&quot;)=List of 2 ## ..$ : chr [1:50] &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; ... ## ..$ : chr [1:8] &quot;Population&quot; &quot;Income&quot; &quot;Illiteracy&quot; &quot;Life Exp&quot; ... ## [[1]] ## [1] &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; ## [5] &quot;California&quot; &quot;Colorado&quot; &quot;Connecticut&quot; &quot;Delaware&quot; ## [9] &quot;Florida&quot; &quot;Georgia&quot; &quot;Hawaii&quot; &quot;Idaho&quot; ## [13] &quot;Illinois&quot; &quot;Indiana&quot; &quot;Iowa&quot; &quot;Kansas&quot; ## [17] &quot;Kentucky&quot; &quot;Louisiana&quot; &quot;Maine&quot; &quot;Maryland&quot; ## [21] &quot;Massachusetts&quot; &quot;Michigan&quot; &quot;Minnesota&quot; &quot;Mississippi&quot; ## [25] &quot;Missouri&quot; &quot;Montana&quot; &quot;Nebraska&quot; &quot;Nevada&quot; ## [29] &quot;New Hampshire&quot; &quot;New Jersey&quot; &quot;New Mexico&quot; &quot;New York&quot; ## [33] &quot;North Carolina&quot; &quot;North Dakota&quot; &quot;Ohio&quot; &quot;Oklahoma&quot; ## [37] &quot;Oregon&quot; &quot;Pennsylvania&quot; &quot;Rhode Island&quot; &quot;South Carolina&quot; ## [41] &quot;South Dakota&quot; &quot;Tennessee&quot; &quot;Texas&quot; &quot;Utah&quot; ## [45] &quot;Vermont&quot; &quot;Virginia&quot; &quot;Washington&quot; &quot;West Virginia&quot; ## [49] &quot;Wisconsin&quot; &quot;Wyoming&quot; ## ## [[1]] ## [1] &quot;Population&quot; &quot;Income&quot; &quot;Illiteracy&quot; &quot;Life Exp&quot; &quot;Murder&quot; ## [6] &quot;HS Grad&quot; &quot;Frost&quot; &quot;Area&quot; ## ## Population Income Illiteracy Life Exp Murder HS Grad Frost ## Alabama 3615 3624 2.1 69.05 15.1 41.3 20 ## Alaska 365 6315 1.5 69.31 11.3 66.7 152 ## Arizona 2212 4530 1.8 70.55 7.8 58.1 15 ## Arkansas 2110 3378 1.9 70.66 10.1 39.9 65 ## California 21198 5114 1.1 71.71 10.3 62.6 20 ## Colorado 2541 4884 0.7 72.06 6.8 63.9 166 ## Area ## Alabama 50708 ## Alaska 566432 ## Arizona 113417 ## Arkansas 51945 ## California 156361 ## Colorado 103766 set.seed(1234) my.df = data.frame( dept = paste(&#39;D&#39;,sample(1:5, 100, replace = T),sep=&#39;&#39;), grp = paste(&#39;G&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), value1 = rnorm(1:100, mean = 50, sd = 5), value2 = rnorm(1:100, mean = 20, sd = 3), stringsAsFactors = T ) head(my.df) ## dept grp value1 value2 ## 1 D1 G1 52.07262 21.45568 ## 2 D4 G2 47.62641 22.09031 ## 3 D4 G1 50.32997 20.55654 ## 4 D4 G1 47.48761 22.10220 ## 5 D5 G1 45.87001 20.93504 ## 6 D4 G1 50.83495 22.28139 "],
["8-2-descriptive-summary.html", "8.2 Descriptive Summary", " 8.2 Descriptive Summary 8.2.1 Single Vector summary provides min, max, quantiles, mean for numerical vector. But it doesn’t provide standard deviation. Other functions below take single vector as input, and output a single value summary(my.df$value1) mean (my.df$value1) max (my.df$value1) median (my.df$value1) sd (my.df$value1) # standard deviation var (my.df$value1) # variance length (my.df$value1) # number of elements ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 35.72 47.20 50.16 50.21 53.14 65.22 ## [1] 50.20622 ## [1] 65.21883 ## [1] 50.16402 ## [1] 5.160937 ## [1] 26.63527 ## [1] 100 8.2.2 Multiple Vectors summary can be used for multiple columns in a data frame, which each columns is evaluated For factor data, summary provides frequency count For individual functions (mean, max, min, sd, var) that take only single vecotr and output single value, use sapply to provide calculation for multiple columns of a dataframe summary (my.df) sapply (my.df[,3:4], min) sapply (my.df[,3:4], max) sapply (my.df[,3:4], median) sapply (my.df[,3:4], sd) sapply (my.df[,3:4], var) ## dept grp value1 value2 ## D1:25 G1:48 Min. :35.72 Min. :10.30 ## D2:26 G2:52 1st Qu.:47.20 1st Qu.:18.87 ## D3:17 Median :50.16 Median :20.83 ## D4:17 Mean :50.21 Mean :20.46 ## D5:15 3rd Qu.:53.14 3rd Qu.:22.05 ## Max. :65.22 Max. :28.76 ## value1 value2 ## 35.72121 10.30054 ## value1 value2 ## 65.21883 28.75742 ## value1 value2 ## 50.16402 20.83363 ## value1 value2 ## 5.160937 2.880463 ## value1 value2 ## 26.635268 8.297068 8.2.3 Custom Function Custom function can be built to accept single vector and return single vector Use sapply with the custom function to sweep through multiple columns in a dataframe and return a matrix (with row and col names) as a result mystats = function(x, na.omit=FALSE){ if (na.omit) x =x[!is.na(x)] m = mean(x) med = median(x) v = var(x) s = sd(x) n = length(x) skew = sum((x-m)^3/s^3)/n kurt = sum((x-m)^4/s^4)/n - 3 return(c(length=n, mean=m, median=med, stdev=s, skew=skew, kurtosis=kurt)) } sapply(my.df[,3:4], mystats) ## value1 value2 ## length 100.00000000 100.0000000 ## mean 50.20621590 20.4638110 ## median 50.16401641 20.8336304 ## stdev 5.16093675 2.8804631 ## skew -0.01832526 -0.2217617 ## kurtosis 0.52800386 1.0046773 "],
["8-3-t-test.html", "8.3 T-Test", " 8.3 T-Test "],
["8-4-covariance-correlation.html", "8.4 Covariance / Correlation", " 8.4 Covariance / Correlation If two variables are independent, their covariance/correlation is 0. But, having a covariance/correlation of 0 does not imply the variables are independent. 8.4.1 Covariance \\[Pearson - Cov(X,Y)= \\frac{\\sum_{i=1}^n (X_i-\\bar{X})*(Y_i-\\bar{Y})}{n-1}\\] Covariance doesn’t really tell you about the strength of the relationship between the two variables. - A large covariance can simply means the variables are made of large numbers, doesn’t means that the relation are strong. Hence correlation (scaled covariance) is a better indicator of the relation strenght. 8.4.2 Correlation \\[Pearson-Cor(X,Y)= \\frac{Cov(X,Y)}{sd(X)sd(Y)}\\] Correlation is a scaled version of covariance that takes on values between -1 and 1 Correlation are used to measure the strength of relationship among linearly related quntitative variables (numerical) 0 indicates no correlation. +1 and -1 indicates perfect correlation cor(x, y, use= , method= ) \\(\\quad\\) x= matrix or dataframe \\(\\quad\\) y= matrix or dataframe, default = x \\(\\quad\\) method= pearson, spearman, kendall, default is pearson \\(\\quad\\) use= everthing:missing value will set to missing, complete.obs:listwise deletion, pairwise.complete.obs:pairwise deletion If y is not specified, you get cross matrices by default (all variables crossed with all other variables). states = state.x77[,1:5] cor(states) cor(states, method = &#39;kendall&#39;) ## Population Income Illiteracy Life Exp Murder ## Population 1.00000000 0.2082276 0.1076224 -0.06805195 0.3436428 ## Income 0.20822756 1.0000000 -0.4370752 0.34025534 -0.2300776 ## Illiteracy 0.10762237 -0.4370752 1.0000000 -0.58847793 0.7029752 ## Life Exp -0.06805195 0.3402553 -0.5884779 1.00000000 -0.7808458 ## Murder 0.34364275 -0.2300776 0.7029752 -0.78084575 1.0000000 ## Population Income Illiteracy Life Exp Murder ## Population 1.00000000 0.08408163 0.2123063 -0.06865555 0.2364983 ## Income 0.08408163 1.00000000 -0.1970811 0.21904389 -0.1448450 ## Illiteracy 0.21230629 -0.19708113 1.0000000 -0.42852098 0.5155359 ## Life Exp -0.06865555 0.21904389 -0.4285210 1.00000000 -0.5997547 ## Murder 0.23649826 -0.14484495 0.5155359 -0.59975465 1.0000000 If x and y are specified, you can produce non squared correlation matrices with only the variables specified for both x and y axis cor(states[,1:5], states[,3:5]) ## Illiteracy Life Exp Murder ## Population 0.1076224 -0.06805195 0.3436428 ## Income -0.4370752 0.34025534 -0.2300776 ## Illiteracy 1.0000000 -0.58847793 0.7029752 ## Life Exp -0.5884779 1.00000000 -0.7808458 ## Murder 0.7029752 -0.78084575 1.0000000 8.4.3 Correlation Test for significance From the cor function, we know that Murder rate and Illiteracy are highly correlated (&gt;0.7). However, is this merely by chance, or it is statistically significant that there are indeed correlated ? To answer this question, we need to perform hypotesis testing: \\(H_0\\) : (population) correlation betwen Murder rate and Illiteracy is zero \\(H_1\\) : (sample) correlation between Murder rate and Illiteracy is not zero We then test our sample data using cor.test to find out the p-value: If p-value &lt; 0.025 (two sided test), means \\(H_1\\) is significant, therefore reject \\(H_0\\). If p-value &gt; 0.025 (two sided test), means \\(H_0\\) is significant, therefore accept \\(H_0\\). cor.test(x, y, method = , alternative= , conf.level= ) \\(\\quad\\) x= vector 1 \\(\\quad\\) y= vector 2 \\(\\quad\\) method= pearson (default), spearman, kendall \\(\\quad\\) alternative= two.sided (default), less, more \\(\\quad\\) conf.level = 0.95(default), any value between 0 to 1 cor.test (states[,&#39;Murder&#39;], states[,&#39;Illiteracy&#39;]) ## ## Pearson&#39;s product-moment correlation ## ## data: states[, &quot;Murder&quot;] and states[, &quot;Illiteracy&quot;] ## t = 6.8479, df = 48, p-value = 1.258e-08 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.5279280 0.8207295 ## sample estimates: ## cor ## 0.7029752 If \\(H_0\\) is true, then chance of observing the sample data (with correlation of 0.7) is 1.258e-08 (too low to be true). Hence we reject \\(H_0\\), and accept \\(H_1\\) that there is indeed a significant correlation between the variables. -->"],
["9-clustering-analysis.html", "Chapter 9 Clustering Analysis", " Chapter 9 Clustering Analysis Cluster analysis is a data-reduction technique designed to uncover subgroups of observations within a dataset It reduce a large number of observations to a much smaller number of clusters or types A cluster is defined as a group of observations that are more similar to each other than they are to the observations in other groups "],
["9-1-packages.html", "9.1 Packages", " 9.1 Packages Below summarizes all packages, their functions and purposes used in this Clustering Analysis chapter. Package Function Purpose 1 Base - R dist Calculate distance between data points with methods: euclidean, maximum, cenberra, minkowski, manhattan scale Scale data (minus mean, div by SD) hclust Build hirerchical cluster model (no cutting) kmeans Build k-means cluster model 2 factoextra fviz_nbclust Optimum number of cluster (K) visual analysis, methods: wss, silhoutte hcut Build hirerchical cluster model (with cutting) fviz_dend Visualize h-cluster model in dendrogram graph as ggplot object fviz_cluster Visualize data points with cluster grouping as ggplot object 3 NbClust NbClust 30 indices to analyze optimal number of cluster, K 4 flexclust randIndex Agreement measure for two cluster results "],
["9-2-application.html", "9.2 Application", " 9.2 Application Business : researchers use cluster analysis for customer segmentation. Customers are arranged into clusters based on the similarity of their demographics and buying behaviours. Marketing campaings are then tailored to appeal to the groups. Psychological: researchers cluster data on the symptoms and demographics of depressed patients, seeking to uncover subtypes of depression, with the hope of finding more effective targeted treatments and a better understanding of the disorder. Medical: researchers use cluster analysis to help catalog gene-expression patterns obtained from DNA microarray data. This can help them to understand normal growth and development and the underlying causes of many human diseases Information Retrieval: The world wide web consists of billions of Web pages, and the results of a query to a search engine can return thousands of pages. Clustering can be used to group these search results into a small number of clusters, each of which captures a particular aspect of the query. For example, a query of “movie” might return Web pages grouped into categories such as reviews, trailers, starts and theaters. Each category (Cluster) can be bnorken into subcategories (sub-clusters), producing a hierachical structure that further assists a user’s exploration of the query results. "],
["9-3-sample-data-4.html", "9.3 Sample Data", " 9.3 Sample Data Sample data used in this chapter emulate two dimensional data points with three groups with clear grouping when visualize. set.seed(1234) my.df = data.frame( id = paste(&#39;ID_&#39;, 1:15, sep = &#39;&#39;), grp = c(rep(&#39;G1&#39;, 5), rep(&#39;G2&#39;, 5), rep(&#39;G3&#39;, 5)), value1 = c( round(rnorm(5, mean = 10, sd = 3)), round(rnorm(5, mean = 10, sd = 3)), round(rnorm(5, mean = 30, sd = 3))), value2 = c( round(rnorm(5, mean = 10, sd = 3)), round(rnorm(5, mean = 20, sd = 3)), round(rnorm(5, mean = 20, sd = 3))), stringsAsFactors = F ) rownames(my.df) = my.df[,1] str(my.df) plot(my.df$value1, my.df$value2) ## &#39;data.frame&#39;: 15 obs. of 4 variables: ## $ id : chr &quot;ID_1&quot; &quot;ID_2&quot; &quot;ID_3&quot; &quot;ID_4&quot; ... ## $ grp : chr &quot;G1&quot; &quot;G1&quot; &quot;G1&quot; &quot;G1&quot; ... ## $ value1: num 6 11 13 3 11 12 8 8 8 7 ... ## $ value2: num 10 8 7 7 17 20 19 19 21 18 ... "],
["9-4-general-steps.html", "9.4 General Steps", " 9.4 General Steps Choose appropriate attributes This is the most important steps. Choose attributes that that actions can be taken upon A sohisticated cluster analysis can’t compensate for a poor choice of variables Scale Data When NOT to scale If you have attributes with a well-defined meaning. Say, latitude and longitude, then you should not scale your data, because this will cause distortion When To Scale If you have mixed numerical data, where each attribute is something entirely different (say, shoe size and weight), has different units attached (lb, tons, m, kg …) then these values aren’t really comparable anyway; z-standardizing them is a best-practise to give equal weight to them If variables vary in range, then the variable with the largest value will have the greatest impact on result. This is undesirable Therefore data must be scaled so that they can be compared fairly Methods of Scaling Popular scaling methods are: Normalize to mean=0 and sd=1 Divide by Max Minus min, divide by Min-Max range Screen for Outliers Outliers can distort results. Screen to remove them Calculate Data Point Distances Popular measure of distance between two data point is Euclidean distance Others are Manhattan, Canberra, Asymmetric Binary, Maximum and Minkowski also available Chosoe a Clustering Alrorithm, and Inter-Custer Distance Method Try few Clustering Solutions Decide the best clustering algorithm, cluster distance method and number of cluster, K Use NbClus as a tool to guide choosing K (number of cluster) Visualize the result Visualization can help you determine the meaning and usefulness of the cluster solution Hierarchical clustering are usually presented as a dendrogram Partitioning results are typically visualized using a bivariate cluster plot Intepret the Cluster Once a cluster solution has been obtained, you must interpret (and possibly name) the clusters What do the observations in a cluster have in common? How do they differ from the observations in other clusters? This step is typically accomplished by obtaining summary statistics for each variable by cluster For continuous data, the mean or median for each variable within each cluster is calculated. For mixed data (data that contain categorical variables), the summary statistics will also include modes or category distributions Validate Result Validating the cluster solution involves asking the question: “Are these groupings in some sense real, and not a manifestation of unique aspects of this dataset or statistical technique?” If a different cluster method or different sample is employed, would the same clusters be obtained? If actual grouping data is known, run randIndex to measure the degree of agreement The fpc, clv, and clValid packages each contain functions for evaluating the stability of a clustering solution (not discussed here) "],
["9-5-distance-algorithm.html", "9.5 Distance Algorithm", " 9.5 Distance Algorithm The choice of an appropriate metric will influence the shape of the clusters, as some elements may be close to one another according to one distance and farther away according to another. For example, in a two dimensional data, the distance between the point (1,1) and the origin (0,0) can be 2 under Manhattan distance, \\(\\sqrt{2}\\) under Euclidean distance, or 1 under Maximum distance. dist is used to measure distance for all numeric elements in dataframe or matrix. Supplying non-numeric columns for dist will incur warning. dist( x, method = ) default method = 'euclidean' \\(\\quad\\) method = 'euclidean', &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot; 9.5.1 Euclidean Distance \\[Euclidean-d(p,q) = \\sqrt{\\sum_{i=1}^n (p_i-q_i)^2} \\quad,n = dimension\\] The Euclidean distance is a distance measure between two points or or vectors in a two- or multidimensional (Euclidean) space based on Pythagoras’ theorem The distance is calculated by taking the square root of the sum of the squared pair-wise distances of every dimension Below command measures distance for numeric columns of all data points in my.df, using euclidean algorithmn. data.scaled = scale(my.df[,3:4]) # Z-Score scaling d.euclidean = dist( data.scaled ) # Euclidean distance round (d.euclidean,1) ## ID_1 ID_2 ID_3 ID_4 ID_5 ID_6 ID_7 ID_8 ID_9 ID_10 ID_11 ID_12 ID_13 ## ID_2 0.6 ## ID_3 0.9 0.3 ## ID_4 0.6 0.8 1.0 ## ID_5 1.4 1.7 1.9 2.1 ## ID_6 2.0 2.3 2.5 2.6 0.6 ## ID_7 1.7 2.1 2.4 2.4 0.5 0.4 ## ID_8 1.7 2.1 2.4 2.4 0.5 0.4 0.0 ## ID_9 2.1 2.5 2.7 2.7 0.8 0.4 0.4 0.4 ## ID_10 1.5 2.0 2.2 2.1 0.4 0.6 0.2 0.2 0.6 ## ID_11 2.5 2.3 2.3 3.0 1.7 1.8 2.1 2.1 2.2 2.1 ## ID_12 3.1 3.1 3.2 3.7 1.8 1.5 1.9 1.9 1.8 2.1 1.2 ## ID_13 2.5 2.4 2.4 3.1 1.6 1.6 1.9 1.9 2.1 2.0 0.2 1.0 ## ID_14 3.0 2.9 3.0 3.6 1.9 1.7 2.1 2.1 2.1 2.2 0.8 0.5 0.6 ## ID_15 2.9 2.7 2.7 3.5 2.1 2.1 2.4 2.4 2.5 2.5 0.4 1.1 0.5 ## ID_14 ## ID_2 ## ID_3 ## ID_4 ## ID_5 ## ID_6 ## ID_7 ## ID_8 ## ID_9 ## ID_10 ## ID_11 ## ID_12 ## ID_13 ## ID_14 ## ID_15 0.6 9.5.2 Manhattan Distance \\[Manhattan - d(p,q) = \\sum_{i=1}^n |p_i-q_i| \\quad,n = dimension\\] The Manhattan distance (sometimes also called Taxicab distance) metric is related to the Euclidean distance But instead of calculating the shortest diagonal path (“beeline”) between two points, it calculates the distance based on gridlines Below command measures distance for numeric columns of all data points in my.df, using manhattan algorithm. data.scaled = scale(my.df[,3:4]) # Z-Score scaling d.manhattan = dist( data.scaled, method=&#39;manhattan&#39;) round (d.manhattan, 1) ## ID_1 ID_2 ID_3 ID_4 ID_5 ID_6 ID_7 ID_8 ID_9 ID_10 ID_11 ID_12 ID_13 ## ID_2 0.9 ## ID_3 1.2 0.4 ## ID_4 0.9 1.0 1.0 ## ID_5 1.8 1.7 2.1 2.7 ## ID_6 2.5 2.4 2.6 3.4 0.7 ## ID_7 1.9 2.4 2.8 2.8 0.7 0.6 ## ID_8 1.9 2.4 2.8 2.8 0.7 0.6 0.0 ## ID_9 2.3 2.8 3.2 3.2 1.1 0.6 0.4 0.4 ## ID_10 1.6 2.3 2.7 2.5 0.6 0.9 0.3 0.3 0.7 ## ID_11 3.3 3.3 3.3 4.2 1.9 2.4 2.6 2.6 3.0 2.5 ## ID_12 4.3 4.2 4.2 5.2 2.5 1.8 2.4 2.4 2.0 2.7 1.3 ## ID_13 3.4 3.4 3.4 4.3 1.6 2.1 2.3 2.3 2.7 2.2 0.3 1.1 ## ID_14 4.2 4.1 4.1 5.1 2.4 1.7 2.3 2.3 2.3 2.6 0.9 0.7 0.8 ## ID_15 3.9 3.8 3.8 4.8 2.1 2.6 2.8 2.8 3.2 2.7 0.6 1.5 0.5 ## ID_14 ## ID_2 ## ID_3 ## ID_4 ## ID_5 ## ID_6 ## ID_7 ## ID_8 ## ID_9 ## ID_10 ## ID_11 ## ID_12 ## ID_13 ## ID_14 ## ID_15 0.9 9.5.3 Maximum Distance \\[d(x,y)= sup|x_j - y_j|, 1≤ j ≤ d\\] 9.5.4 Canberra Distance \\[\\sum_{j=1}^{d}|x_j - y_j|) / (|x_j|+|y_j|)\\] 9.5.5 Minkowski Distance The Minkowski distance is a generalized form of the Euclidean distance (if m=2) and the Manhattan distance (if m=1). \\[\\left(\\sum_{i=1}^n |p_i-q_i|^p\\right)^{1/m}\\] "],
["9-6-optimum-number-of-clusters-k.html", "9.6 Optimum Number of Clusters (K)", " 9.6 Optimum Number of Clusters (K) There are three (3) popular methods for determining the optimal number of clusters. Elbow Method Applicable for partioning clustering, such as k-means Average Silhoutte Method Gap Statistics (not discussed here) There is no guarantee that they will agree with each other. In fact, they probably won’t. However, use this as a guidine and test few highest criteria score to determinee final number of cluster. 9.6.1 Elbow Method 9.6.1.1 Elbow Concept The objective of partitioning clustering (such as K-Mean) is to define clusters such that the total intra-cluster variation (known as total within-cluster variation or total within-cluster sum of square, wss) is minimized. 9.6.1.2 Elbow Algorithm Run K-mean clustering algorithm for K=1 to n For each K, calculate the within-cluster-sum-of-square (wss) Plot the curve of wss against the number of clusters K The location of bend (knee) in the plot is generally considered as the indicator of the appropriate number of clusters When the WSS value stop decreasing significantly (at the knee), then the number of clusters probably had reached its optimum. Although this approach is heuristic, it still provide a good guideline for K selection. 9.6.1.3 Elbow Codes (for K-mean) - Do It Yourself! The method presented here does not require any external library ! However, it requires writing a funciton to calculate WSS and plot the results. Define the The Algorithmn # Algorithmn: Compute k-means and plot wss for k=2 to k=15 wssplot = function(data, nc=15, seed=1234){ wss &lt;- (nrow(data)-1)*sum(apply(data,2,var)) for (i in 2:nc) { set.seed(seed) wss[i] &lt;- sum(kmeans(data, centers=i)$withinss) } plot(1:nc, wss, type=&quot;b&quot;, xlab=&quot;Number of Clusters (K)&quot;, ylab=&quot;Total Within Groups Sum of Squares&quot;) wss } Run The Code If number of observations &lt;=nc(default 15), specify smaller nc. wssplot(data.scaled, nc=8) abline(v=3, lty=2) # mark the optimum K after facts ## [1] 28.000000 12.865178 2.467904 2.191659 2.038777 0.785887 1.396947 ## [8] 1.030988 The wssplot above indicates that there is a distinct drop in the within-groups sum of squares when moving from 1 to 3 clusters. After three clusters, this decrease drops off, suggestign that a three-cluster solution may be a good fit to the data. 9.6.1.4 Elbow Codes - using factoextra::fviz_nbclust,hcut factoextra combined functions to calculate ‘silhoutte’ and output ggplot object For k-mean wss analysis, kmeans helper function from base-R is required For pam wss analysis, cluster:pam helper function is required For h-cluster wss analysis, hcut helper function by its own library is used. Somehow base-R hclust is not supproted library(factoextra) library(cluster) fviz_nbclust(data.scaled, kmeans, method = &quot;wss&quot;) + labs(subtitle=&#39;kmeans&#39;) fviz_nbclust(data.scaled, pam, method = &quot;wss&quot;) + labs(subtitle=&#39;pam&#39;) fviz_nbclust(data.scaled, hcut, method = &quot;wss&quot;) + labs(subtitle=&#39;hcut&#39;) + geom_vline(xintercept = 3, linetype = 2) 9.6.2 Average Silhoutte Method 9.6.2.1 Average Silhoutte Concept Average silhouette method computes the average silhouette of observations for different values of k. The optimal number of clusters k is the one that maximize the average silhouette over a range of possible values for k (Kaufman and Rousseeuw [1990]). Silhouette analysis can be used to study the separation distance between the resulting clusters. The silhouette plot displays a measure of how close each point in one cluster is to points in the neighboring clusters and thus provides a way to assess parameters like number of clusters visually. This measure has a range of [-1, 1]. Silhouette coefficients (as these values are referred to as) near +1 indicate that the sample is far away from the neighboring clusters. A value of 0 indicates that the sample is on or very close to the decision boundary between two neighboring clusters and negative values indicate that those samples might have been assigned to the wrong cluster. 9.6.2.2 Average Silhoutte Algorithm Compute clustering algorithm (e.g., k-means clustering) for different values of k For each k, calculate the average silhouette of observations (avg.sil) Plot the curve of avg.sil according to the number of clusters k The location of the maximum is considered as the appropriate number of clusters 9.6.2.3 Average Silhoutte Code - factoextra:fviz_nbclust Example code below shows silhoute analysis for kmeans, pam and h-cluster: factoextra combined functions to calculate ‘silhoutte’ and output ggplot object For k-mean silhoutte analysis, kmeans helper function from base-R is required For pam silhoutte analysis, cluster:pam helper function is required For h-cluster silhoutte analysis, hcut helper function by its own library is used. Somehow base-R hclust is not supproted library(factoextra) library(cluster) fviz_nbclust(data.scaled, kmeans, method = &quot;silhouette&quot;) + labs(subtitle=&#39;kmeans&#39;) fviz_nbclust(data.scaled, pam, method = &quot;silhouette&quot;) + labs(subtitle=&#39;pam&#39;) fviz_nbclust(data.scaled, hcut, method = &quot;silhouette&quot;) + labs(subtitle=&#39;hcut&#39;) 9.6.3 NbClust Package (with 30 Indices) NbClust package offers numerous 26 indices for determining the best number of clusters in a cluster analysis. library(&#39;NbClust&#39;) Multiple indices are computed simultaneously - a clear advantage Paramter index='all' will utilize all indices to evaluate the optimum number of clusters Nbclust returns a list that contains all evaluation statistic based on the indices used Results of the evaluation is stored in Best.nc vector Using table and barplot is best way to visualize the result of best K Supported Indices are kl, ch, hartigan, ccc, scott, marriot, trcovw, tracew, friedman, rubin, cindex, db, silhouette, duda, pseudot2, beale, ratkowsky, ball, ptbiserial, gap, frey, mcclain, gamma, gplus, tau, dunn, hubert, sdindex, dindex, sdbw ‘all’ (all indices except GAP, Gamma, Gplus and Tau) ‘alllong’ (all indices with Gap, Gamma, Gplus and Tau included) NbClust( data=, diss=NULL, distance='euclidean', min.nc=2, max.nc=15, method=NULL, index='all', alphaBeale=0.1) \\(\\quad\\) data = matrix or dataframe \\(\\quad\\) diss = dissimilarity matrix, if not NULL, then distance should be NULL \\(\\quad\\) distance = &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot; or &quot;NULL&quot; \\(\\quad\\) min.nc = minimum number of clusters \\(\\quad\\) max.nc = maximum number of clusters \\(\\quad\\) method = &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, &quot;centroid&quot;, &quot;kmeans&quot; \\(\\quad\\) index = 'all' to use all indices for evaluation NbClust output an object with below values: Best.nc : Best number of clusters proposed by each index and the corresponding index value Best.partition: vector of cluster group for every observation 9.6.3.1 Run The Code Run NbClust for average (h-clustering) and kmeans method. nbc.hclust = NbClust(data.scaled, distance=&quot;euclidean&quot;, min.nc=2, max.nc=8, method=&quot;average&quot;) nbc.kmeans = NbClust(data.scaled, min.nc=2, max.nc=8, method=&quot;kmeans&quot;) 9.6.3.2 Visualize The Result Visualize using Base-R As output Best.nc[1,] shows, majority indices favor three (3) clusters. table( nbc.hclust$Best.n[1,] ) barplot( table(nbc.hclust$Best.n[1,] ), xlab=&quot;Numer of Clusters&quot;, ylab=&quot;Number of Criteria&quot;, main=&quot;Number of Clusters Chosen by 26 Criteria\\nh-cluster&quot;) table( nbc.kmeans$Best.nc[1,] ) barplot( table(nbc.kmeans$Best.nc[1,] ), xlab=&quot;Numer of Clusters&quot;, ylab=&quot;Number of Criteria&quot;, main=&quot;Number of Clusters Chosen by 26 Criteria\\nkmeans&quot;) ## ## 0 1 2 3 5 6 7 8 ## 2 1 2 14 2 1 2 2 ## ## 0 1 2 3 5 7 8 ## 2 1 2 15 1 1 4 Visualize using factoextra::fviz_nbclust() Single function fviz_nbclust() from factoextra library will use value in NbClust object to visualize the optimal cluster number. fviz_nbclus output ggplot object, hence can be easily customized. library(&#39;factoextra&#39;) fviz_nbclust(nbc.hclust) + labs(subtitle=&#39;H-Cluster&#39;) fviz_nbclust(nbc.kmeans) + labs(subtitle=&#39;K-Means&#39;) "],
["9-7-clustering-algorithm-compared.html", "9.7 Clustering Algorithm Compared", " 9.7 Clustering Algorithm Compared Description h-cluster k-means 1 Computation Time Fast. Linear to number of observation Slow: Quadradric to number of observation 2 Initial K needed No Yes 3 Fine Tuning Experiment with different method of Linkage Experiment with different K centroids 4 Perform Well in Hierachical Nature Data Set Spherical Data Points 5 Perform Bad in Large data sets U-Shape, Outliers 6 Unique Advantages Good for hirechical discovery 7 R Library Base R, factoextra Base R "],
["9-8-hierarchical-clustering.html", "9.8 Hierarchical Clustering", " 9.8 Hierarchical Clustering Hierarchical clustering is a widely used data analysis tool The idea is to build a binary tree of the data that successively merges similar groups of points Number of clusters (K) is required as import It is an unsupervised learning 9.8.1 Clustering Algorithm This is how Hierarchical Clustering works: 1. Initially, put each data point in its own cluster 2. Calucate the distances between each cluster and all other clusters (inter-cluster distance) 3. Combine the two clusters with the smallest distance - This reduce cluster number by one 4. Repeat step (2) and (3) until all clusters have been merged into single cluster 9.8.2 Inter Cluster Distance Method Once distance for all data points has been measured, decide which of the five (5) methods below to measure distance between clusters: Single Linkage: Shortest distance among all data points betweentwo clusters Complete Linkage (common): Longest distance among all data points between two clusters Average Linkage (common): Average distance of all points between two clusters Centroid: Find the centroid of each cluster and calculate the distance between centroids between two clusters Please note that the Inter Cluster Distance Method above uses Distance Algorithmn such as ‘euclidean’, “maximum”, “manhattan”, “canberra”, “binary” or “minkowski” to calculate actual distance value. 9.8.3 Run The Code Generally, step (A), (B) and (C) are followed for H-clustering analysis. A. Before running H-Clustering Fiter Data (choose only numeric columns) Scale Data (if required) Calculate distance, using B. Performing H-Clustering Build H-Cluster model, require input of inter-cluster distance method Derive cluster by **cutting* into K number of clusters C. Visualize Display frequency, number of observations for each cluster group Plot dendrogram, superimpose cluster group into the plot 9.8.3.1 Using Base-R Utilities hclust (d, method ='complete') \\(\\quad\\) d = distance calculated using dist() \\(\\quad\\) method = 'single', 'complete', 'average', 'centroid' as cluster distance method Filter, Scale, Calculate Distance data.scaled = scale(my.df[,3:4]) # scale data d.euclidean = dist( data.scaled ) # calculate distance Build H-Cluster Model, Cutting into clusters fit.average = hclust (d.euclidean, method=&#39;average&#39;) # build the model clusters = cutree (fit.average, k=3) # derive the clusters clusters ## ID_1 ID_2 ID_3 ID_4 ID_5 ID_6 ID_7 ID_8 ID_9 ID_10 ID_11 ID_12 ## 1 1 1 1 2 2 2 2 2 2 3 3 ## ID_13 ID_14 ID_15 ## 3 3 3 Display frequency table, Visualize with dendogram, superimpose cluster group barplot( table(clusters), xlab=&#39;Cluster Group Number&#39;, ylab=&#39;No. of Observations&#39; ) plot( fit.average, main=&#39;HCluster, Average-Linkage\\n3 Clusters Solution&#39; ) rect.hclust( fit.average, k=3, border = 2:5 ) 9.8.3.2 Using factoextra Package factoextra provides single function hcut to scale, calcuate distance and cutting into cluster groups. Which is handy. library(&quot;factoextra&quot;) hcut(x, k = 2, hc_method = &quot;ward.D2&quot;, hc_metric = &quot;euclidean&quot;, stand = FALSE, graph = FALSE) \\(\\quad\\) x = matrix or dataframe \\(\\quad\\) k = number of clusters to cut \\(\\quad\\) hc_method = inter-cluster distance method: ward.D, ward.D2, single, complete, average \\(\\quad\\) hc_metric = distance calc method: euclidean, manhattan, maximum, canberra, binary, &quot;minkowski \\(\\quad\\) stand = TRUE: scale x with z-score, FALSE: not to scale x hcut output below useful values (not all displayed): \\(\\quad\\) data = original data (if stand=FALSE), scaled data (if stand=TRUE) \\(\\quad\\) nbclust = number of clusters \\(\\quad\\) cluster = cluster group number assigned for each observation \\(\\quad\\) size = frequency vector, number of observations for each cluster \\(\\quad\\) method = inter-cluster distance method applied \\(\\quad\\) dist.method = distance method applied Filter, Scale, Calculate Distance, Build H-Cluster Model, Cutting into Clusters fit.hc = hcut(my.df[,3:4], k=3, hc_method=&#39;average&#39;, hc_metric=&#39;euclidean&#39;, stand = TRUE) Display frequency table, Visualize with dendogram, superimpose cluster group barplot( table(fit.hc$cluster), xlab=&#39;Cluster Group Number&#39;, ylab=&#39;No. of Observations&#39; ) fviz_dend(fit.hc, rect = TRUE, rect_border = &#39;red&#39;, cex = 0.5, lower_rect = -0.5, horiz = T) "],
["9-9-k-mean-clustering.html", "9.9 K-Mean Clustering", " 9.9 K-Mean Clustering K-mean is the most common partitioning clustering algorithm Partitioning means data points need to be initally partioned into few clusters to start the process with The other partitioning clustering method is Medoids 9.9.1 Clustering Algorithm Define K number of centroids (data points) Cluster Assignment Each observation is assigned to the nearest centroid, using euclidean distance Update Centroids After all observations had been assigned to the centroids, a new centroids is calculated Repeat step (2) - (3) until convergence Convergence means none of the observations changed cluster membership 9.9.2 Run The Code Generally, step (A), (B) and (C) are followed for H-clustering analysis. A. Before running H-Clustering Fiter Data (choose only numeric columns) Scale Data (if required) B. Performing H-Clustering Build K-Means Cluster model, require input Number of initial centers (clusters K) K-Means Algorithmn Number of tries to seed random centers, before choosing the best model C. Visualize Display frequency, number of observations for each cluster group Plot graph, superimpose cluster group into the plot 9.9.2.1 kmeans( x, centers, nstart=1, algorithmn='Hartiga-Wong' ) \\(\\quad\\) x = matrix or dataframe \\(\\quad\\) centers = number of centroids \\(\\quad\\) nstart = how many times to randomly try seeding centroids \\(\\quad\\) algorithm = &quot;Hartigan-Wong&quot;-default, &quot;Lloyd&quot;, &quot;Forgy&quot;, &quot;MacQueen&quot; nstart=25 is a good number to use. kmeans output below useful values: cluster : cluster number for all observations centers : Centre values (of each dimensions) for each cluster withinss : Total Sum of Squares Within For Each Cluster size : Number of observations for each cluster number fit.kmeans = kmeans(data.scaled, 3, nstart = 25) fit.kmeans$cluster ## ID_1 ID_2 ID_3 ID_4 ID_5 ID_6 ID_7 ID_8 ID_9 ID_10 ID_11 ID_12 ## 3 3 3 3 1 1 1 1 1 1 2 2 ## ID_13 ID_14 ID_15 ## 2 2 2 fit.kmeans$withinss ## [1] 0.5512567 1.1226046 0.7940430 fit.kmeans$size ## [1] 6 5 4 9.9.3 Visualizing K-Mean Cluster library(factoextra) fviz_cluster( fit.kmeans, data = data.scaled, geom = &quot;point&quot;, stand = FALSE, ellipse.type = &quot;norm&quot;) "],
["9-10-agreement-with-actual-group-data.html", "9.10 Agreement With Actual Group Data", " 9.10 Agreement With Actual Group Data The adjusted Rand index provides a measure of the agreement between two sets of grouping data, adjusted for chance. It ranges from -1 (no agreement) to 1 (perfect agreement). library(&#39;flexclust&#39;) 9.10.1 Compare Cluster with Actual Data If we know the actual grouping data, we can then run this index analysis against the cluster grouping. Construct a table of cluster groups and actual groups. Then run randIndex on it to reveal the agreement measure. # cluster data generated using cutree() table(my.df$grp, clusters) randIndex( table(my.df$grp, clusters) ) ## clusters ## 1 2 3 ## G1 4 1 0 ## G2 0 5 0 ## G3 0 0 5 ## ARI ## 0.7920792 9.10.2 Compare Two Clusters We can also compare cluster data from two different clusters, eg. clusters using different algorithm. # cluster data generated using kmeans and factoextra::hcut() table(fit.kmeans$cluster, fit.hc$cluster) randIndex( table(fit.kmeans$cluster, fit.hc$cluster) ) ## ## 1 2 3 ## 1 0 6 0 ## 2 0 0 5 ## 3 4 0 0 ## ARI ## 1 It this case, both models give similar clustering result. -->"],
["10-classification.html", "Chapter 10 Classification ", " Chapter 10 Classification "],
["10-1-introduction.html", "10.1 Introduction", " 10.1 Introduction "],
["10-2-application-1.html", "10.2 Application", " 10.2 Application "],
["10-3-choosing-the-right-algorithm.html", "10.3 Choosing The Right Algorithm", " 10.3 Choosing The Right Algorithm "],
["10-4-logistic-regression.html", "10.4 Logistic Regression", " 10.4 Logistic Regression "],
["10-5-decision-tree-regression.html", "10.5 Decision Tree Regression", " 10.5 Decision Tree Regression -->"],
["11-regression-analysis.html", "Chapter 11 Regression Analysis ", " Chapter 11 Regression Analysis "],
["11-1-introduction-1.html", "11.1 Introduction", " 11.1 Introduction Regression is statistical process for estimating the relationships among variables: It includes many techniques for modeling and analyzing the relationship between a dependent variable and one or more independent variables More specifically, regression analysis helps one understand how the typical value of the dependent variable changes when any one of the independent variables is varied, while the other independent variables are held fixed Regression analysis estimates the conditional expectation of the dependent variable given the independent variables – that is, the average value of the dependent variable when the independent variables are fixed Regression analysis is a form of predictive modelling technique which investigates the relationship between a dependent (target) and independent variable 11.1.1 General Equation and Terminilogy A regression model relates Y to a function of \\(X\\) and \\(\\beta\\): \\(\\quad{Y\\approx f(\\mathbf {X} ,{\\boldsymbol {\\beta }})}\\) \\(\\quad \\quad E(Y)\\) = Predicted Value, Expected outcome or response, Expectation \\(\\quad \\quad Y\\) = Dependent variable, criterion, outocme, response \\(\\quad \\quad X\\) = Independent variable, features, predictors The goal of regression analaysis is to derive a model that estimate the paramter (\\(\\beta\\)) which has the least cost. 11.1.2 R Formula Object 11.1.2.1 Notation Symbols Symbol Usage Example ~ Seperate response variables on the left, predictor variables on the right y ~ x + Seperate predictor variables y ~ x + z : Denotes interaction between predictors y ~ x : z * Shortcut denoting all possible interactions. x * z equivalent to x + z + x:z y ~ x * z ^ ^3 measn include these variables and all interactions up to three way y ~ (x + z + w)^2 -1 Suppress the intercept (make intercept to be zero) y ~ x - 1 fits the regression of y on x, forcing the line y = 0 at x = 0 y ~ x -1 . A shortcut placeholder to include all other variables except the dependent variable y ~ . will expand to y ~ x + z + w y ~ . - Exclude specific variable y ~.-z , y~.-w:z I () Elements in parentheses are interpreted arithmetically function Math function can be used in formula, log(y) ~ x + z + w would predict log(y) from x, z and w log(y) ~ x + z + w 11.1.2.2 Example Equation and Notations Example Equation R Formula Notation 1 \\(y=\\beta_0 + \\beta_1 x + \\beta_2 w + \\beta_3 z + e\\) y ~ x + w + z 2 \\(y=\\beta_0 + \\beta_1 x + \\beta_2 wz + e\\) y ~ x + w:z 3 \\(y=\\beta_0 + \\beta_1 x + \\beta_2 wz + \\beta_3 w + \\beta_4 z + e\\) y ~ x + w*z y ~ x + w:z + w + z 4 \\(y = 0 + \\beta_1 x + \\beta_2 w\\) y ~ -1 + x + w 5 \\(y=\\beta_0 + \\beta_1 x + \\beta_2 w + e\\) y ~ .- z 6 \\(y=\\beta_0 + \\beta_1 x + \\beta_2 x^2 + \\beta_3 x^3 + e\\) y ~ x + I(x^2) + I(x^3) In R, there are more than one way to write a notation, consider below two examples: \\(y=\\beta_0 + \\beta_1 x + \\beta_2 w + \\beta_3 z + \\beta_4 xw + \\beta_5 xz + \\beta_6 wz + \\beta_7 xwz + e\\) can be represented by three formulas as below: y ~ (x + w + z)^3 y ~ x * w * z y ~ x + w + z + x:w + x:z + w:z + x:w:z \\(y=\\beta_0 + \\beta_1 x + \\beta_2 w + \\beta_3 z + \\beta_4 xw + \\beta_5 xz + \\beta_6 wz + e\\) can be represented by three formula as below: y ~ (x + w + z)^2 y ~ x * w * z - x:w:z y ~ x + w + z + x:w + x:z + w:z "],
["11-2-application-2.html", "11.2 Application", " 11.2 Application "],
["11-3-types-of-regression.html", "11.3 Types of Regression", " 11.3 Types of Regression 11.3.1 Linear and Non Lienar Linear Regression Simple an d Multiple Regression General Linear Model Heteroscedastic Model Hierarchical Linear Model Erros-in-variables Others Non Linear Regression Logistic Regression Polynomial Regression Stepwise Regression Ridge Regression Lasso Regression ElasticNet Regression Others 11.3.2 Choosing the Regression Algorithm Number of independent variables Shape of the regression line Type of dependent variable Binary outocme : Logistic Regression "],
["11-4-linear-regression.html", "11.4 Linear Regression", " 11.4 Linear Regression This section discussed Ordinary Least Square Linear Regression, this includes single and multiple variable OLS Linear Regression. There are other types of linear regression, which are not covered. General Linear Regression Generalized Linear Regression Hierachical Linear Regression Erros-in-variable Linear Regression Others 11.4.1 The Concept Linear Regression establishes a relationship between dependent variable (Y) and one or more independent variables (X) using a best fit straight line (also known as regression line). The objective of linear regression modeling is to find the most optimum equation that best explain the data Optimum equation is defined as the one that has the least cost (error) Once we had derived the optimum equation, we can use the model to predict target \\(Y&#39;\\) base on new variables \\(X\\). 11.4.2 Assumptions Below are conditions for the least-squares estimator - used by linear regression to possess desirable properties; in particular, these assumptions imply that the parameter estimates will be unbiased, consistent, and efficient in the class of linear unbiased estimators. Classical assumptions for linear regression analysis include: The sample is representative of the population for the inference prediction Question how is the data being gathered, is it convincing that it represents the population ? Number of observations must be larger than number of independent variables Check the length of observations &gt;= column length of data Assumptions On Independent Variable The independent variables are measured with no error, that is observations must be a set of known constants. (Note: If this is not so, modeling may be done instead using errors-in-variables model techniques) Think about if the ‘predictor’ has erors, what makes the outcome ? Each independent variable are linearly correclated with outcome, when other independent variables are held constant. Validation methods: Run Matrix Scatter plot outcome against individual independent variables. Methods to verify are: Run matrix correlation calculation for outcome againsts all independent varaibels. Correlation value 0.5 and above consider good correlation and therefore acceptable NO Multicollinearity amont predictors - Meaning little or not linear correlationamong the predictors, i.e. it is not possible to express any predictor as a linear combination of the others, if so, we wouldn’t know which predictor actually influene the outcome. Validation method: Scatter Plot Matrix for all independent variables Correlation Matrix calculation for all independent varaibels. Correlation value 0.2 and below consider week correlation and therefore acceptable Tolerance (T) - measures the influence of one independent variable on all other independent variables T &lt;0.01 –&gt; confirm correlation T &lt;0.1 –&gt; might have correlation Variance Inflation Factor (VIF) - VIF = 1/T T &gt;100 –&gt; confirm correlation T &gt;10 –&gt; might have correlation Condition Index (CI) - calculated using a factor analysis on the independent variables ** Values of 10-30** –&gt; indicate a mediocre multicollinearity ** Values &gt; 30** –&gt; strong multicollinearity Assumptions On Errors (residuals) The errors are random numbers, with means of zero There should not be a pattern in the residuals distribution If the residuals are normally distributed with mean of zero, then it is considered a bonus which we can perform statistical significant testing. \\(e = N(0,\\sigma^2)\\) Normality on redisuals implies that the dependent variable are also normally distributed (if and only if dependent variable is not stochastic) The errors are uncorrelated - that is, the variance–covariance matrix of the errors is diagonal and each non-zero element is the variance of the error Homoscedasticity - The variance of the error is constant across observations. If heteroscedasticity exist, scatter plot of response and predictor will look like below If not, weighted least squares or other methods might instead be used. - The Goldfeld-Quandt Test can test for heteroscedasticity - If homoscedasticity is present, a non-linear correction might fix the problem 11.4.2.1 Are The Assumptions to be followed strictly ? In real life, actual data rarely satisfies the assumptions, that is: Method is used even though the assumptions are not true Variation from the assumptions can sometimes be used as a measure of how far the model is from being useful Many of these assumptions may be relaxed in more advanced treatments Reports of statistical analyses usually include analyses of tests on the sample data and methodology for the fit and usefulness of the model. 11.4.2.2 Additional notes of independent variables Adding more variables to a regression procedure may overfit the model and make things worse. The idea is to pick the best variables Some independent variable(s) are better at predicting the outocme, some contribute little or nothing Because of multicollinearity and overfitting, there is a fair amount of prep-work to be performed BEFORE conducting multiple regression analysis - if one is to do it properly. 11.4.3 Equations 11.4.3.1 Terminology Simple Linear Regression (classical) consists of just on predictor. aka Single Variable Linear Regression. Multiple Linear Regression (classical) consists of multiple predictors. aka. Multiple Variable Linear Regression. Multivariate Regression (aka. General Linear Regression) is linear regression where the outocme is a vector (not scalar). Not the same as multiple variable linear regression. 11.4.3.2 Ordinary Least Square Estimatation Regression Model - Actual Outcome \\(\\quad y_i = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + ... \\beta_k x_k + e_i\\) \\(\\quad\\)where: \\(\\quad \\quad y_i\\) = actual outcome value \\(\\quad \\quad \\beta_0\\) = intercept, when all independent variables are 0 \\(\\quad \\quad \\beta_k\\) = parameter for independent variable k \\(\\quad \\quad e_i\\) = error for observation i Regression Equation - Predicted Outcome \\(\\quad E(y_i) = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + ... \\beta_k x_k\\) \\(\\quad h_\\theta(X)~=~\\theta_0~+~\\theta_1 \\cdot X\\) , error terms assumed to be zero \\(\\quad\\)where: \\(\\quad \\quad h_\\theta(x)\\) = hypothesis target (dependant variable) \\(\\quad \\quad \\theta_0\\) = intercept \\(\\quad \\quad \\theta_1\\) = slopes or coefficients \\(\\quad \\quad X\\) = independant variables (predictors) \\(\\quad\\)Take note that each \\(\\theta_0\\) and \\(\\theta_1\\) represents multi-variate data in matrix form. 11.4.3.3 Cost Function The goal is to find some values of θ (known as coefficients), so we can minimize the difference between real values \\(y\\) and predicted values (\\(h(x)\\)) Mathematically, this means finding the minimum value of cost function \\(J\\) and derive the optimum value of \\(\\theta_0\\) and \\(\\theta_1\\) Linear regression uses Total Sum Of Square calculation on Error as Cost Function, denoted by \\(J\\) below: \\(\\quad \\quad J(\\theta_0,\\theta_1) = \\frac{1}{2m}\\sum_{i=1}^m ((h_\\theta(x^i)-y^i)^2\\) 11.4.4 Sample Data set.seed(1234) my.df = data.frame( id = paste(&#39;ID&#39;, 1:n), x1 = 10:(10 + n - 1) * runif(n, min = 0.5, max = 1.1), x2 = 20:(20 + n - 1) * runif(n, min = 0.5, max = 1.1), x3 = 30:(30 + n - 1) * runif(n, min = 0.5, max = 1.1) ) my.df$y = 88 + 0.1 * my.df$x1 + 0.2 * my.df$x2 + 0.3*my.df$x3 cor(my.df[, 2:5]) lm(formula = y ~ x1 + x2 + x3, data = my.df) ## x1 x2 x3 y ## x1 1.0000000 0.7798930 0.7848857 0.8732915 ## x2 0.7798930 1.0000000 0.7879751 0.9235238 ## x3 0.7848857 0.7879751 1.0000000 0.9574600 ## y 0.8732915 0.9235238 0.9574600 1.0000000 ## ## Call: ## lm(formula = y ~ x1 + x2 + x3, data = my.df) ## ## Coefficients: ## (Intercept) x1 x2 x3 ## 88.0 0.1 0.2 0.3 \\(h(x_1,x_2,x_3) = \\theta_0+ \\theta_1x_1 + \\theta_2x_2 + \\theta_3X_3\\) 11.4.5 Run The Code fit = lm ( data = , formula = ) fit = lm ( data , formula ) fit = lm ( formula , data ) formula : y~x1 + x2 + x3 data: matrix or dataframe cor(my.df[, 2:5]) lm(formula = y ~ x1 + x2 + x3, data = my.df) ## x1 x2 x3 y ## x1 1.0000000 0.7798930 0.7848857 0.8732915 ## x2 0.7798930 1.0000000 0.7879751 0.9235238 ## x3 0.7848857 0.7879751 1.0000000 0.9574600 ## y 0.8732915 0.9235238 0.9574600 1.0000000 ## ## Call: ## lm(formula = y ~ x1 + x2 + x3, data = my.df) ## ## Coefficients: ## (Intercept) x1 x2 x3 ## 88.0 0.1 0.2 0.3 "],
["11-5-regression-diagnostic.html", "11.5 Regression Diagnostic", " 11.5 Regression Diagnostic library(&#39;car&#39;) 11.5.1 Outlier Test 11.5.2 Linearity Test 11.5.3 Homoscedasticity Test 11.5.4 Multicollinearity Test 11.5.5 Normality Test -->"]
]
