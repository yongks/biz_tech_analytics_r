[
["5-data-preprocessing.html", "Chapter 5 Data Preprocessing ", " Chapter 5 Data Preprocessing "],
["5-1-artificial-grouping.html", "5.1 Artificial Grouping", " 5.1 Artificial Grouping Artificial group can be created based on existing numeric data. Such as age_group based on age. 5.1.1 Grouping with Numeric Breakpoints Simulate data with x,y,z variables. p simulates priority scoring. x = rnorm(10, mean = 10) y = rnorm(10, mean = 10) p = x * y Articial groups is created first by identifying the number of groups, generate the break points vector, then cut the data base on break points and return factor as output. Automatically calculate breakpoints by distributing numbers into the min-max range, in low to high order: num_groups = 4 breakPoints = seq(min(p), max(p), length.out = num_groups + 1) breakPoints ## [1] 85.59917 92.47633 99.35348 106.23063 113.10779 cut ( x, breaks, right = TRUE, include.lowest = FALSE) \\(\\quad\\) x: numeric vector to be cutted \\(\\quad\\) breaks: numeric vector ranging from low to high (in order) \\(\\quad\\) include.lowest: FALSE - ommit element matching lowest number in breaks \\(\\quad\\) right: TRUE - close end on right;open end on left The result from cut is factor based on order from breakPoints. Therefore, once convert into numeric, the group number is in order of low to high accoriding to breakPoints. Verify that group (g) has been assigned for each priority (p). g = as.numeric( cut( p, breakPoints, include.lowest=TRUE)) data.frame(p,g) ## p g ## 1 103.90189 3 ## 2 89.43620 1 ## 3 85.91982 1 ## 4 86.45631 1 ## 5 113.10779 4 ## 6 96.50497 2 ## 7 85.59917 1 ## 8 88.17396 1 ## 9 105.27011 3 ## 10 101.99212 3 5.1.2 Grouping based on Custom Criteria ??? "],
["5-2-handling-missing-data.html", "5.2 Handling Missing Data", " 5.2 Handling Missing Data 5.2.1 Detecting Missing Data 5.2.2 Removing Missing Data "],
["5-3-scaling-data.html", "5.3 Scaling Data", " 5.3 Scaling Data 5.3.1 Sample Data Scaling section will use sample data generated as below: set.seed(1234) my.df = data.frame( id = paste(&#39;ID_&#39;, 1:5, sep = &#39;&#39;), value1 = sample(50:100, 5), value2 = sample(10:50, 5), stringsAsFactors = F ) my.df ## id value1 value2 ## 1 ID_1 55 36 ## 2 ID_2 81 10 ## 3 ID_3 79 19 ## 4 ID_4 98 35 ## 5 ID_5 90 29 5.3.2 Z-Score Scaling scale apply transformation column-wise, for columns within matrix or dataframe scale return a matrix scale (x, center=T, scale=T) # default S-Score transformation \\(\\quad\\) center = T (default) means value minus with mean \\(\\quad\\) scale = T (default) means value divide by sd \\(\\quad\\) \\(\\quad\\) output scaled:center --&gt; mean \\(\\quad\\) \\(\\quad\\) output scaled:scale --&gt; sd scale( my.df[,2:3] ) ## value1 value2 ## [1,] -1.58066858 0.9170971 ## [2,] 0.02469795 -1.4206014 ## [3,] -0.09879179 -0.6113981 ## [4,] 1.07436067 0.8271856 ## [5,] 0.58040174 0.2877167 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 80.6 25.8 ## attr(,&quot;scaled:scale&quot;) ## value1 value2 ## 16.19568 11.12205 scale( my.df[,2:3], scale=F ) ## value1 value2 ## [1,] -25.6 10.2 ## [2,] 0.4 -15.8 ## [3,] -1.6 -6.8 ## [4,] 17.4 9.2 ## [5,] 9.4 3.2 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 80.6 25.8 5.3.3 Min Max Scaling Min-Max scaling will transform all numbers between 0 and 1. Easiest way to perform this transformation is to write a function then apply. min_max = function(x){(x-min(x))/(max(x)-min(x))} apply( my.df[,2:3], MARGIN = 2, FUN = min_max ) ## 2 means column-wise ## value1 value2 ## [1,] 0.0000000 1.0000000 ## [2,] 0.6046512 0.0000000 ## [3,] 0.5581395 0.3461538 ## [4,] 1.0000000 0.9615385 ## [5,] 0.8139535 0.7307692 -->"]
]
