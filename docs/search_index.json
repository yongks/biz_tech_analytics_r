[
["5-data-preprocessing.html", "Chapter 5 Data Preprocessing ", " Chapter 5 Data Preprocessing "],
["5-1-library.html", "5.1 Library", " 5.1 Library library(&#39;lubridate&#39;) library(&#39;caTools&#39;) Below summarizes all packages, their functions and purposes used in this Data Preprocessing chapter. Package Function Purpose 1 Base R (factor) as.factor Convert a vector to a new factor droplevels Return a new factor with unused levels removed relevel Return a new factor with new reference level 2 Base R (missing data) is.na Return TRUE if is found in vector na.omit Return a new vector/dataframe with ALL removed, with attribute containing info ro rows removed complete.cases Return TRUE if vector/data.frame row does not contain any 3 Base R (numeric) scale Centre numeric data (-mean), and optionally normalize it (/sd) cut Cut numeric vector into breakpoints, and return grouping factor 4 Base R (date) as.Date Parse a factor / string to date lubridate ymd,mdy,dmy Parse a string to date interval Return interval object betwen two given dates. Can be further used for deriving days/months in between ceiling.date Return next nearest date according to unit (day / month / year) 5 Base R (dataset) subset Return a new data based on input logical vector merge Merge two data.frame together based on common key nrow, ncol How many columns / rows in the dataset ? length How many elements in a vector ? caTools sample.split Split vector into two with a ratio, return result in logical vector "],
["5-2-sample-data.html", "5.2 Sample Data", " 5.2 Sample Data my.df &lt;- read.csv ( file=&quot;./datasets/import_sample.csv&quot;, na.strings=c(&#39;NA&#39;,&#39;NULL&#39;,&#39;&#39;)) # stringsAsFactors = FALSE ) my.df ## X X.1 dept gender weight height date_birth amount date_last ## 1 1 ID101 D1 Male 35.00000 173 1/7/1973 100 2/29/2016 ## 2 2 ID102 D2 Female 37.10000 164 28/2/1980 121 4/1/2017 ## 3 3 ID103 D3 Female 43.12000 178 31/12/1978 152 10/31/2015 ## 4 4 ID104 D1 Male 38.12300 182 12/1/1997 133 11/1/2016 ## 5 5 ID105 D1 Male 54.12340 159 2/1/1982 143 9/30/2016 ## 6 6 ID106 D3 Female 34.12345 166 26/7/1973 155 11/27/2015 ## 7 7 ID107 D2 Male 49.12346 153 21/8/1985 117 3/31/2017 ## 8 8 ID108 D1 Male 50.20000 159 2/1/1982 143 9/30/2016 ## 9 9 ID109 D3 Female 59.10000 166 13/7/1975 155 11/1/2017 ## 10 10 ID110 D2 Male 63.20000 163 24/8/1982 117 3/12/2016 ## 11 11 ID111 D3 Female 75.10000 170 9/8/1979 135 2/1/2015 ## 12 12 ID112 D2 Male 52.10000 169 &lt;NA&gt; 128 &lt;NA&gt; ## 13 13 ID113 D3 &lt;NA&gt; 88.80000 171 &lt;NA&gt; 141 &lt;NA&gt; ## date.first ## 1 2013-07-31 ## 2 2013-08-31 ## 3 2014-12-31 ## 4 2015-02-28 ## 5 2012-06-15 ## 6 2013-04-28 ## 7 2014-03-01 ## 8 2011-06-15 ## 9 2012-04-02 ## 10 2013-03-12 ## 11 &lt;NA&gt; ## 12 &lt;NA&gt; ## 13 &lt;NA&gt; str(my.df) ## &#39;data.frame&#39;: 13 obs. of 10 variables: ## $ X : int 1 2 3 4 5 6 7 8 9 10 ... ## $ X.1 : Factor w/ 13 levels &quot;ID101&quot;,&quot;ID102&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... ## $ dept : Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 2 3 1 1 3 2 1 3 2 ... ## $ gender : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 1 1 2 2 1 2 2 1 2 ... ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 159 166 163 ... ## $ date_birth: Factor w/ 10 levels &quot;1/7/1973&quot;,&quot;12/1/1997&quot;,..: 1 8 9 2 4 7 5 4 3 6 ... ## $ amount : int 100 121 152 133 143 155 117 143 155 117 ... ## $ date_last : Factor w/ 10 levels &quot;10/31/2015&quot;,&quot;11/1/2016&quot;,..: 6 9 1 2 10 4 8 10 3 7 ... ## $ date.first: Factor w/ 10 levels &quot;2011-06-15&quot;,&quot;2012-04-02&quot;,..: 6 7 9 10 3 5 8 1 2 4 ... "],
["5-3-column-manipulation.html", "5.3 Column Manipulation", " 5.3 Column Manipulation 5.3.1 Duplicating Columns Duplicate single column using $ selector my.df$Z1 = my.df$X my.df$Z2 = my.df$X str(my.df) ## &#39;data.frame&#39;: 13 obs. of 12 variables: ## $ X : int 1 2 3 4 5 6 7 8 9 10 ... ## $ X.1 : Factor w/ 13 levels &quot;ID101&quot;,&quot;ID102&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... ## $ dept : Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 2 3 1 1 3 2 1 3 2 ... ## $ gender : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 1 1 2 2 1 2 2 1 2 ... ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 159 166 163 ... ## $ date_birth: Factor w/ 10 levels &quot;1/7/1973&quot;,&quot;12/1/1997&quot;,..: 1 8 9 2 4 7 5 4 3 6 ... ## $ amount : int 100 121 152 133 143 155 117 143 155 117 ... ## $ date_last : Factor w/ 10 levels &quot;10/31/2015&quot;,&quot;11/1/2016&quot;,..: 6 9 1 2 10 4 8 10 3 7 ... ## $ date.first: Factor w/ 10 levels &quot;2011-06-15&quot;,&quot;2012-04-02&quot;,..: 6 7 9 10 3 5 8 1 2 4 ... ## $ Z1 : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Z2 : int 1 2 3 4 5 6 7 8 9 10 ... 5.3.2 Delete Columns 5.3.2.1 Delete One Column Use $ column selector, setting to NULL. my.df$Z1 = NULL 5.3.2.2 Delete Multiple Columns Use multiple columns selector [,vector], with vector containing column numbers or names, setting to NULL. my.df[,c(&#39;X&#39;,&#39;Z2&#39;)] = NULL str(my.df) ## &#39;data.frame&#39;: 13 obs. of 9 variables: ## $ X.1 : Factor w/ 13 levels &quot;ID101&quot;,&quot;ID102&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... ## $ dept : Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 2 3 1 1 3 2 1 3 2 ... ## $ gender : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 1 1 2 2 1 2 2 1 2 ... ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 159 166 163 ... ## $ date_birth: Factor w/ 10 levels &quot;1/7/1973&quot;,&quot;12/1/1997&quot;,..: 1 8 9 2 4 7 5 4 3 6 ... ## $ amount : int 100 121 152 133 143 155 117 143 155 117 ... ## $ date_last : Factor w/ 10 levels &quot;10/31/2015&quot;,&quot;11/1/2016&quot;,..: 6 9 1 2 10 4 8 10 3 7 ... ## $ date.first: Factor w/ 10 levels &quot;2011-06-15&quot;,&quot;2012-04-02&quot;,..: 6 7 9 10 3 5 8 1 2 4 ... 5.3.3 Renaming Columns 5.3.3.1 What Are The Column Names colnames returns vector of names attribute of data.frame. colnames(my.df) ## [1] &quot;X.1&quot; &quot;dept&quot; &quot;gender&quot; &quot;weight&quot; &quot;height&quot; ## [6] &quot;date_birth&quot; &quot;amount&quot; &quot;date_last&quot; &quot;date.first&quot; 5.3.3.2 Set the Column Name(s) Use colnames to rename single or multiple columns. Use [] to select the specific column(s). colnames(my.df)[c(1,9)] = c(&#39;id&#39;,&#39;date_first&#39;) colnames(my.df) ## [1] &quot;id&quot; &quot;dept&quot; &quot;gender&quot; &quot;weight&quot; &quot;height&quot; ## [6] &quot;date_birth&quot; &quot;amount&quot; &quot;date_last&quot; &quot;date_first&quot; "],
["5-4-missing-data.html", "5.4 Missing Data", " 5.4 Missing Data 5.4.1 Detecting Complete/Incomplete Vector/Row complete.cases returns logical vector for elements that doesn’t contain , with TRUE. It can be applied to both vector or data.frame. complete.cases(my.df$date_birth) # vector example complete.cases(my.df) # data.frame example ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [12] FALSE FALSE ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE ## [12] FALSE FALSE Negate complete.cases resulting TRUE for rows containing . !complete.cases(my.df$date_birth) # vector example !complete.cases(my.df) # data.frame example ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [12] TRUE TRUE ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [12] TRUE TRUE Result from complete.cases is useful to retrieve incomplete rows for further investigation. my.df[!complete.cases(my.df),] ## id dept gender weight height date_birth amount date_last date_first ## 11 ID111 D3 Female 75.1 170 9/8/1979 135 2/1/2015 &lt;NA&gt; ## 12 ID112 D2 Male 52.1 169 &lt;NA&gt; 128 &lt;NA&gt; &lt;NA&gt; ## 13 ID113 D3 &lt;NA&gt; 88.8 171 &lt;NA&gt; 141 &lt;NA&gt; &lt;NA&gt; 5.4.2 Removing Missing Data na.omit returns data with removed. The advantage of this method compare to complete.cases are: - simpler syntax, filtering using [rows,] not require - additonal attribute, accessible through na.action(), providing information on element number removed 5.4.2.1 Remove Elements with Missing Data In Vector na.omit(my.df$date_birth) # vector example ## [1] 1/7/1973 28/2/1980 31/12/1978 12/1/1997 2/1/1982 26/7/1973 ## [7] 21/8/1985 2/1/1982 13/7/1975 24/8/1982 9/8/1979 ## attr(,&quot;na.action&quot;) ## [1] 12 13 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; ## 10 Levels: 1/7/1973 12/1/1997 13/7/1975 2/1/1982 21/8/1985 ... 9/8/1979 str(na.omit(my.df$date_birth)) ## Factor w/ 10 levels &quot;1/7/1973&quot;,&quot;12/1/1997&quot;,..: 1 8 9 2 4 7 5 4 3 6 ... ## - attr(*, &quot;na.action&quot;)=Class &#39;omit&#39; int [1:2] 12 13 5.4.2.2 Remove Rows with Missing Data In Data Frame # my.df[complete.cases(my.df),] # longer method which is less elegant my.df = na.omit(my.df) # data.frame example na.action(my.df) # number of rows removed ## 11 12 13 ## 11 12 13 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; "],
["5-5-merging-data.html", "5.5 Merging Data", " 5.5 Merging Data "],
["5-6-categorical-data.html", "5.6 Categorical Data", " 5.6 Categorical Data 5.6.1 Converting to Factor as.factor converts string, discrete integer and logical data to factor. Each unique value will make up the levels for the factor, (sorted alphabatically during creation time). Convert below string to factor, and the first element of the sorted unique value - D1 is the reference level. x = as.factor( c(&#39;D2&#39;, &#39;D1&#39;, &#39;D3&#39;, &#39;D3&#39;, &#39;D2&#39;, &#39;D1&#39;, &#39;D3&#39;) ) x ## [1] D2 D1 D3 D3 D2 D1 D3 ## Levels: D1 D2 D3 5.6.2 Releveling Factor relevel return a new factor with base reference changed. Notice current factor x has ’D1` as the reference. levels(x) ## [1] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; Change the reference to ‘D3’, return a new factor y = relevel(x, &#39;D3&#39;) levels(y) ## [1] &quot;D3&quot; &quot;D1&quot; &quot;D2&quot; 5.6.3 Dropping Levels Levels can be ‘squeezed’ if it contain levels that no longer have data in it. Original data below contain three levels, D1 D2 D3. After removing all ‘D2’ value from the factor, all three original levels still exist ! z = x[x!=&#39;D2&#39;] str(z) ## Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 3 3 1 3 Use droplevels to remove all unused levels. All value will be renumbered. z = droplevels(z) str(z) ## Factor w/ 2 levels &quot;D1&quot;,&quot;D3&quot;: 1 2 2 1 2 "],
["5-7-string-manipulation.html", "5.7 String Manipulation", " 5.7 String Manipulation 5.7.1 Extration 5.7.2 Removal 5.7.3 Concatenation "],
["5-8-date-manipulation.html", "5.8 Date Manipulation", " 5.8 Date Manipulation 5.8.1 Parsing Date When import date date from text file using read(), often date column are imported as string or factor. Note that lubridate::dmy,ymd can convert from string only, whereas as.Date can convert from both string and factor. Before Conversion, verify that all dates column are actually chr. str(my.df) ## &#39;data.frame&#39;: 10 obs. of 9 variables: ## $ id : Factor w/ 13 levels &quot;ID101&quot;,&quot;ID102&quot;,..: 1 2 3 4 5 6 7 8 9 10 ## $ dept : Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 2 3 1 1 3 2 1 3 2 ## $ gender : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 1 1 2 2 1 2 2 1 2 ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 159 166 163 ## $ date_birth: Factor w/ 10 levels &quot;1/7/1973&quot;,&quot;12/1/1997&quot;,..: 1 8 9 2 4 7 5 4 3 6 ## $ amount : int 100 121 152 133 143 155 117 143 155 117 ## $ date_last : Factor w/ 10 levels &quot;10/31/2015&quot;,&quot;11/1/2016&quot;,..: 6 9 1 2 10 4 8 10 3 7 ## $ date_first: Factor w/ 10 levels &quot;2011-06-15&quot;,&quot;2012-04-02&quot;,..: 6 7 9 10 3 5 8 1 2 4 ## - attr(*, &quot;na.action&quot;)=Class &#39;omit&#39; Named int [1:3] 11 12 13 ## .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;11&quot; &quot;12&quot; &quot;13&quot; Two ways to convert string to date: as.Date - convert vector into date data type. A format parameter has to be specified to match the source format. Otherwise as.Date will try default format of “%Y-%m-%d” then “%Y/%m/%d” lubridate::dmy, mdy, ymd - this is more elegant because manual format is not required. However, it converts only string data. If the data source is factor, convert it to string first In both methods, unmatched rows with unrecognized format will throw an error. my.df$date_birth = as.Date( my.df$date_birth, format = &quot;%d/%m/%Y&quot; ) # base R my.df$date_last = mdy( my.df$date_last ) # lubridate my.df$date_first = ymd( my.df$date_first ) # lubridate str(my.df) ## &#39;data.frame&#39;: 10 obs. of 9 variables: ## $ id : Factor w/ 13 levels &quot;ID101&quot;,&quot;ID102&quot;,..: 1 2 3 4 5 6 7 8 9 10 ## $ dept : Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 2 3 1 1 3 2 1 3 2 ## $ gender : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 1 1 2 2 1 2 2 1 2 ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 159 166 163 ## $ date_birth: Date, format: &quot;1973-07-01&quot; &quot;1980-02-28&quot; ... ## $ amount : int 100 121 152 133 143 155 117 143 155 117 ## $ date_last : Date, format: &quot;2016-02-29&quot; &quot;2017-04-01&quot; ... ## $ date_first: Date, format: &quot;2013-07-31&quot; &quot;2013-08-31&quot; ... ## - attr(*, &quot;na.action&quot;)=Class &#39;omit&#39; Named int [1:3] 11 12 13 ## .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;11&quot; &quot;12&quot; &quot;13&quot; 5.8.2 What Day/Month/Year lubridate has useful functions to return numeric day, month, year from date object. 5.8.2.1 What Day d1 = as.Date(&#39;2017-03-31&#39;) lubridate::day(d1) ## [1] 31 5.8.2.2 What Month lubridate::month(d1) ## [1] 3 5.8.2.3 What Year lubridate::year(d1) ## [1] 2017 5.8.3 Days/Months/Year Difference 5.8.3.1 Days Difference my.df$date_last my.df$date_first my.df$date_last - my.df$date_first ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; &quot;2012-06-15&quot; ## [6] &quot;2013-04-28&quot; &quot;2014-03-01&quot; &quot;2011-06-15&quot; &quot;2012-04-02&quot; &quot;2013-03-12&quot; ## Time differences in days ## [1] 943 1309 304 612 1568 943 1126 1934 2039 1096 5.8.3.2 Months Difference Combination of lubridate::interval and lubridate operator provides a integer vector of months elapsed between two date: - The result can be negative if first date parameter &gt; second date parameter - lubridate ‘intelligently’ knows interval is from end of month to end of month interval interval( ymd(&#39;2016-03-30&#39;), ymd(&#39;2016-04-29&#39;) ) %/% months(1) # end day no. &lt; begining day no. interval( ymd(&#39;2016-03-30&#39;), ymd(&#39;2016-04-30&#39;) ) %/% months(1) # end day no. == beginning day no. interval( ymd(&#39;2016-03-31&#39;), ymd(&#39;2016-04-30&#39;) ) %/% months(1) # end of month to end of month ## [1] 0 ## [1] 1 ## [1] 1 Apply this to data frame / vector. my.df$date_first my.df$date_last interval( my.df$date_first, my.df$date_last ) %/% months(1) ## [1] &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; &quot;2012-06-15&quot; ## [6] &quot;2013-04-28&quot; &quot;2014-03-01&quot; &quot;2011-06-15&quot; &quot;2012-04-02&quot; &quot;2013-03-12&quot; ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] 31 43 10 20 51 30 36 63 66 36 5.8.3.3 Years Difference Use lubridate::year function to find the year (integer) of a given date. Difference of the year() results from the birthdate and current date is the Age. year(now()) - year(my.df$date_birth) ## [1] 44 37 39 20 35 44 32 35 42 35 However in insurance industry, only a full year is considred for age. interval( ymd(&#39;2016-02-29&#39;), ymd(&#39;2017-02-27&#39;) ) %/% years(1) # a day short for a year interval( ymd(&#39;2016-02-29&#39;), ymd(&#39;2017-02-28&#39;) ) %/% years(1) # EoM to EoM ## [1] 0 ## [1] 1 Apply this to data frame / vector. my.df$date_first my.df$date_last interval( my.df$date_first, my.df$date_last ) %/% years(1) ## [1] &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; &quot;2012-06-15&quot; ## [6] &quot;2013-04-28&quot; &quot;2014-03-01&quot; &quot;2011-06-15&quot; &quot;2012-04-02&quot; &quot;2013-03-12&quot; ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] 2 3 0 1 4 2 3 5 5 3 5.8.4 Days/Monhts/Years Later Adding days to a date is simple. Just + days(123) for 123 days later. However, adding months and years is tricky, because certain months are shorter. Good solution is to use lubridate::%m+% operator. 5.8.4.1 Days Later Adding days is as simple as add number of days to the date variables. my.df$date_last ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; 5.8.4.2 Months Later Adding month(s) is tricky on the last day of month. Use lubridate operator for correct solution, because it takes cares of last day of month including February of leap years. my.df$date_last my.df$date_last + months(1) # 1 month later, bad solution, can result in &lt;NA&gt; my.df$date_last %m+% months(1) # 1 month later, good solution ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] &quot;2016-03-29&quot; &quot;2017-05-01&quot; NA &quot;2016-12-01&quot; &quot;2016-10-30&quot; ## [6] &quot;2015-12-27&quot; NA &quot;2016-10-30&quot; &quot;2017-12-01&quot; &quot;2016-04-12&quot; ## [1] &quot;2016-03-29&quot; &quot;2017-05-01&quot; &quot;2015-11-30&quot; &quot;2016-12-01&quot; &quot;2016-10-30&quot; ## [6] &quot;2015-12-27&quot; &quot;2017-04-30&quot; &quot;2016-10-30&quot; &quot;2017-12-01&quot; &quot;2016-04-12&quot; 5.8.4.3 Years Later Adding year(s) is similar to adding month(s) above. my.df$date_last my.df$date_last + years(1) # 1 year later, bad solution my.df$date_last %m+% years(1) # 1 year later, good solution ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] NA &quot;2018-04-01&quot; &quot;2016-10-31&quot; &quot;2017-11-01&quot; &quot;2017-09-30&quot; ## [6] &quot;2016-11-27&quot; &quot;2018-03-31&quot; &quot;2017-09-30&quot; &quot;2018-11-01&quot; &quot;2017-03-12&quot; ## [1] &quot;2017-02-28&quot; &quot;2018-04-01&quot; &quot;2016-10-31&quot; &quot;2017-11-01&quot; &quot;2017-09-30&quot; ## [6] &quot;2016-11-27&quot; &quot;2018-03-31&quot; &quot;2017-09-30&quot; &quot;2018-11-01&quot; &quot;2017-03-12&quot; 5.8.5 Last Day of Month lubridate::ceiling_date rounds up the date to the nearest unit. When rounding up a date to the **next nearest month*, it results the first day of next month. my.df$date_last ceiling_date(my.df$date_last, &quot;month&quot;) ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] &quot;2016-03-01&quot; &quot;2017-05-01&quot; &quot;2015-11-01&quot; &quot;2016-12-01&quot; &quot;2016-10-01&quot; ## [6] &quot;2015-12-01&quot; &quot;2017-04-01&quot; &quot;2016-10-01&quot; &quot;2017-12-01&quot; &quot;2016-04-01&quot; Substracting this date by one will return last day of the month. ceiling_date(my.df$date_last, &quot;month&quot;) - days(1) ## [1] &quot;2016-02-29&quot; &quot;2017-04-30&quot; &quot;2015-10-31&quot; &quot;2016-11-30&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-30&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-30&quot; &quot;2016-03-31&quot; "],
["5-9-number-manipulation.html", "5.9 Number Manipulation", " 5.9 Number Manipulation 5.9.1 Sample Data Scaling section will use sample data generated as below: set.seed(1234) num.df = data.frame( id = paste(&#39;ID_&#39;, 1:5, sep = &#39;&#39;), value1 = sample(50:100, 5), value2 = sample(10:50, 5), stringsAsFactors = F ) num.df ## id value1 value2 ## 1 ID_1 55 36 ## 2 ID_2 81 10 ## 3 ID_3 79 19 ## 4 ID_4 98 35 ## 5 ID_5 90 29 5.9.2 Z-Score Scaling scale apply transformation column-wise, for columns within matrix or dataframe scale return a matrix scale (x, center=T, scale=T) # default S-Score transformation \\(\\quad\\) center = T (default) means value minus with mean \\(\\quad\\) scale = T (default) means value divide by sd \\(\\quad\\) \\(\\quad\\) output scaled:center --&gt; mean \\(\\quad\\) \\(\\quad\\) output scaled:scale --&gt; sd scale( num.df[,2:3] ) ## value1 value2 ## [1,] -1.58066858 0.9170971 ## [2,] 0.02469795 -1.4206014 ## [3,] -0.09879179 -0.6113981 ## [4,] 1.07436067 0.8271856 ## [5,] 0.58040174 0.2877167 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 80.6 25.8 ## attr(,&quot;scaled:scale&quot;) ## value1 value2 ## 16.19568 11.12205 scale( num.df[,2:3], scale=F ) ## value1 value2 ## [1,] -25.6 10.2 ## [2,] 0.4 -15.8 ## [3,] -1.6 -6.8 ## [4,] 17.4 9.2 ## [5,] 9.4 3.2 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 80.6 25.8 5.9.3 Min Max Scaling Min-Max scaling will transform all numbers between 0 and 1. Easiest way to perform this transformation is to write a function then apply. min_max = function(x){(x-min(x))/(max(x)-min(x))} apply( num.df[,2:3], MARGIN = 2, FUN = min_max ) ## 2 means column-wise ## value1 value2 ## [1,] 0.0000000 1.0000000 ## [2,] 0.6046512 0.0000000 ## [3,] 0.5581395 0.3461538 ## [4,] 1.0000000 0.9615385 ## [5,] 0.8139535 0.7307692 "],
["5-10-artificial-grouping.html", "5.10 Artificial Grouping", " 5.10 Artificial Grouping Artificial group can be created based on existing numeric data. Such as age_group based on age. 5.10.1 Grouping with Numeric Breakpoints Simulate data with x,y,z variables. p simulates priority scoring. x = rnorm(10, mean = 10) y = rnorm(10, mean = 10) p = x * y Articial groups is created first by identifying the number of groups, generate the break points vector, then cut the data base on break points and return factor as output. Automatically calculate breakpoints by distributing numbers into the min-max range, in low to high order: num_groups = 4 breakPoints = seq(min(p), max(p), length.out = num_groups + 1) breakPoints ## [1] 85.59917 92.47633 99.35348 106.23063 113.10779 cut ( x, breaks, right = TRUE, include.lowest = FALSE) \\(\\quad\\) x: numeric vector to be cutted \\(\\quad\\) breaks: numeric vector ranging from low to high (in order) \\(\\quad\\) include.lowest: FALSE - ommit element matching lowest number in breaks \\(\\quad\\) right: TRUE - close end on right;open end on left The result from cut is factor based on order from breakPoints. Therefore, once convert into numeric, the group number is in order of low to high accoriding to breakPoints. Verify that group (g) has been assigned for each priority (p). g = as.numeric( cut( p, breakPoints, include.lowest=TRUE)) data.frame(p,g) ## p g ## 1 103.90189 3 ## 2 89.43620 1 ## 3 85.91982 1 ## 4 86.45631 1 ## 5 113.10779 4 ## 6 96.50497 2 ## 7 85.59917 1 ## 8 88.17396 1 ## 9 105.27011 3 ## 10 101.99212 3 5.10.2 Grouping based on Custom Criteria creates a logical vector, indicating. Ratio specified in SplitRatio will be have value ‘TRUE’ "],
["5-11-radom-dataset-splitting.html", "5.11 Radom Dataset Splitting", " 5.11 Radom Dataset Splitting When we have only ONE dataset, we can split them into training and testing, example 0.7/0.3 split. 5.11.1 Simple Random Split 5.11.1.1 Verify Dataset Verify the total number of rows before splitting. nrow(my.df) ## [1] 10 5.11.1.2 Create Randomized Row Numbers Vector Randomly pick 60% of elements from a bag of all row numbers, with no replacement. Verify that 60% of full observations are picked. set.seed(8034) train.rows = sample( 1:nrow(my.df), 0.6 * nrow(my.df) ) length(train.rows) ## [1] 6 train.rows ## [1] 5 7 4 3 1 10 5.11.1.3 Split Data Into Two Sets Subseting for the training data, using [,] row selection method. my.df [train.rows, ] # Training Data (0.6) ## dept gender weight height date_birth amount date_last date_first ## 5 D1 Male 54.12340 159 1982-01-02 143 2016-09-30 2012-06-15 ## 7 D2 Male 49.12346 153 1985-08-21 117 2017-03-31 2014-03-01 ## 4 D1 Male 38.12300 182 1997-01-12 133 2016-11-01 2015-02-28 ## 3 D3 Female 43.12000 178 1978-12-31 152 2015-10-31 2014-12-31 ## 1 D1 Male 35.00000 173 1973-07-01 100 2016-02-29 2013-07-31 ## 10 D2 Male 63.20000 163 1982-08-24 117 2016-03-12 2013-03-12 Subsetting the test data by negating the splitting row numbers. my.df [-train.rows, ] # Training Data (0.4) ## dept gender weight height date_birth amount date_last date_first ## 2 D2 Female 37.10000 164 1980-02-28 121 2017-04-01 2013-08-31 ## 6 D3 Female 34.12345 166 1973-07-26 155 2015-11-27 2013-04-28 ## 8 D1 Male 50.20000 159 1982-01-02 143 2016-09-30 2011-06-15 ## 9 D3 Female 59.10000 166 1975-07-13 155 2017-11-01 2012-04-02 5.11.2 Random Split (Maintaining Data Value Ratio) Sometimes we want to maintain the original data value ratio. For example, if original factor variable contains 40%A, 30%B and 30%C, and we want the splitted sample to maintain 40-30-30 ratio. For prediction on classification/clustering, usually the dependent variable (categorical/binary) is used as spliting parameter For regression prediction of continuous data, it doesn’t make sense to use dependent variable for spliting, as the ratio cannot be determined with continuous data Maintaining the ratio is key difference to sample approach which does not care about the original balance 5.11.2.1 Verify Data Value Ratio We are going to split the data frame, while maintaining the ratio of dept variable. Here is distribution dept variable. table(my.df[,c(&#39;dept&#39;)]) ## ## D1 D2 D3 ## 4 3 3 5.11.2.2 Create The Spliting Logical Vector Create the logical vector of the split, while maintaining the underlying factor ratio caTools::sample.split takes a vector (or a column from a data.frame), randomly assign TRUE (training data) and FALSE (test data) according to a specified ratio. It returns a logical vector for data subsetting purpose. sample.split (Y, SplitRatio = 2/3, group = NULL) \\(\\quad\\) Y = vector, of which ratio of value to be maintained \\(\\quad\\) SplitRatio = ratio of split set.seed(8034) spl = sample.split(my.df$dept, 0.6) # randomly 0.6 set to TRUE, remaining FALSE spl ## [1] FALSE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE 5.11.2.3 Split Data Into Two Sets Subseting for the training data, using subset or [,] row selection method # my.df[split.data,] # alternative s1 = subset( my.df, spl ) # Training Data (0.6) table(s1[,&#39;dept&#39;]) ## ## D1 D2 D3 ## 2 2 2 Subsetting the test data by negating the splitting logical vector. # my.df[!spl,] # alternative s2 = subset( my.df, !spl ) # Testing Data (0.4) table(s2[,&#39;dept&#39;]) ## ## D1 D2 D3 ## 2 1 1 -->"]
]
