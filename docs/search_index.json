[
["grouping-data.html", "Chapter 4 Grouping Data 4.1 Sample Data 4.2 Grouping Data", " Chapter 4 Grouping Data This capter explore manipulating table-like data, summarization and aggregation. 4.1 Sample Data Sample data used simulate two categorical-alike feature, and two numeric value feature: dept is random character between ‘D1’, ‘D2’ and ‘D3’ grp is random character with randomly generated ‘G1’, ‘G2’ value1 represents numeric value, normally distributed at mean 50 value2 is numeric value, normally distributed at mean 25 set.seed(1234) my.df = data.frame( dept = paste(&#39;D&#39;,sample(1:3, 100, replace = T),sep=&#39;&#39;), grp = paste(&#39;G&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), team = paste(&#39;T&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), value1 = rnorm(1:100, mean = 50, sd = 5), value2 = rnorm(1:100, mean = 20, sd = 3), value3 = rnorm(1:100, mean = 5, sd = 1), stringsAsFactors = F ) head(my.df) ## dept grp team value1 value2 value3 ## 1 D1 G1 T2 48.11381 21.31079 2.683964 ## 2 D2 G2 T2 50.48810 23.18037 5.562472 ## 3 D2 G1 T1 58.19372 21.35657 4.216225 ## 4 D2 G1 T2 45.62204 21.98960 4.773946 ## 5 D3 G1 T2 50.60880 16.59088 3.412897 ## 6 D2 G1 T2 56.81065 18.88851 5.547524 4.2 Grouping Data This chapter explore multiple methods to group data columns and computes value within groups. 4.2.1 aggretate - base R Aggregate is a very useful base R function and provides quick way to group data and values: Input in list/data.frame, computes and output new data.frame. It groups categorical variable(s) and compute value variable(s) based on function FUN. FUN can be min, max, mean, sd, sum or length (frequency count). ONLY ONE function is supported, and it applies to all value variables !!! 4.2.1.1 Basic Syntax (formula method) - data source is data.frame The formula method use ‘data’ parameter and therefore apply for single data source only. The objective is simplicy and without flexibility to customize column names aggregate (data = df, formula, FUN = function) Formula in the form: value~categorical one value variable ~ one categorical variable aggregate (data = my.df, value1 ~ grp, FUN = length) ## grp value1 ## 1 G1 48 ## 2 G2 52 one value variable ~ multiple categorical variables aggregate (data = my.df, value1 ~ grp + dept, FUN = length) ## grp dept value1 ## 1 G1 D1 23 ## 2 G2 D1 26 ## 3 G1 D2 14 ## 4 G2 D2 12 ## 5 G1 D3 11 ## 6 G2 D3 14 multiple value variables ~ one categorical variable, use cbind() aggregate (data = my.df, cbind(value1,value2) ~ grp, FUN = length) ## grp value1 value2 ## 1 G1 48 48 ## 2 G2 52 52 multiple value variables ~ multiple categorical variable aggregate (data = my.df, cbind(value1,value2) ~ grp + dept, FUN = length) ## grp dept value1 value2 ## 1 G1 D1 23 23 ## 2 G2 D1 26 26 ## 3 G1 D2 14 14 ## 4 G2 D2 12 12 ## 5 G1 D3 11 11 ## 6 G2 D3 14 14 ALL value variables ~ multiple categorical variable, use dot notation Change from FUN=length to sum results in error because sum() cannot be applied to non-numerical variable ‘team’ aggregate (data = my.df, . ~ grp + dept, FUN = length) ## grp dept team value1 value2 value3 ## 1 G1 D1 23 23 23 23 ## 2 G2 D1 26 26 26 26 ## 3 G1 D2 14 14 14 14 ## 4 G2 D2 12 12 12 12 ## 5 G1 D3 11 11 11 11 ## 6 G2 D3 14 14 14 14 4.2.1.2 Advance Syntax (by method) - data source is either list or data.frame The advantage of ’by method’ are: Can use list/data.frame subset method to choose column to display, hence flexible Can customize output column names (list subset method only) Flexibility to use multiple data sources, hence ‘data’ is not used and has no effect if specified Using list subseting: column name is not preserved, hence must specify meaningful column names. If not supplied, generic names and undesirable column names derived from data value will be used as column name aggregate (x = list(…value_variables…), by = list(…categorical_variables…), FUN = function) aggregate (x = list( v1_mean = my.df$value1, my.df$value2 ), by = list( my.df$grp, DEPT = my.df$dept), FUN=mean) ## Group.1 DEPT v1_mean ## 1 G1 D1 50.31850 ## 2 G2 D1 51.87504 ## 3 G1 D2 51.13119 ## 4 G2 D2 47.15365 ## 5 G1 D3 50.85523 ## 6 G2 D3 51.50880 ## c.21.3107917311184..23.1803717164621..21.3565711895861..21.9895958470612.. ## 1 20.08096 ## 2 19.98123 ## 3 21.17846 ## 4 20.67360 ## 5 18.63134 ## 6 20.35175 Using data.frame subseting: column names are preserved and no option to change. Notice attempt below to change the column name does not succeed aggregate( x = df[,c(…)], by = df[,c(…)]), FUN = function) aggregate( x = df[, p:q], by = df[,s:t]), FUN = function) aggregate(x=my.df[, c(v1_mean=&#39;value1&#39;, &#39;value2&#39;)], by=my.df[,c(GRP=&#39;grp&#39;, &#39;dept&#39;)], FUN=mean) # aggregate(x = my.df[, 4:5], by = my.df[, 1:2], FUN = mean) # produce similar result as above ## grp dept value1 value2 ## 1 G1 D1 50.31850 20.08096 ## 2 G2 D1 51.87504 19.98123 ## 3 G1 D2 51.13119 21.17846 ## 4 G2 D2 47.15365 20.67360 ## 5 G1 D3 50.85523 18.63134 ## 6 G2 D3 51.50880 20.35175 4.2.2 group_by - dplyr Package "]
]
