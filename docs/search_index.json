[
["4-data-summarization.html", "Chapter 4 Data Summarization ", " Chapter 4 Data Summarization "],
["4-1-library.html", "4.1 Library", " 4.1 Library library(dplyr) "],
["4-2-sample-data.html", "4.2 Sample Data", " 4.2 Sample Data Sample data used simulate two categorical-alike feature, and two numeric value feature: dept is random character between ‘D1’, ‘D2’ and ‘D3’ grp is random character with randomly generated ‘G1’, ‘G2’ value1 represents numeric value, normally distributed at mean 50 value2 is numeric value, normally distributed at mean 25 set.seed(1234) my.df = data.frame( com = paste(&#39;C&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), dept = paste(&#39;D&#39;,sample(1:3, 100, replace = T),sep=&#39;&#39;), grp = paste(&#39;G&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), team = paste(&#39;T&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), prd = paste(&#39;P&#39;,sample(1:5, 100, replace = T),sep=&#39;&#39;), value1 = rnorm(1:100, mean = 50, sd = 5), value2 = rnorm(1:100, mean = 20, sd = 3), value3 = rnorm(1:100, mean = 5, sd = 1), stringsAsFactors = F ) head(my.df) ## com dept grp team prd value1 value2 value3 ## 1 C1 D1 G2 T1 P4 52.18465 13.05189 5.362667 ## 2 C2 D2 G2 T2 P3 55.30062 21.68742 6.411405 ## 3 C2 D1 G1 T2 P4 52.26095 17.64867 6.367544 ## 4 C2 D1 G2 T1 P4 53.31599 19.32184 4.592824 ## 5 C2 D1 G2 T2 P3 44.31813 15.23869 5.762542 ## 6 C2 D1 G2 T1 P1 48.14751 21.64257 4.348799 str(my.df) ## &#39;data.frame&#39;: 100 obs. of 8 variables: ## $ com : chr &quot;C1&quot; &quot;C2&quot; &quot;C2&quot; &quot;C2&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D2&quot; &quot;D1&quot; &quot;D1&quot; ... ## $ grp : chr &quot;G2&quot; &quot;G2&quot; &quot;G1&quot; &quot;G2&quot; ... ## $ team : chr &quot;T1&quot; &quot;T2&quot; &quot;T2&quot; &quot;T1&quot; ... ## $ prd : chr &quot;P4&quot; &quot;P3&quot; &quot;P4&quot; &quot;P4&quot; ... ## $ value1: num 52.2 55.3 52.3 53.3 44.3 ... ## $ value2: num 13.1 21.7 17.6 19.3 15.2 ... ## $ value3: num 5.36 6.41 6.37 4.59 5.76 ... "],
["4-3-frequency-table.html", "4.3 Frequency Table", " 4.3 Frequency Table table return table object (which is also array) that report frequency count base of categorical-alike data provided. table has the below data type characteristics. Note that only 2-dimensional table object is a matrix Dimension is.atomic is.vector is.matrix is.array is.table t1 T F F T T t2 T F T T T t3 T F F T T t4 T F F T T ftable is technically a matrix with two dimensional data (it flatten multiple dimension data). It has below data type characteristic. Dimension is.atomic is.vector is.matrix is.array is.table 1 T F T T F 2 T F T T F 3 T F T T F 4 T F T T F 4.3.1 Single Dimension Data t1 = table( my.df$com ) t1 ## ## C1 C2 ## 55 45 str(t1) ## &#39;table&#39; int [1:2(1d)] 55 45 ## - attr(*, &quot;dimnames&quot;)=List of 1 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; 4.3.2 Two Dimension Data t2 = table( my.df$com, my.df$dept ) t2 ## ## D1 D2 D3 ## C1 16 18 21 ## C2 15 18 12 str(t2) ## &#39;table&#39; int [1:2, 1:3] 16 15 18 18 21 12 ## - attr(*, &quot;dimnames&quot;)=List of 2 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; 4.3.3 Three Dimension Data When table contain three or more dimension, use ftable (flat table) to put multi dimension table into one flat output t3 = table( my.df$com, my.df$dept, my.df$grp ) t3 ## , , = G1 ## ## ## D1 D2 D3 ## C1 10 7 11 ## C2 7 9 4 ## ## , , = G2 ## ## ## D1 D2 D3 ## C1 6 11 10 ## C2 8 9 8 str(t3) ## &#39;table&#39; int [1:2, 1:3, 1:2] 10 7 7 9 11 4 6 8 11 9 ... ## - attr(*, &quot;dimnames&quot;)=List of 3 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; f3 = ftable( t3 ) f3 ## G1 G2 ## ## C1 D1 10 6 ## D2 7 11 ## D3 11 10 ## C2 D1 7 8 ## D2 9 9 ## D3 4 8 str(f3) ## &#39;ftable&#39; int [1:6, 1:2] 10 7 11 7 9 4 6 11 10 8 ... ## - attr(*, &quot;row.vars&quot;)=List of 2 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## - attr(*, &quot;col.vars&quot;)=List of 1 ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; 4.3.4 Four Dimension Data When table contain three or more dimension, use ftable (flat table) to put multi dimension table into one flat output t4 = table( my.df$com, my.df$dept, my.df$grp, my.df$team ) t4 ## , , = G1, = T1 ## ## ## D1 D2 D3 ## C1 4 5 4 ## C2 4 5 1 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 ## C1 3 6 6 ## C2 5 5 4 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 ## C1 6 2 7 ## C2 3 4 3 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 ## C1 3 5 4 ## C2 3 4 4 str(t4) ## &#39;table&#39; int [1:2, 1:3, 1:2, 1:2] 4 4 5 5 4 1 3 5 6 5 ... ## - attr(*, &quot;dimnames&quot;)=List of 4 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; ## ..$ : chr [1:2] &quot;T1&quot; &quot;T2&quot; f4 = ftable( t4 ) f4 ## T1 T2 ## ## C1 D1 G1 4 6 ## G2 3 3 ## D2 G1 5 2 ## G2 6 5 ## D3 G1 4 7 ## G2 6 4 ## C2 D1 G1 4 3 ## G2 5 3 ## D2 G1 5 4 ## G2 5 4 ## D3 G1 1 3 ## G2 4 4 str(f4) ## &#39;ftable&#39; int [1:12, 1:2] 4 3 5 6 4 6 4 5 5 5 ... ## - attr(*, &quot;row.vars&quot;)=List of 3 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; ## - attr(*, &quot;col.vars&quot;)=List of 1 ## ..$ : chr [1:2] &quot;T1&quot; &quot;T2&quot; 4.3.5 Making Table Proportion prop.table converts table or ftable object into proportion. It can calculate table-wise, column-wise or row-wise proportion. prop.table (x,margin=NULL) \\(\\quad\\) x = table object \\(\\quad\\) margin = NULL: proportion table-wise, 1-row_wise, 2-column_wise 4.3.5.1 Proportion Table on ‘table’ object prop.table( t1 ) ## ## C1 C2 ## 0.55 0.45 prop.table( t2 ) ## ## D1 D2 D3 ## C1 0.16 0.18 0.21 ## C2 0.15 0.18 0.12 prop.table( t2, margin=1 ) ## ## D1 D2 D3 ## C1 0.2909091 0.3272727 0.3818182 ## C2 0.3333333 0.4000000 0.2666667 prop.table( t2, margin=2 ) ## ## D1 D2 D3 ## C1 0.5161290 0.5000000 0.6363636 ## C2 0.4838710 0.5000000 0.3636364 4.3.5.2 Proportion Table on ‘ftable’ object prop.table( f3 ) ## G1 G2 ## ## C1 D1 0.10 0.06 ## D2 0.07 0.11 ## D3 0.11 0.10 ## C2 D1 0.07 0.08 ## D2 0.09 0.09 ## D3 0.04 0.08 prop.table( f4 ) ## T1 T2 ## ## C1 D1 G1 0.04 0.06 ## G2 0.03 0.03 ## D2 G1 0.05 0.02 ## G2 0.06 0.05 ## D3 G1 0.04 0.07 ## G2 0.06 0.04 ## C2 D1 G1 0.04 0.03 ## G2 0.05 0.03 ## D2 G1 0.05 0.04 ## G2 0.05 0.04 ## D3 G1 0.01 0.03 ## G2 0.04 0.04 prop.table( f3, margin=1 ) ## G1 G2 ## ## C1 D1 0.6250000 0.3750000 ## D2 0.3888889 0.6111111 ## D3 0.5238095 0.4761905 ## C2 D1 0.4666667 0.5333333 ## D2 0.5000000 0.5000000 ## D3 0.3333333 0.6666667 prop.table( f4, margin=1 ) ## T1 T2 ## ## C1 D1 G1 0.4000000 0.6000000 ## G2 0.5000000 0.5000000 ## D2 G1 0.7142857 0.2857143 ## G2 0.5454545 0.4545455 ## D3 G1 0.3636364 0.6363636 ## G2 0.6000000 0.4000000 ## C2 D1 G1 0.5714286 0.4285714 ## G2 0.6250000 0.3750000 ## D2 G1 0.5555556 0.4444444 ## G2 0.5555556 0.4444444 ## D3 G1 0.2500000 0.7500000 ## G2 0.5000000 0.5000000 prop.table( f3, margin=2 ) ## G1 G2 ## ## C1 D1 0.20833333 0.11538462 ## D2 0.14583333 0.21153846 ## D3 0.22916667 0.19230769 ## C2 D1 0.14583333 0.15384615 ## D2 0.18750000 0.17307692 ## D3 0.08333333 0.15384615 prop.table( f4, margin=2 ) ## T1 T2 ## ## C1 D1 G1 0.07692308 0.12500000 ## G2 0.05769231 0.06250000 ## D2 G1 0.09615385 0.04166667 ## G2 0.11538462 0.10416667 ## D3 G1 0.07692308 0.14583333 ## G2 0.11538462 0.08333333 ## C2 D1 G1 0.07692308 0.06250000 ## G2 0.09615385 0.06250000 ## D2 G1 0.09615385 0.08333333 ## G2 0.09615385 0.08333333 ## D3 G1 0.01923077 0.06250000 ## G2 0.07692308 0.08333333 4.3.6 Adding Margin Info To Table addmargins (x, margin=NULL) \\(\\quad\\) x = table or ftable object \\(\\quad\\) margin = NULL: row and column-sum, 1-col_sum, 2-row_sum 4.3.6.1 Margin Info on ‘table’ object addmargins( t2) ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 addmargins( t2,margin=1 ) ## ## D1 D2 D3 ## C1 16 18 21 ## C2 15 18 12 ## Sum 31 36 33 addmargins( t2,margin=2 ) ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 addmargins( t3 ) ## , , = G1 ## ## ## D1 D2 D3 Sum ## C1 10 7 11 28 ## C2 7 9 4 20 ## Sum 17 16 15 48 ## ## , , = G2 ## ## ## D1 D2 D3 Sum ## C1 6 11 10 27 ## C2 8 9 8 25 ## Sum 14 20 18 52 ## ## , , = Sum ## ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 addmargins( t4 ) ## , , = G1, = T1 ## ## ## D1 D2 D3 Sum ## C1 4 5 4 13 ## C2 4 5 1 10 ## Sum 8 10 5 23 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 Sum ## C1 3 6 6 15 ## C2 5 5 4 14 ## Sum 8 11 10 29 ## ## , , = Sum, = T1 ## ## ## D1 D2 D3 Sum ## C1 7 11 10 28 ## C2 9 10 5 24 ## Sum 16 21 15 52 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 Sum ## C1 6 2 7 15 ## C2 3 4 3 10 ## Sum 9 6 10 25 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 Sum ## C1 3 5 4 12 ## C2 3 4 4 11 ## Sum 6 9 8 23 ## ## , , = Sum, = T2 ## ## ## D1 D2 D3 Sum ## C1 9 7 11 27 ## C2 6 8 7 21 ## Sum 15 15 18 48 ## ## , , = G1, = Sum ## ## ## D1 D2 D3 Sum ## C1 10 7 11 28 ## C2 7 9 4 20 ## Sum 17 16 15 48 ## ## , , = G2, = Sum ## ## ## D1 D2 D3 Sum ## C1 6 11 10 27 ## C2 8 9 8 25 ## Sum 14 20 18 52 ## ## , , = Sum, = Sum ## ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 4.3.6.2 Margin Info on ‘ftable’ object addmargins( f3 ) ## Sum ## 10 6 16 ## 7 11 18 ## 11 10 21 ## 7 8 15 ## 9 9 18 ## 4 8 12 ## Sum 48 52 100 addmargins( f4 ) ## Sum ## 4 6 10 ## 3 3 6 ## 5 2 7 ## 6 5 11 ## 4 7 11 ## 6 4 10 ## 4 3 7 ## 5 3 8 ## 5 4 9 ## 5 4 9 ## 1 3 4 ## 4 4 8 ## Sum 52 48 100 4.3.7 Proportion Table with Margin First to obtain the proportion table, then only add the margin. addmargins( prop.table( t2 )) # add both column and row margin ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( t2 ), 1) # add column margin ## ## D1 D2 D3 ## C1 0.16 0.18 0.21 ## C2 0.15 0.18 0.12 ## Sum 0.31 0.36 0.33 addmargins( prop.table( t2 ), 2) # add row margin ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 addmargins( prop.table( t3 )) ## , , = G1 ## ## ## D1 D2 D3 Sum ## C1 0.10 0.07 0.11 0.28 ## C2 0.07 0.09 0.04 0.20 ## Sum 0.17 0.16 0.15 0.48 ## ## , , = G2 ## ## ## D1 D2 D3 Sum ## C1 0.06 0.11 0.10 0.27 ## C2 0.08 0.09 0.08 0.25 ## Sum 0.14 0.20 0.18 0.52 ## ## , , = Sum ## ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( t4 )) ## , , = G1, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.04 0.05 0.04 0.13 ## C2 0.04 0.05 0.01 0.10 ## Sum 0.08 0.10 0.05 0.23 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.03 0.06 0.06 0.15 ## C2 0.05 0.05 0.04 0.14 ## Sum 0.08 0.11 0.10 0.29 ## ## , , = Sum, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.07 0.11 0.10 0.28 ## C2 0.09 0.10 0.05 0.24 ## Sum 0.16 0.21 0.15 0.52 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.06 0.02 0.07 0.15 ## C2 0.03 0.04 0.03 0.10 ## Sum 0.09 0.06 0.10 0.25 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.03 0.05 0.04 0.12 ## C2 0.03 0.04 0.04 0.11 ## Sum 0.06 0.09 0.08 0.23 ## ## , , = Sum, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.09 0.07 0.11 0.27 ## C2 0.06 0.08 0.07 0.21 ## Sum 0.15 0.15 0.18 0.48 ## ## , , = G1, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.10 0.07 0.11 0.28 ## C2 0.07 0.09 0.04 0.20 ## Sum 0.17 0.16 0.15 0.48 ## ## , , = G2, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.06 0.11 0.10 0.27 ## C2 0.08 0.09 0.08 0.25 ## Sum 0.14 0.20 0.18 0.52 ## ## , , = Sum, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( f3 )) ## Sum ## 0.10 0.06 0.16 ## 0.07 0.11 0.18 ## 0.11 0.10 0.21 ## 0.07 0.08 0.15 ## 0.09 0.09 0.18 ## 0.04 0.08 0.12 ## Sum 0.48 0.52 1.00 addmargins( prop.table( f4 )) ## Sum ## 0.04 0.06 0.10 ## 0.03 0.03 0.06 ## 0.05 0.02 0.07 ## 0.06 0.05 0.11 ## 0.04 0.07 0.11 ## 0.06 0.04 0.10 ## 0.04 0.03 0.07 ## 0.05 0.03 0.08 ## 0.05 0.04 0.09 ## 0.05 0.04 0.09 ## 0.01 0.03 0.04 ## 0.04 0.04 0.08 ## Sum 0.52 0.48 1.00 "],
["4-4-data-aggregation.html", "4.4 Data Aggregation", " 4.4 Data Aggregation This chapter explore multiple methods to group data columns and computes value within groups: tapply aggregate (10x slower than apply) 4.4.1 tapply tapply is quick and fast way to produce aggregation with ONE level of grouping. tapply ( X, INDEX, FUN, na.rm = FALSE ) $quad$ X = value vector $quad$ INDEX = groups data, can be factor, number of string $quad$ FUN = function to apply to elements in X according to group specified in INDEX $quad$ na.rm = ignore &lt;NA&gt; values tapply will divide the vector (X) into groups (base on index INDEX), and perform computation (FUN) on each group. If there are &lt;NA&gt; in the vector X, some FUN may fail to return value, such as mean, sum. So it is essential to specify na.rm = TRUE in these cases. Group identifier will be used as column name (accessible through names()). 4.4.1.1 FUN That Returns Vector t1 = tapply(my.df$value1, my.df$com, FUN=mean) t1 ## C1 C2 ## 50.02603 50.55429 names( t1 ) ## [1] &quot;C1&quot; &quot;C2&quot; 4.4.1.2 FUN That Returns Non-Vector - output is list t2 = tapply(my.df$value1, my.df$com, FUN=summary) t2 ## $C1 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 38.28 47.44 49.56 50.03 52.28 60.25 ## ## $C2 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 41.18 46.75 51.29 50.55 54.07 59.05 names( t2 ) ## [1] &quot;C1&quot; &quot;C2&quot; 4.4.2 aggretate - base R Aggregate is a very useful base R function and provides quick way to group data and values: Input in list/data.frame, computes and output new data.frame. It groups categorical variable(s) and compute value variable(s) based on function FUN. FUN can be min, max, mean, sd, sum or length (frequency count). ONLY ONE function is supported, and it applies to all value variables !!! 4.4.2.1 Basic Syntax (formula method) - data source is data.frame The formula method use ‘data’ parameter and therefore apply for single data source only. The objective is simplicy and without flexibility to customize column names aggregate (data = df, formula, FUN = function) Formula in the form: value~categorical one value variable ~ one categorical variable aggregate (data = my.df, value1 ~ grp, FUN = length) ## grp value1 ## 1 G1 48 ## 2 G2 52 one value variable ~ multiple categorical variables aggregate (data = my.df, value1 ~ grp + dept, FUN = length) ## grp dept value1 ## 1 G1 D1 17 ## 2 G2 D1 14 ## 3 G1 D2 16 ## 4 G2 D2 20 ## 5 G1 D3 15 ## 6 G2 D3 18 multiple value variables ~ one categorical variable, use cbind() aggregate (data = my.df, cbind(value1,value2) ~ grp, FUN = length) ## grp value1 value2 ## 1 G1 48 48 ## 2 G2 52 52 multiple value variables ~ multiple categorical variable aggregate (data = my.df, cbind(value1,value2) ~ grp + dept, FUN = length) ## grp dept value1 value2 ## 1 G1 D1 17 17 ## 2 G2 D1 14 14 ## 3 G1 D2 16 16 ## 4 G2 D2 20 20 ## 5 G1 D3 15 15 ## 6 G2 D3 18 18 ALL value variables ~ multiple categorical variable, use dot notation Change from FUN=length to sum results in error because sum() cannot be applied to non-numerical variable ‘team’ aggregate (data = my.df, . ~ grp + dept, FUN = length) ## grp dept com team prd value1 value2 value3 ## 1 G1 D1 17 17 17 17 17 17 ## 2 G2 D1 14 14 14 14 14 14 ## 3 G1 D2 16 16 16 16 16 16 ## 4 G2 D2 20 20 20 20 20 20 ## 5 G1 D3 15 15 15 15 15 15 ## 6 G2 D3 18 18 18 18 18 18 4.4.2.2 Advance Syntax (by method) - data source is either list or data.frame The advantage of ’by method’ are: Can use list/data.frame subset method to choose column to display, hence flexible Can customize output column names (list subset method only) Flexibility to use multiple data sources, hence ‘data’ is not used and has no effect if specified Using list subseting: column name is not preserved, hence must specify meaningful column names. If not supplied, generic names and undesirable column names derived from data value will be used as column name aggregate (x = list(…value_variables…), by = list(…categorical_variables…), FUN = function) aggregate (x = list( v1_mean = my.df$value1, my.df$value2 ), by = list( my.df$grp, DEPT = my.df$dept), FUN=mean) ## Group.1 DEPT v1_mean ## 1 G1 D1 49.45476 ## 2 G2 D1 49.24632 ## 3 G1 D2 52.53196 ## 4 G2 D2 50.49061 ## 5 G1 D3 51.34741 ## 6 G2 D3 48.64784 ## c.13.0518915454923..21.6874152709086..17.6486745817329..19.3218380413155.. ## 1 19.75117 ## 2 19.15763 ## 3 20.32423 ## 4 20.03524 ## 5 18.40269 ## 6 20.73220 Using data.frame subseting: column names are preserved and no option to change. Notice attempt below to change the column name does not succeed aggregate( x = df[,c(…)], by = df[,c(…)]), FUN = function) aggregate( x = df[, p:q], by = df[,s:t]), FUN = function) aggregate(x=my.df[, c(v1_mean=&#39;value1&#39;, &#39;value2&#39;)], by=my.df[,c(GRP=&#39;grp&#39;, &#39;dept&#39;)], FUN=mean) ## grp dept value1 value2 ## 1 G1 D1 49.45476 19.75117 ## 2 G2 D1 49.24632 19.15763 ## 3 G1 D2 52.53196 20.32423 ## 4 G2 D2 50.49061 20.03524 ## 5 G1 D3 51.34741 18.40269 ## 6 G2 D3 48.64784 20.73220 # aggregate(x = my.df[, 4:5], by = my.df[, 1:2], FUN = mean) # produce similar result as above 4.4.3 dplyr::Grouping and Summarizing 4.4.3.1 Grouping Gourping returns all rows, with internal grouping structure Display of tibble rows truncates automatically if too many rows. Use print(tbl_df(my.tbl), n=40) to display more rows (quite troublesome, but look at all the other benefits) The internal grouping structure can be used for many types of summarization (discussed below) To get the row numbers for each group, add additional column with mutate of row_number() d.df = my.df %&gt;% group_by(com,dept, grp) %&gt;% mutate( idx = row_number()) %&gt;% arrange( com,dept,grp) print(tbl_df(d.df),n=18) ## # A tibble: 100 x 9 ## com dept grp team prd value1 value2 value3 idx ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 C1 D1 G1 T1 P4 57.38485 25.67368 3.526344 1 ## 2 C1 D1 G1 T2 P1 43.88048 17.36577 3.798334 2 ## 3 C1 D1 G1 T1 P1 51.92468 19.86104 4.112561 3 ## 4 C1 D1 G1 T2 P2 51.59526 19.00501 3.833495 4 ## 5 C1 D1 G1 T2 P3 46.49515 18.25825 3.312780 5 ## 6 C1 D1 G1 T2 P4 41.16885 17.65594 7.239388 6 ## 7 C1 D1 G1 T2 P4 50.11813 21.25232 6.782608 7 ## 8 C1 D1 G1 T1 P3 49.79999 13.55708 6.038110 8 ## 9 C1 D1 G1 T2 P1 47.53860 19.14849 4.635542 9 ## 10 C1 D1 G1 T1 P4 55.63241 16.23800 4.972599 10 ## 11 C1 D1 G2 T1 P4 52.18465 13.05189 5.362667 1 ## 12 C1 D1 G2 T1 P5 51.69298 18.47111 3.704798 2 ## 13 C1 D1 G2 T1 P4 44.06117 20.92194 3.730439 3 ## 14 C1 D1 G2 T2 P4 45.23361 20.10846 3.775262 4 ## 15 C1 D1 G2 T2 P4 48.92934 16.17850 4.588945 5 ## 16 C1 D1 G2 T2 P5 54.77662 20.51524 4.348304 6 ## 17 C1 D2 G1 T1 P5 60.24702 17.48262 4.959793 1 ## 18 C1 D2 G1 T1 P5 48.77118 20.94729 4.159204 2 ## # ... with 82 more rows Verify the number of group levels in attr(*, &quot;vars&quot;) str(d.df) ## Classes &#39;grouped_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 100 obs. of 9 variables: ## $ com : chr &quot;C1&quot; &quot;C1&quot; &quot;C1&quot; &quot;C1&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D1&quot; &quot;D1&quot; &quot;D1&quot; ... ## $ grp : chr &quot;G1&quot; &quot;G1&quot; &quot;G1&quot; &quot;G1&quot; ... ## $ team : chr &quot;T1&quot; &quot;T2&quot; &quot;T1&quot; &quot;T2&quot; ... ## $ prd : chr &quot;P4&quot; &quot;P1&quot; &quot;P1&quot; &quot;P2&quot; ... ## $ value1: num 57.4 43.9 51.9 51.6 46.5 ... ## $ value2: num 25.7 17.4 19.9 19 18.3 ... ## $ value3: num 3.53 3.8 4.11 3.83 3.31 ... ## $ idx : int 1 2 3 4 5 6 7 8 9 10 ... ## - attr(*, &quot;vars&quot;)=List of 3 ## ..$ : symbol com ## ..$ : symbol dept ## ..$ : symbol grp ## - attr(*, &quot;indices&quot;)=List of 12 ## ..$ : int 0 1 2 3 4 5 6 7 8 9 ## ..$ : int 10 11 12 13 14 15 ## ..$ : int 16 17 18 19 20 21 22 ## ..$ : int 23 24 25 26 27 28 29 30 31 32 ... ## ..$ : int 34 35 36 37 38 39 40 41 42 43 ... ## ..$ : int 45 46 47 48 49 50 51 52 53 54 ## ..$ : int 55 56 57 58 59 60 61 ## ..$ : int 62 63 64 65 66 67 68 69 ## ..$ : int 70 71 72 73 74 75 76 77 78 ## ..$ : int 79 80 81 82 83 84 85 86 87 ## ..$ : int 88 89 90 91 ## ..$ : int 92 93 94 95 96 97 98 99 ## - attr(*, &quot;drop&quot;)= logi TRUE ## - attr(*, &quot;group_sizes&quot;)= int 10 6 7 11 11 10 7 8 9 9 ... ## - attr(*, &quot;biggest_group_size&quot;)= int 11 ## - attr(*, &quot;labels&quot;)=&#39;data.frame&#39;: 12 obs. of 3 variables: ## ..$ com : chr &quot;C1&quot; &quot;C1&quot; &quot;C1&quot; &quot;C1&quot; ... ## ..$ dept: chr &quot;D1&quot; &quot;D1&quot; &quot;D2&quot; &quot;D2&quot; ... ## ..$ grp : chr &quot;G1&quot; &quot;G2&quot; &quot;G1&quot; &quot;G2&quot; ... ## ..- attr(*, &quot;vars&quot;)=List of 3 ## .. ..$ : symbol com ## .. ..$ : symbol dept ## .. ..$ : symbol grp ## ..- attr(*, &quot;indices&quot;)=List of 12 ## .. ..$ : int 6 7 18 29 32 42 54 63 64 78 ## .. ..$ : int 0 14 17 51 88 92 ## .. ..$ : int 24 37 56 61 74 81 87 ## .. ..$ : int 31 44 47 50 58 62 66 76 77 82 ... ## .. ..$ : int 12 20 21 22 23 68 70 72 86 93 ... ## .. ..$ : int 16 19 30 34 36 48 84 94 96 98 ## .. ..$ : int 2 11 25 52 67 79 85 ## .. ..$ : int 3 4 5 9 13 26 69 83 ## .. ..$ : int 8 27 35 38 40 45 65 80 99 ## .. ..$ : int 1 28 33 43 49 59 60 71 73 ## .. ..$ : int 41 53 57 91 ## .. ..$ : int 10 15 39 46 55 75 89 95 ## ..- attr(*, &quot;drop&quot;)= logi TRUE ## ..- attr(*, &quot;group_sizes&quot;)= int 10 6 7 11 11 10 7 8 9 9 ... ## ..- attr(*, &quot;biggest_group_size&quot;)= int 11 4.4.3.2 Counting Group and provide additional column n, which counts the number of rows within the group. d.df = my.df %&gt;% count(com, dept, prd) d.df ## Source: local data frame [29 x 4] ## Groups: com, dept [?] ## ## # A tibble: 29 x 4 ## com dept prd n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 P1 3 ## 2 C1 D1 P2 1 ## 3 C1 D1 P3 2 ## 4 C1 D1 P4 8 ## 5 C1 D1 P5 2 ## 6 C1 D2 P2 4 ## 7 C1 D2 P3 6 ## 8 C1 D2 P4 4 ## 9 C1 D2 P5 4 ## 10 C1 D3 P1 5 ## # ... with 19 more rows # alternative long methods for similar result # my.df %&gt;% # group_by(com, dept, prd) %&gt;% # summarize(count = n()) Counting reduce grouping by one level. ### result in grouping of (com, dept), &#39;prd&#39; removed str(d.df) ## Classes &#39;grouped_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 29 obs. of 4 variables: ## $ com : chr &quot;C1&quot; &quot;C1&quot; &quot;C1&quot; &quot;C1&quot; ... ## $ dept: chr &quot;D1&quot; &quot;D1&quot; &quot;D1&quot; &quot;D1&quot; ... ## $ prd : chr &quot;P1&quot; &quot;P2&quot; &quot;P3&quot; &quot;P4&quot; ... ## $ n : int 3 1 2 8 2 4 6 4 4 5 ... ## - attr(*, &quot;vars&quot;)=List of 2 ## ..$ : symbol com ## ..$ : symbol dept ## - attr(*, &quot;drop&quot;)= logi TRUE 4.4.3.3 In-Group Row Numbering Summarize reduce group level by one, hence n() will return the rows within the new group. Example below group with three levels (com, dept,prd), however, after summarize, n() returns the number of rows within (com,dept) group. d.df = my.df %&gt;% group_by(com,dept,prd) %&gt;% summarize(avg.value1=mean(value1)) %&gt;% mutate (c = 1:n()) d.df ## Source: local data frame [29 x 5] ## Groups: com, dept [6] ## ## # A tibble: 29 x 5 ## com dept prd avg.value1 c ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 C1 D1 P1 47.78125 1 ## 2 C1 D1 P2 51.59526 2 ## 3 C1 D1 P3 48.14757 3 ## 4 C1 D1 P4 49.33913 4 ## 5 C1 D1 P5 53.23480 5 ## 6 C1 D2 P2 48.15502 1 ## 7 C1 D2 P3 50.31508 2 ## 8 C1 D2 P4 51.50564 3 ## 9 C1 D2 P5 54.87918 4 ## 10 C1 D3 P1 48.15483 1 ## # ... with 19 more rows 4.4.3.4 In-Group Row Selection Example below select highest occurance of prd within the group of (com,dept). It is based on the principe that count reduce group levels by one, then selection is based on rows within the new group. my.df %&gt;% count(com, dept, prd) %&gt;% slice(which.max(n)) ## Source: local data frame [6 x 4] ## Groups: com, dept [6] ## ## # A tibble: 6 x 4 ## com dept prd n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 P4 8 ## 2 C1 D2 P3 6 ## 3 C1 D3 P4 8 ## 4 C2 D1 P1 5 ## 5 C2 D2 P3 6 ## 6 C2 D3 P4 4 4.4.3.5 In-Group Summarization Many functions can be applied that returns a single value, to be assigned as new column. d.df = my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise( avg_value1 = mean(value1), min_value1 = min(value1), max_value1 = max(value1), n.team = n_distinct(team), count = n()) d.df ## Source: local data frame [29 x 8] ## Groups: com, dept [?] ## ## # A tibble: 29 x 8 ## com dept prd avg_value1 min_value1 max_value1 n.team count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 C1 D1 P1 47.78125 43.88048 51.92468 2 3 ## 2 C1 D1 P2 51.59526 51.59526 51.59526 1 1 ## 3 C1 D1 P3 48.14757 46.49515 49.79999 2 2 ## 4 C1 D1 P4 49.33913 41.16885 57.38485 2 8 ## 5 C1 D1 P5 53.23480 51.69298 54.77662 2 2 ## 6 C1 D2 P2 48.15502 47.10022 50.15033 2 4 ## 7 C1 D2 P3 50.31508 45.23657 55.41305 2 6 ## 8 C1 D2 P4 51.50564 47.40629 58.09895 2 4 ## 9 C1 D2 P5 54.87918 48.77118 60.24702 2 4 ## 10 C1 D3 P1 48.15483 38.27743 54.74316 2 5 ## # ... with 19 more rows Summarize reduce the grouping level by one. ### result in grouping of (com, dept), &#39;prd&#39; removed str(d.df) ## Classes &#39;grouped_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 29 obs. of 8 variables: ## $ com : chr &quot;C1&quot; &quot;C1&quot; &quot;C1&quot; &quot;C1&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D1&quot; &quot;D1&quot; &quot;D1&quot; ... ## $ prd : chr &quot;P1&quot; &quot;P2&quot; &quot;P3&quot; &quot;P4&quot; ... ## $ avg_value1: num 47.8 51.6 48.1 49.3 53.2 ... ## $ min_value1: num 43.9 51.6 46.5 41.2 51.7 ... ## $ max_value1: num 51.9 51.6 49.8 57.4 54.8 ... ## $ n.team : int 2 1 2 2 2 2 2 2 2 2 ... ## $ count : int 3 1 2 8 2 4 6 4 4 5 ... ## - attr(*, &quot;vars&quot;)=List of 2 ## ..$ : symbol com ## ..$ : symbol dept ## - attr(*, &quot;drop&quot;)= logi TRUE "],
["4-5-r-with-sql-emulation.html", "4.5 R with SQL Emulation", " 4.5 R with SQL Emulation Running SQL statement on existing data.frame are useful to derive summarization and aggregation for someone who are familiar with SQL. 4.5.1 Library sqldf library is required. It has dependency on gsubfn, proto and RSQLite packages. library(sqldf) 4.5.2 Run The Code R data.frame variable is specified in ‘FROM’ clause. Note that . is a SQL operator, any variable with ‘.’ must be contained within single quote. sqldf(&quot; SELECT com, dept, count(*) AS qty, AVG(value1) AS v1_mean, SUM(value2) AS v2_sum FROM &#39;my.df&#39; GROUP BY com, dept &quot;) ## com dept qty v1_mean v2_sum ## 1 C1 D1 16 49.52605 297.2627 ## 2 C1 D2 18 51.11388 355.7833 ## 3 C1 D3 21 49.47453 411.6937 ## 4 C2 D1 15 49.18417 306.7140 ## 5 C2 D2 18 51.68186 370.1092 ## 6 C2 D3 12 50.57559 237.5263 -->"]
]
