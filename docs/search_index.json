[
["4-data-summarization.html", "Chapter 4 Data Summarization ", " Chapter 4 Data Summarization "],
["4-1-library.html", "4.1 Library", " 4.1 Library Package Function Purpose 1 Base R table Generate frequency table ftable Generate flat table prop.table Generate probability table out from table or ftable addmargins Add margin to table or ftable tapply Produce aggregation with one level of grouping aggregate 2 | dplyr | select | select the columns | | | filter | filter rows based on criteria | | | group_by | create a tiblle table with group columns | | | ungroup | remvoe group columns | | | summarize | specify the columns and functions to summarize | | | summarize_at | specify the columns to be summarized | | | summarize_if | conditionally choose the columns to be summarized | | | summarize_all | summarize all columns, be it numeric or not | | | count | group and count the number of rows within each group | | | arrange | in-group sorting of rows | | | slice | in-group row selection | | | mutate | create a new column | 3 | tidyr | gather | Gather columns into rows | | | spread | Reverse of gather() | | | seperate | Seperate one column into multiple columns | | | unite | Reverse of seperate() | library(dplyr) library(tidyr) "],
["4-2-sample-data.html", "4.2 Sample Data", " 4.2 Sample Data Sample data used simulate two categorical-alike feature, and two numeric value feature: dept is random character between ‘D1’, ‘D2’ and ‘D3’ grp is random character with randomly generated ‘G1’, ‘G2’ value1 represents numeric value, normally distributed at mean 50 value2 is numeric value, normally distributed at mean 25 set.seed(1234) my.df = data.frame( com = paste(&#39;C&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), dept = paste(&#39;D&#39;,sample(1:3, 100, replace = T),sep=&#39;&#39;), grp = paste(&#39;G&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), team = paste(&#39;T&#39;,sample(1:2, 100, replace = T),sep=&#39;&#39;), prd = paste(&#39;P&#39;,sample(1:5, 100, replace = T),sep=&#39;&#39;), value1 = rnorm(1:100, mean = 50, sd = 5), value2 = rnorm(1:100, mean = 20, sd = 3), value3 = rnorm(1:100, mean = 5, sd = 1), stringsAsFactors = F ) head(my.df) ## com dept grp team prd value1 value2 value3 ## 1 C1 D1 G2 T1 P4 52.18465 13.05189 5.362667 ## 2 C2 D2 G2 T2 P3 55.30062 21.68742 6.411405 ## 3 C2 D1 G1 T2 P4 52.26095 17.64867 6.367544 ## 4 C2 D1 G2 T1 P4 53.31599 19.32184 4.592824 ## 5 C2 D1 G2 T2 P3 44.31813 15.23869 5.762542 ## 6 C2 D1 G2 T1 P1 48.14751 21.64257 4.348799 str(my.df) ## &#39;data.frame&#39;: 100 obs. of 8 variables: ## $ com : chr &quot;C1&quot; &quot;C2&quot; &quot;C2&quot; &quot;C2&quot; ... ## $ dept : chr &quot;D1&quot; &quot;D2&quot; &quot;D1&quot; &quot;D1&quot; ... ## $ grp : chr &quot;G2&quot; &quot;G2&quot; &quot;G1&quot; &quot;G2&quot; ... ## $ team : chr &quot;T1&quot; &quot;T2&quot; &quot;T2&quot; &quot;T1&quot; ... ## $ prd : chr &quot;P4&quot; &quot;P3&quot; &quot;P4&quot; &quot;P4&quot; ... ## $ value1: num 52.2 55.3 52.3 53.3 44.3 ... ## $ value2: num 13.1 21.7 17.6 19.3 15.2 ... ## $ value3: num 5.36 6.41 6.37 4.59 5.76 ... "],
["4-3-frequency-table.html", "4.3 Frequency Table", " 4.3 Frequency Table table return table object (which is also array) that report frequency count base of categorical-alike data provided. table has the below data type characteristics. Note that only 2-dimensional table object is a matrix Dimension is.atomic is.vector is.matrix is.array is.table t1 T F F T T t2 T F T T T t3 T F F T T t4 T F F T T ftable is technically a matrix with two dimensional data (it flatten multiple dimension data). It has below data type characteristic. Dimension is.atomic is.vector is.matrix is.array is.table 1 T F T T F 2 T F T T F 3 T F T T F 4 T F T T F 4.3.1 Single Dimension Data t1 = table( my.df$com ) t1 ## ## C1 C2 ## 55 45 str(t1) ## &#39;table&#39; int [1:2(1d)] 55 45 ## - attr(*, &quot;dimnames&quot;)=List of 1 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; 4.3.2 Two Dimension Data t2 = table( my.df$com, my.df$dept ) t2 ## ## D1 D2 D3 ## C1 16 18 21 ## C2 15 18 12 str(t2) ## &#39;table&#39; int [1:2, 1:3] 16 15 18 18 21 12 ## - attr(*, &quot;dimnames&quot;)=List of 2 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; 4.3.3 Three Dimension Data When table contain three or more dimension, use ftable (flat table) to put multi dimension table into one flat output t3 = table( my.df$com, my.df$dept, my.df$grp ) t3 ## , , = G1 ## ## ## D1 D2 D3 ## C1 10 7 11 ## C2 7 9 4 ## ## , , = G2 ## ## ## D1 D2 D3 ## C1 6 11 10 ## C2 8 9 8 str(t3) ## &#39;table&#39; int [1:2, 1:3, 1:2] 10 7 7 9 11 4 6 8 11 9 ... ## - attr(*, &quot;dimnames&quot;)=List of 3 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; f3 = ftable( t3 ) f3 ## G1 G2 ## ## C1 D1 10 6 ## D2 7 11 ## D3 11 10 ## C2 D1 7 8 ## D2 9 9 ## D3 4 8 str(f3) ## &#39;ftable&#39; int [1:6, 1:2] 10 7 11 7 9 4 6 11 10 8 ... ## - attr(*, &quot;row.vars&quot;)=List of 2 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## - attr(*, &quot;col.vars&quot;)=List of 1 ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; 4.3.4 Four Dimension Data When table contain three or more dimension, use ftable (flat table) to put multi dimension table into one flat output t4 = table( my.df$com, my.df$dept, my.df$grp, my.df$team ) t4 ## , , = G1, = T1 ## ## ## D1 D2 D3 ## C1 4 5 4 ## C2 4 5 1 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 ## C1 3 6 6 ## C2 5 5 4 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 ## C1 6 2 7 ## C2 3 4 3 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 ## C1 3 5 4 ## C2 3 4 4 str(t4) ## &#39;table&#39; int [1:2, 1:3, 1:2, 1:2] 4 4 5 5 4 1 3 5 6 5 ... ## - attr(*, &quot;dimnames&quot;)=List of 4 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; ## ..$ : chr [1:2] &quot;T1&quot; &quot;T2&quot; f4 = ftable( t4 ) f4 ## T1 T2 ## ## C1 D1 G1 4 6 ## G2 3 3 ## D2 G1 5 2 ## G2 6 5 ## D3 G1 4 7 ## G2 6 4 ## C2 D1 G1 4 3 ## G2 5 3 ## D2 G1 5 4 ## G2 5 4 ## D3 G1 1 3 ## G2 4 4 str(f4) ## &#39;ftable&#39; int [1:12, 1:2] 4 3 5 6 4 6 4 5 5 5 ... ## - attr(*, &quot;row.vars&quot;)=List of 3 ## ..$ : chr [1:2] &quot;C1&quot; &quot;C2&quot; ## ..$ : chr [1:3] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; ## ..$ : chr [1:2] &quot;G1&quot; &quot;G2&quot; ## - attr(*, &quot;col.vars&quot;)=List of 1 ## ..$ : chr [1:2] &quot;T1&quot; &quot;T2&quot; 4.3.5 Making Table Proportion prop.table converts table or ftable object into proportion. It can calculate table-wise, column-wise or row-wise proportion. prop.table (x,margin=NULL) \\(\\quad\\) x = table object \\(\\quad\\) margin = NULL: proportion table-wise, 1-row_wise, 2-column_wise 4.3.5.1 Proportion Table on ‘table’ object prop.table( t1 ) ## ## C1 C2 ## 0.55 0.45 prop.table( t2 ) ## ## D1 D2 D3 ## C1 0.16 0.18 0.21 ## C2 0.15 0.18 0.12 prop.table( t2, margin=1 ) ## ## D1 D2 D3 ## C1 0.2909091 0.3272727 0.3818182 ## C2 0.3333333 0.4000000 0.2666667 prop.table( t2, margin=2 ) ## ## D1 D2 D3 ## C1 0.5161290 0.5000000 0.6363636 ## C2 0.4838710 0.5000000 0.3636364 4.3.5.2 Proportion Table on ‘ftable’ object prop.table( f3 ) ## G1 G2 ## ## C1 D1 0.10 0.06 ## D2 0.07 0.11 ## D3 0.11 0.10 ## C2 D1 0.07 0.08 ## D2 0.09 0.09 ## D3 0.04 0.08 prop.table( f4 ) ## T1 T2 ## ## C1 D1 G1 0.04 0.06 ## G2 0.03 0.03 ## D2 G1 0.05 0.02 ## G2 0.06 0.05 ## D3 G1 0.04 0.07 ## G2 0.06 0.04 ## C2 D1 G1 0.04 0.03 ## G2 0.05 0.03 ## D2 G1 0.05 0.04 ## G2 0.05 0.04 ## D3 G1 0.01 0.03 ## G2 0.04 0.04 prop.table( f3, margin=1 ) ## G1 G2 ## ## C1 D1 0.6250000 0.3750000 ## D2 0.3888889 0.6111111 ## D3 0.5238095 0.4761905 ## C2 D1 0.4666667 0.5333333 ## D2 0.5000000 0.5000000 ## D3 0.3333333 0.6666667 prop.table( f4, margin=1 ) ## T1 T2 ## ## C1 D1 G1 0.4000000 0.6000000 ## G2 0.5000000 0.5000000 ## D2 G1 0.7142857 0.2857143 ## G2 0.5454545 0.4545455 ## D3 G1 0.3636364 0.6363636 ## G2 0.6000000 0.4000000 ## C2 D1 G1 0.5714286 0.4285714 ## G2 0.6250000 0.3750000 ## D2 G1 0.5555556 0.4444444 ## G2 0.5555556 0.4444444 ## D3 G1 0.2500000 0.7500000 ## G2 0.5000000 0.5000000 prop.table( f3, margin=2 ) ## G1 G2 ## ## C1 D1 0.20833333 0.11538462 ## D2 0.14583333 0.21153846 ## D3 0.22916667 0.19230769 ## C2 D1 0.14583333 0.15384615 ## D2 0.18750000 0.17307692 ## D3 0.08333333 0.15384615 prop.table( f4, margin=2 ) ## T1 T2 ## ## C1 D1 G1 0.07692308 0.12500000 ## G2 0.05769231 0.06250000 ## D2 G1 0.09615385 0.04166667 ## G2 0.11538462 0.10416667 ## D3 G1 0.07692308 0.14583333 ## G2 0.11538462 0.08333333 ## C2 D1 G1 0.07692308 0.06250000 ## G2 0.09615385 0.06250000 ## D2 G1 0.09615385 0.08333333 ## G2 0.09615385 0.08333333 ## D3 G1 0.01923077 0.06250000 ## G2 0.07692308 0.08333333 4.3.6 Adding Margin Info To Table addmargins (x, margin=NULL) \\(\\quad\\) x = table or ftable object \\(\\quad\\) margin = NULL: row and column-sum, 1-col_sum, 2-row_sum 4.3.6.1 Margin Info on ‘table’ object addmargins( t2) ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 addmargins( t2,margin=1 ) ## ## D1 D2 D3 ## C1 16 18 21 ## C2 15 18 12 ## Sum 31 36 33 addmargins( t2,margin=2 ) ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 addmargins( t3 ) ## , , = G1 ## ## ## D1 D2 D3 Sum ## C1 10 7 11 28 ## C2 7 9 4 20 ## Sum 17 16 15 48 ## ## , , = G2 ## ## ## D1 D2 D3 Sum ## C1 6 11 10 27 ## C2 8 9 8 25 ## Sum 14 20 18 52 ## ## , , = Sum ## ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 addmargins( t4 ) ## , , = G1, = T1 ## ## ## D1 D2 D3 Sum ## C1 4 5 4 13 ## C2 4 5 1 10 ## Sum 8 10 5 23 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 Sum ## C1 3 6 6 15 ## C2 5 5 4 14 ## Sum 8 11 10 29 ## ## , , = Sum, = T1 ## ## ## D1 D2 D3 Sum ## C1 7 11 10 28 ## C2 9 10 5 24 ## Sum 16 21 15 52 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 Sum ## C1 6 2 7 15 ## C2 3 4 3 10 ## Sum 9 6 10 25 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 Sum ## C1 3 5 4 12 ## C2 3 4 4 11 ## Sum 6 9 8 23 ## ## , , = Sum, = T2 ## ## ## D1 D2 D3 Sum ## C1 9 7 11 27 ## C2 6 8 7 21 ## Sum 15 15 18 48 ## ## , , = G1, = Sum ## ## ## D1 D2 D3 Sum ## C1 10 7 11 28 ## C2 7 9 4 20 ## Sum 17 16 15 48 ## ## , , = G2, = Sum ## ## ## D1 D2 D3 Sum ## C1 6 11 10 27 ## C2 8 9 8 25 ## Sum 14 20 18 52 ## ## , , = Sum, = Sum ## ## ## D1 D2 D3 Sum ## C1 16 18 21 55 ## C2 15 18 12 45 ## Sum 31 36 33 100 4.3.6.2 Margin Info on ‘ftable’ object addmargins( f3 ) ## Sum ## 10 6 16 ## 7 11 18 ## 11 10 21 ## 7 8 15 ## 9 9 18 ## 4 8 12 ## Sum 48 52 100 addmargins( f4 ) ## Sum ## 4 6 10 ## 3 3 6 ## 5 2 7 ## 6 5 11 ## 4 7 11 ## 6 4 10 ## 4 3 7 ## 5 3 8 ## 5 4 9 ## 5 4 9 ## 1 3 4 ## 4 4 8 ## Sum 52 48 100 4.3.7 Proportion Table with Margin First to obtain the proportion table, then only add the margin. addmargins( prop.table( t2 )) # add both column and row margin ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( t2 ), 1) # add column margin ## ## D1 D2 D3 ## C1 0.16 0.18 0.21 ## C2 0.15 0.18 0.12 ## Sum 0.31 0.36 0.33 addmargins( prop.table( t2 ), 2) # add row margin ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 addmargins( prop.table( t3 )) ## , , = G1 ## ## ## D1 D2 D3 Sum ## C1 0.10 0.07 0.11 0.28 ## C2 0.07 0.09 0.04 0.20 ## Sum 0.17 0.16 0.15 0.48 ## ## , , = G2 ## ## ## D1 D2 D3 Sum ## C1 0.06 0.11 0.10 0.27 ## C2 0.08 0.09 0.08 0.25 ## Sum 0.14 0.20 0.18 0.52 ## ## , , = Sum ## ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( t4 )) ## , , = G1, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.04 0.05 0.04 0.13 ## C2 0.04 0.05 0.01 0.10 ## Sum 0.08 0.10 0.05 0.23 ## ## , , = G2, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.03 0.06 0.06 0.15 ## C2 0.05 0.05 0.04 0.14 ## Sum 0.08 0.11 0.10 0.29 ## ## , , = Sum, = T1 ## ## ## D1 D2 D3 Sum ## C1 0.07 0.11 0.10 0.28 ## C2 0.09 0.10 0.05 0.24 ## Sum 0.16 0.21 0.15 0.52 ## ## , , = G1, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.06 0.02 0.07 0.15 ## C2 0.03 0.04 0.03 0.10 ## Sum 0.09 0.06 0.10 0.25 ## ## , , = G2, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.03 0.05 0.04 0.12 ## C2 0.03 0.04 0.04 0.11 ## Sum 0.06 0.09 0.08 0.23 ## ## , , = Sum, = T2 ## ## ## D1 D2 D3 Sum ## C1 0.09 0.07 0.11 0.27 ## C2 0.06 0.08 0.07 0.21 ## Sum 0.15 0.15 0.18 0.48 ## ## , , = G1, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.10 0.07 0.11 0.28 ## C2 0.07 0.09 0.04 0.20 ## Sum 0.17 0.16 0.15 0.48 ## ## , , = G2, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.06 0.11 0.10 0.27 ## C2 0.08 0.09 0.08 0.25 ## Sum 0.14 0.20 0.18 0.52 ## ## , , = Sum, = Sum ## ## ## D1 D2 D3 Sum ## C1 0.16 0.18 0.21 0.55 ## C2 0.15 0.18 0.12 0.45 ## Sum 0.31 0.36 0.33 1.00 addmargins( prop.table( f3 )) ## Sum ## 0.10 0.06 0.16 ## 0.07 0.11 0.18 ## 0.11 0.10 0.21 ## 0.07 0.08 0.15 ## 0.09 0.09 0.18 ## 0.04 0.08 0.12 ## Sum 0.48 0.52 1.00 addmargins( prop.table( f4 )) ## Sum ## 0.04 0.06 0.10 ## 0.03 0.03 0.06 ## 0.05 0.02 0.07 ## 0.06 0.05 0.11 ## 0.04 0.07 0.11 ## 0.06 0.04 0.10 ## 0.04 0.03 0.07 ## 0.05 0.03 0.08 ## 0.05 0.04 0.09 ## 0.05 0.04 0.09 ## 0.01 0.03 0.04 ## 0.04 0.04 0.08 ## Sum 0.52 0.48 1.00 "],
["4-4-data-aggregation.html", "4.4 Data Aggregation", " 4.4 Data Aggregation This chapter explore multiple methods to group data columns and computes value within groups: tapply aggregate (10x slower than apply) dplyr and tidyr, a much intuitive tools 4.4.1 tapply tapply is quick and fast way to produce aggregation with ONE level of grouping. tapply ( X, INDEX, FUN, na.rm = FALSE ) \\(\\quad\\) X = value vector \\(\\quad\\) INDEX = vector of groups data (can be factor, number or string) \\(\\quad\\) FUN = function to apply on X, according to group specified in INDEX \\(\\quad\\) na.rm = ignore &lt;NA&gt; values X and INDEX must have the same length tapply will divide the value vector (X) into groups (base on INDEX), and perform computation (FUN) on each group If there are &lt;NA&gt; in the vector X, some FUN may fail to return value, such as mean, sum. So it is essential to specify na.rm = TRUE in these cases Group identifier will be used as column name (accessible through names()) 4.4.1.1 FUN That Returns Vector t1 = tapply(my.df$value1, my.df$com, FUN=mean) t1 ## C1 C2 ## 50.02603 50.55429 names( t1 ) ## [1] &quot;C1&quot; &quot;C2&quot; 4.4.1.2 FUN That Returns Non-Vector - output is list t2 = tapply(my.df$value1, my.df$com, FUN=summary) t2 ## $C1 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 38.28 47.44 49.56 50.03 52.28 60.25 ## ## $C2 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 41.18 46.75 51.29 50.55 54.07 59.05 names( t2 ) ## [1] &quot;C1&quot; &quot;C2&quot; 4.4.2 aggretate - base R Aggregate is a very useful base R function and provides quick way to group data and values: Input in list/data.frame, computes and output new data.frame. It groups categorical variable(s) and compute value variable(s) based on function FUN. FUN can be min, max, mean, sd, sum or length (frequency count). ONLY ONE function is supported, and it applies to all value variables !!! 4.4.2.1 Basic Syntax (formula method) - data source is data.frame The formula method use ‘data’ parameter and therefore apply for single data source only. The objective is simplicy and without flexibility to customize column names aggregate (data = df, formula, FUN = function) \\(\\quad\\) Formula in the form: value~categorical 4.4.2.2 One value variable ~ one categorical variable aggregate (data = my.df, value1 ~ grp, FUN = length) ## grp value1 ## 1 G1 48 ## 2 G2 52 4.4.2.3 One value variable ~ multiple categorical variables aggregate (data = my.df, value1 ~ grp + dept, FUN = length) ## grp dept value1 ## 1 G1 D1 17 ## 2 G2 D1 14 ## 3 G1 D2 16 ## 4 G2 D2 20 ## 5 G1 D3 15 ## 6 G2 D3 18 4.4.2.4 Multiple value variables ~ one categorical variable, use cbind() aggregate (data = my.df, cbind(value1,value2) ~ grp, FUN = length) ## grp value1 value2 ## 1 G1 48 48 ## 2 G2 52 52 4.4.2.5 multiple value variables ~ multiple categorical variable aggregate (data = my.df, cbind(value1,value2) ~ grp + dept, FUN = length) ## grp dept value1 value2 ## 1 G1 D1 17 17 ## 2 G2 D1 14 14 ## 3 G1 D2 16 16 ## 4 G2 D2 20 20 ## 5 G1 D3 15 15 ## 6 G2 D3 18 18 4.4.2.6 ALL value variables ~ multiple categorical variable, use dot notation Change from FUN=length to sum results in error because sum() cannot be applied to non-numerical variable ‘team’ aggregate (data = my.df, . ~ grp + dept, FUN = length) ## grp dept com team prd value1 value2 value3 ## 1 G1 D1 17 17 17 17 17 17 ## 2 G2 D1 14 14 14 14 14 14 ## 3 G1 D2 16 16 16 16 16 16 ## 4 G2 D2 20 20 20 20 20 20 ## 5 G1 D3 15 15 15 15 15 15 ## 6 G2 D3 18 18 18 18 18 18 4.4.2.7 Advance Syntax (by method) - data source is either list or data.frame The advantage of ’by method’ are: Can use list/data.frame subset method to choose column to display, hence flexible Can customize output column names (list subset method only) Flexibility to use multiple data sources, hence ‘data’ is not used and has no effect if specified Using list subseting: column name is not preserved, hence must specify meaningful column names. If not supplied, generic names and undesirable column names derived from data value will be used as column name aggregate (x = list(…value_variables…), by = list(…categorical_variables…), FUN = function) aggregate (x = list( v1_mean = my.df$value1, my.df$value2 ), by = list( my.df$grp, DEPT = my.df$dept), FUN=mean) ## Group.1 DEPT v1_mean ## 1 G1 D1 49.45476 ## 2 G2 D1 49.24632 ## 3 G1 D2 52.53196 ## 4 G2 D2 50.49061 ## 5 G1 D3 51.34741 ## 6 G2 D3 48.64784 ## c.13.0518915454923..21.6874152709086..17.6486745817329..19.3218380413155.. ## 1 19.75117 ## 2 19.15763 ## 3 20.32423 ## 4 20.03524 ## 5 18.40269 ## 6 20.73220 Using data.frame subseting: column names are preserved and no option to change. Notice attempt below to change the column name does not succeed aggregate( x = df[,c(…)], by = df[,c(…)]), FUN = function) aggregate( x = df[, p:q], by = df[,s:t]), FUN = function) aggregate(x=my.df[, c(v1_mean=&#39;value1&#39;, &#39;value2&#39;)], by=my.df[,c(GRP=&#39;grp&#39;, &#39;dept&#39;)], FUN=mean) ## grp dept value1 value2 ## 1 G1 D1 49.45476 19.75117 ## 2 G2 D1 49.24632 19.15763 ## 3 G1 D2 52.53196 20.32423 ## 4 G2 D2 50.49061 20.03524 ## 5 G1 D3 51.34741 18.40269 ## 6 G2 D3 48.64784 20.73220 # aggregate(x = my.df[, 4:5], by = my.df[, 1:2], FUN = mean) # produce similar result as above "],
["4-5-dplyr.html", "4.5 dplyr", " 4.5 dplyr 4.5.1 Grouping Gourping returns all rows, with internal grouping structure Display of tibble rows truncates automatically if too many rows. Use print(tbl_df(my.tbl), n=40) to display more rows (quite troublesome, but look at all the other benefits) The internal grouping structure can be used for many types of summarization (discussed below) To get the row numbers for each group, add additional column with mutate of row_number() d.df = my.df %&gt;% group_by(com,dept, grp) %&gt;% mutate( idx = row_number()) %&gt;% arrange( com,dept,grp) print(tbl_df(d.df),n=18) ## # A tibble: 100 x 9 ## com dept grp team prd value1 value2 value3 idx ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 C1 D1 G1 T1 P4 57.38485 25.67368 3.526344 1 ## 2 C1 D1 G1 T2 P1 43.88048 17.36577 3.798334 2 ## 3 C1 D1 G1 T1 P1 51.92468 19.86104 4.112561 3 ## 4 C1 D1 G1 T2 P2 51.59526 19.00501 3.833495 4 ## 5 C1 D1 G1 T2 P3 46.49515 18.25825 3.312780 5 ## 6 C1 D1 G1 T2 P4 41.16885 17.65594 7.239388 6 ## 7 C1 D1 G1 T2 P4 50.11813 21.25232 6.782608 7 ## 8 C1 D1 G1 T1 P3 49.79999 13.55708 6.038110 8 ## 9 C1 D1 G1 T2 P1 47.53860 19.14849 4.635542 9 ## 10 C1 D1 G1 T1 P4 55.63241 16.23800 4.972599 10 ## 11 C1 D1 G2 T1 P4 52.18465 13.05189 5.362667 1 ## 12 C1 D1 G2 T1 P5 51.69298 18.47111 3.704798 2 ## 13 C1 D1 G2 T1 P4 44.06117 20.92194 3.730439 3 ## 14 C1 D1 G2 T2 P4 45.23361 20.10846 3.775262 4 ## 15 C1 D1 G2 T2 P4 48.92934 16.17850 4.588945 5 ## 16 C1 D1 G2 T2 P5 54.77662 20.51524 4.348304 6 ## 17 C1 D2 G1 T1 P5 60.24702 17.48262 4.959793 1 ## 18 C1 D2 G1 T1 P5 48.77118 20.94729 4.159204 2 ## # ... with 82 more rows Verify group levels in attr(*, &quot;vars&quot;) attr(d.df, &#39;vars&#39;) ## [[1]] ## com ## ## [[2]] ## dept ## ## [[3]] ## grp 4.5.2 Counting count() groups and provide additional column n, which counts the number of rows within the group. d.df = my.df %&gt;% count(com, dept, prd) d.df ## Source: local data frame [29 x 4] ## Groups: com, dept [?] ## ## # A tibble: 29 x 4 ## com dept prd n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 P1 3 ## 2 C1 D1 P2 1 ## 3 C1 D1 P3 2 ## 4 C1 D1 P4 8 ## 5 C1 D1 P5 2 ## 6 C1 D2 P2 4 ## 7 C1 D2 P3 6 ## 8 C1 D2 P4 4 ## 9 C1 D2 P5 4 ## 10 C1 D3 P1 5 ## # ... with 19 more rows # alternative long methods for similar result # my.df %&gt;% # group_by(com, dept, prd) %&gt;% # summarize(count = n()) Similar to summarize, counting reduce grouping level by one. ### count() reduce group level by one, &#39;prd&#39; is removed from grouping attr(d.df, &#39;vars&#39;) ## [[1]] ## com ## ## [[2]] ## dept 4.5.3 In-Group Row Numbering Summarize reduce group level by one, hence n() will return the rows within the new group. Example below group with three levels (com, dept,prd), however, after summarize, n() returns the number of rows within (com,dept) group. d.df = my.df %&gt;% group_by(com,dept,prd) %&gt;% summarize(avg.value1=mean(value1)) %&gt;% mutate (c = 1:n()) d.df ## Source: local data frame [29 x 5] ## Groups: com, dept [6] ## ## # A tibble: 29 x 5 ## com dept prd avg.value1 c ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 C1 D1 P1 47.78125 1 ## 2 C1 D1 P2 51.59526 2 ## 3 C1 D1 P3 48.14757 3 ## 4 C1 D1 P4 49.33913 4 ## 5 C1 D1 P5 53.23480 5 ## 6 C1 D2 P2 48.15502 1 ## 7 C1 D2 P3 50.31508 2 ## 8 C1 D2 P4 51.50564 3 ## 9 C1 D2 P5 54.87918 4 ## 10 C1 D3 P1 48.15483 1 ## # ... with 19 more rows 4.5.4 In-Group Row Selection Example below select highest occurance of prd within the group of (com,dept). It is based on the principe that count reduce group levels by one, then selection is based on rows within the new group. my.df %&gt;% count(com, dept, prd) %&gt;% slice(which.max(n)) ## Source: local data frame [6 x 4] ## Groups: com, dept [6] ## ## # A tibble: 6 x 4 ## com dept prd n ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 C1 D1 P4 8 ## 2 C1 D2 P3 6 ## 3 C1 D3 P4 8 ## 4 C2 D1 P1 5 ## 5 C2 D2 P3 6 ## 6 C2 D3 P4 4 4.5.5 In-Group Summarization 4.5.5.1 Summarize Specific Columns, Mix Functions Many functions can be applied that returns a single value, to be assigned as new column. d.df = my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise( avg_value1 = mean(value1), min_value2 = min(value2), max_value3 = max(value3), n.team = n_distinct(team), count = n()) d.df ## Source: local data frame [29 x 8] ## Groups: com, dept [?] ## ## # A tibble: 29 x 8 ## com dept prd avg_value1 min_value2 max_value3 n.team count ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 C1 D1 P1 47.78125 17.36577 4.635542 2 3 ## 2 C1 D1 P2 51.59526 19.00501 3.833495 1 1 ## 3 C1 D1 P3 48.14757 13.55708 6.038110 2 2 ## 4 C1 D1 P4 49.33913 13.05189 7.239388 2 8 ## 5 C1 D1 P5 53.23480 18.47111 4.348304 2 2 ## 6 C1 D2 P2 48.15502 16.31955 5.984780 2 4 ## 7 C1 D2 P3 50.31508 14.24332 5.714599 2 6 ## 8 C1 D2 P4 51.50564 12.04478 6.206739 2 4 ## 9 C1 D2 P5 54.87918 17.48262 4.959793 2 4 ## 10 C1 D3 P1 48.15483 16.28942 6.466723 2 5 ## # ... with 19 more rows 4.5.5.2 Summarize Specific Columns, with Single Function my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_at(c(&#39;value2&#39;, &#39;value3&#39;), mean) ## Source: local data frame [29 x 5] ## Groups: com, dept [?] ## ## # A tibble: 29 x 5 ## com dept prd value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 18.79177 4.182146 ## 2 C1 D1 P2 19.00501 3.833495 ## 3 C1 D1 P3 15.90767 4.675445 ## 4 C1 D1 P4 18.88509 4.997282 ## 5 C1 D1 P5 19.49317 4.026551 ## 6 C1 D2 P2 20.13975 4.692159 ## 7 C1 D2 P3 20.44208 4.779972 ## 8 C1 D2 P4 18.35243 5.488939 ## 9 C1 D2 P5 19.79051 4.291767 ## 10 C1 D3 P1 18.56090 5.566364 ## # ... with 19 more rows 4.5.5.3 Summarize All Columns, with Single Function Notice that each column whin the group will be summarized with one more functions. This includes columns which are NOT numeric, resulting warnings and NA. my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_all(mean) ## Source: local data frame [29 x 8] ## Groups: com, dept [?] ## ## # A tibble: 29 x 8 ## com dept prd grp team value1 value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 NA NA 47.78125 18.79177 4.182146 ## 2 C1 D1 P2 NA NA 51.59526 19.00501 3.833495 ## 3 C1 D1 P3 NA NA 48.14757 15.90767 4.675445 ## 4 C1 D1 P4 NA NA 49.33913 18.88509 4.997282 ## 5 C1 D1 P5 NA NA 53.23480 19.49317 4.026551 ## 6 C1 D2 P2 NA NA 48.15502 20.13975 4.692159 ## 7 C1 D2 P3 NA NA 50.31508 20.44208 4.779972 ## 8 C1 D2 P4 NA NA 51.50564 18.35243 5.488939 ## 9 C1 D2 P5 NA NA 54.87918 19.79051 4.291767 ## 10 C1 D3 P1 NA NA 48.15483 18.56090 5.566364 ## # ... with 19 more rows 4.5.5.4 Summarize Specified Columns, with Single Function my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_at(c(&#39;value2&#39;,&#39;value3&#39;),mean) ## Source: local data frame [29 x 5] ## Groups: com, dept [?] ## ## # A tibble: 29 x 5 ## com dept prd value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 18.79177 4.182146 ## 2 C1 D1 P2 19.00501 3.833495 ## 3 C1 D1 P3 15.90767 4.675445 ## 4 C1 D1 P4 18.88509 4.997282 ## 5 C1 D1 P5 19.49317 4.026551 ## 6 C1 D2 P2 20.13975 4.692159 ## 7 C1 D2 P3 20.44208 4.779972 ## 8 C1 D2 P4 18.35243 5.488939 ## 9 C1 D2 P5 19.79051 4.291767 ## 10 C1 D3 P1 18.56090 5.566364 ## # ... with 19 more rows 4.5.5.5 Summarize Series of Columns, with Single Function Use vars() to select the sequence of variable names in colon : my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_at(vars(value1:value3),mean) ## Source: local data frame [29 x 6] ## Groups: com, dept [?] ## ## # A tibble: 29 x 6 ## com dept prd value1 value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 47.78125 18.79177 4.182146 ## 2 C1 D1 P2 51.59526 19.00501 3.833495 ## 3 C1 D1 P3 48.14757 15.90767 4.675445 ## 4 C1 D1 P4 49.33913 18.88509 4.997282 ## 5 C1 D1 P5 53.23480 19.49317 4.026551 ## 6 C1 D2 P2 48.15502 20.13975 4.692159 ## 7 C1 D2 P3 50.31508 20.44208 4.779972 ## 8 C1 D2 P4 51.50564 18.35243 5.488939 ## 9 C1 D2 P5 54.87918 19.79051 4.291767 ## 10 C1 D3 P1 48.15483 18.56090 5.566364 ## # ... with 19 more rows 4.5.5.6 Summarize Numeric Columns, with Single Function my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_if(is.numeric,mean) ## Source: local data frame [29 x 6] ## Groups: com, dept [?] ## ## # A tibble: 29 x 6 ## com dept prd value1 value2 value3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 47.78125 18.79177 4.182146 ## 2 C1 D1 P2 51.59526 19.00501 3.833495 ## 3 C1 D1 P3 48.14757 15.90767 4.675445 ## 4 C1 D1 P4 49.33913 18.88509 4.997282 ## 5 C1 D1 P5 53.23480 19.49317 4.026551 ## 6 C1 D2 P2 48.15502 20.13975 4.692159 ## 7 C1 D2 P3 50.31508 20.44208 4.779972 ## 8 C1 D2 P4 51.50564 18.35243 5.488939 ## 9 C1 D2 P5 54.87918 19.79051 4.291767 ## 10 C1 D3 P1 48.15483 18.56090 5.566364 ## # ... with 19 more rows 4.5.5.7 Summarize with Multiple Functions Any of the above summarize can combine with funs() to specify multiple functions. my.df %&gt;% group_by(com, dept, prd) %&gt;% summarise_if(is.numeric, funs(mean,sd)) ## Source: local data frame [29 x 9] ## Groups: com, dept [?] ## ## # A tibble: 29 x 9 ## com dept prd value1_mean value2_mean value3_mean value1_sd ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 C1 D1 P1 47.78125 18.79177 4.182146 4.027584 ## 2 C1 D1 P2 51.59526 19.00501 3.833495 NaN ## 3 C1 D1 P3 48.14757 15.90767 4.675445 2.336877 ## 4 C1 D1 P4 49.33913 18.88509 4.997282 5.665388 ## 5 C1 D1 P5 53.23480 19.49317 4.026551 2.180465 ## 6 C1 D2 P2 48.15502 20.13975 4.692159 1.368888 ## 7 C1 D2 P3 50.31508 20.44208 4.779972 3.929730 ## 8 C1 D2 P4 51.50564 18.35243 5.488939 4.903765 ## 9 C1 D2 P5 54.87918 19.79051 4.291767 5.315652 ## 10 C1 D3 P1 48.15483 18.56090 5.566364 6.122913 ## # ... with 19 more rows, and 2 more variables: value2_sd &lt;dbl&gt;, ## # value3_sd &lt;dbl&gt; 4.5.5.8 Summarize Reduce The Grouping Level by One ### result in grouping of (com, dept), &#39;prd&#39; has been removed from grouping attr(d.df, &#39;vars&#39;) ## [[1]] ## com ## ## [[2]] ## dept "],
["4-6-r-with-sql-emulation.html", "4.6 R with SQL Emulation", " 4.6 R with SQL Emulation Running SQL statement on existing data.frame are useful to derive summarization and aggregation for someone who are familiar with SQL. 4.6.1 Library sqldf library is required. It has dependency on gsubfn, proto and RSQLite packages. library(sqldf) 4.6.2 Run The Code R data.frame variable is specified in ‘FROM’ clause. Note that . is a SQL operator, any variable with ‘.’ must be contained within single quote. sqldf(&quot; SELECT com, dept, count(*) AS qty, AVG(value1) AS v1_mean, SUM(value2) AS v2_sum FROM &#39;my.df&#39; GROUP BY com, dept &quot;) ## com dept qty v1_mean v2_sum ## 1 C1 D1 16 49.52605 297.2627 ## 2 C1 D2 18 51.11388 355.7833 ## 3 C1 D3 21 49.47453 411.6937 ## 4 C2 D1 15 49.18417 306.7140 ## 5 C2 D2 18 51.68186 370.1092 ## 6 C2 D3 12 50.57559 237.5263 -->"]
]
