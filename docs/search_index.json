[
["5-data-preprocessing.html", "Chapter 5 Data Preprocessing ", " Chapter 5 Data Preprocessing "],
["5-1-library.html", "5.1 Library", " 5.1 Library library(lubridate) library(caTools) library(dplyr) library(caret) Below summarizes all packages, their functions and purposes used in this Data Preprocessing chapter. Package Function Purpose 1 Base R (factor) as.factor Convert a vector to a new factor droplevels Return a new factor with unused levels removed relevel Return a new factor with new reference level 2 Base R (missing data) is.na Return TRUE if is found in vector na.omit Return a new vector/dataframe with ALL removed, with attribute containing info ro rows removed complete.cases Return TRUE if vector/data.frame row does not contain any 3 Base R (numeric) scale Centre numeric data (-mean), and optionally normalize it (/sd) cut Cut numeric vector into breakpoints, and return grouping factor 4 Base R (date) as.Date Parse a factor / string to date lubridate ymd,mdy,dmy Parse a string to date interval Return interval object betwen two given dates. Can be further used for deriving days/months in between ceiling.date Return next nearest date according to unit (day / month / year) 5 Base R (dataset) subset Return a new data based on input logical vector merge Merge two data.frame together based on common key nrow, ncol How many columns / rows in the dataset ? length How many elements in a vector ? 6 caTools sample.split Split vector into two with a ratio, whiel maintain data value ratio, return result in logical vector 7 dplyr select extract columns from existing data.frame mutate Add new columns, from existing data.frame 8 caret preProcess Advance data transofrmation "],
["5-2-sample-data.html", "5.2 Sample Data", " 5.2 Sample Data my.df &lt;- read.csv ( file=&quot;./datasets/import_sample.csv&quot;, na.strings=c(&#39;NA&#39;,&#39;NULL&#39;,&#39;&#39;)) # stringsAsFactors = FALSE ) my.df ## X X.1 dept gender weight height date_birth amount date_last ## 1 1 ID101 D1 Male 35.00000 173 1/7/1973 100 2/29/2016 ## 2 2 ID102 D2 Female 37.10000 164 28/2/1980 121 4/1/2017 ## 3 3 ID103 D3 Female 43.12000 178 31/12/1978 152 10/31/2015 ## 4 4 ID104 D1 Male 38.12300 182 12/1/1997 133 11/1/2016 ## 5 5 ID105 D1 Male 54.12340 159 2/1/1982 143 9/30/2016 ## 6 6 ID106 D3 Female 34.12345 166 26/7/1973 155 11/27/2015 ## 7 7 ID107 D2 Male 49.12346 153 21/8/1985 117 3/31/2017 ## 8 8 ID108 D1 Male 50.20000 159 2/1/1982 143 9/30/2016 ## 9 9 ID109 D3 Female 59.10000 166 13/7/1975 155 11/1/2017 ## 10 10 ID110 D2 Male 63.20000 163 24/8/1982 117 3/12/2016 ## 11 11 ID111 D3 Female 75.10000 170 9/8/1979 135 2/1/2015 ## 12 12 ID112 D2 Male 52.10000 169 &lt;NA&gt; 128 &lt;NA&gt; ## 13 13 ID113 D3 &lt;NA&gt; 88.80000 171 &lt;NA&gt; 141 &lt;NA&gt; ## date.first ## 1 2013-07-31 ## 2 2013-08-31 ## 3 2014-12-31 ## 4 2015-02-28 ## 5 2012-06-15 ## 6 2013-04-28 ## 7 2014-03-01 ## 8 2011-06-15 ## 9 2012-04-02 ## 10 2013-03-12 ## 11 &lt;NA&gt; ## 12 &lt;NA&gt; ## 13 &lt;NA&gt; str(my.df) ## &#39;data.frame&#39;: 13 obs. of 10 variables: ## $ X : int 1 2 3 4 5 6 7 8 9 10 ... ## $ X.1 : Factor w/ 13 levels &quot;ID101&quot;,&quot;ID102&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... ## $ dept : Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 2 3 1 1 3 2 1 3 2 ... ## $ gender : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 1 1 2 2 1 2 2 1 2 ... ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 159 166 163 ... ## $ date_birth: Factor w/ 10 levels &quot;1/7/1973&quot;,&quot;12/1/1997&quot;,..: 1 8 9 2 4 7 5 4 3 6 ... ## $ amount : int 100 121 152 133 143 155 117 143 155 117 ... ## $ date_last : Factor w/ 10 levels &quot;10/31/2015&quot;,&quot;11/1/2016&quot;,..: 6 9 1 2 10 4 8 10 3 7 ... ## $ date.first: Factor w/ 10 levels &quot;2011-06-15&quot;,&quot;2012-04-02&quot;,..: 6 7 9 10 3 5 8 1 2 4 ... "],
["5-3-column-manipulation.html", "5.3 Column Manipulation", " 5.3 Column Manipulation 5.3.1 Duplicating Columns Duplicate single column using $ selector my.df$Z1 = my.df$X my.df$Z2 = my.df$X glimpse(my.df) ## Observations: 13 ## Variables: 12 ## $ X &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ## $ X.1 &lt;fctr&gt; ID101, ID102, ID103, ID104, ID105, ID106, ID107, I... ## $ dept &lt;fctr&gt; D1, D2, D3, D1, D1, D3, D2, D1, D3, D2, D3, D2, D3 ## $ gender &lt;fctr&gt; Male, Female, Female, Male, Male, Female, Male, Ma... ## $ weight &lt;dbl&gt; 35.00000, 37.10000, 43.12000, 38.12300, 54.12340, 3... ## $ height &lt;int&gt; 173, 164, 178, 182, 159, 166, 153, 159, 166, 163, 1... ## $ date_birth &lt;fctr&gt; 1/7/1973, 28/2/1980, 31/12/1978, 12/1/1997, 2/1/19... ## $ amount &lt;int&gt; 100, 121, 152, 133, 143, 155, 117, 143, 155, 117, 1... ## $ date_last &lt;fctr&gt; 2/29/2016, 4/1/2017, 10/31/2015, 11/1/2016, 9/30/2... ## $ date.first &lt;fctr&gt; 2013-07-31, 2013-08-31, 2014-12-31, 2015-02-28, 20... ## $ Z1 &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ## $ Z2 &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 5.3.2 Delete Columns 5.3.2.1 Delete One Column Use $ column selector, setting to NULL. my.df$Z1 = NULL 5.3.2.2 Delete Multiple Columns Use multiple columns selector [,vector], with vector containing column numbers or names, setting to NULL. my.df[,c(&#39;X&#39;,&#39;Z2&#39;)] = NULL glimpse(my.df) ## Observations: 13 ## Variables: 9 ## $ X.1 &lt;fctr&gt; ID101, ID102, ID103, ID104, ID105, ID106, ID107, I... ## $ dept &lt;fctr&gt; D1, D2, D3, D1, D1, D3, D2, D1, D3, D2, D3, D2, D3 ## $ gender &lt;fctr&gt; Male, Female, Female, Male, Male, Female, Male, Ma... ## $ weight &lt;dbl&gt; 35.00000, 37.10000, 43.12000, 38.12300, 54.12340, 3... ## $ height &lt;int&gt; 173, 164, 178, 182, 159, 166, 153, 159, 166, 163, 1... ## $ date_birth &lt;fctr&gt; 1/7/1973, 28/2/1980, 31/12/1978, 12/1/1997, 2/1/19... ## $ amount &lt;int&gt; 100, 121, 152, 133, 143, 155, 117, 143, 155, 117, 1... ## $ date_last &lt;fctr&gt; 2/29/2016, 4/1/2017, 10/31/2015, 11/1/2016, 9/30/2... ## $ date.first &lt;fctr&gt; 2013-07-31, 2013-08-31, 2014-12-31, 2015-02-28, 20... 5.3.3 Renaming Columns 5.3.3.1 What Are The Column Names colnames returns vector of names attribute of data.frame. colnames(my.df) ## [1] &quot;X.1&quot; &quot;dept&quot; &quot;gender&quot; &quot;weight&quot; &quot;height&quot; ## [6] &quot;date_birth&quot; &quot;amount&quot; &quot;date_last&quot; &quot;date.first&quot; 5.3.3.2 Set the Column Name(s) Use colnames to rename single or multiple columns. Use [] to select the specific column(s). colnames(my.df)[c(1,9)] = c(&#39;id&#39;,&#39;date_first&#39;) colnames(my.df) ## [1] &quot;id&quot; &quot;dept&quot; &quot;gender&quot; &quot;weight&quot; &quot;height&quot; ## [6] &quot;date_birth&quot; &quot;amount&quot; &quot;date_last&quot; &quot;date_first&quot; 5.3.4 Columns Selection 5.3.4.1 base R Use [,] notation to select columns head( my.df[,c(&#39;dept&#39;,&#39;gender&#39;,&#39;weight&#39;,&#39;height&#39;,&#39;amount&#39;,&#39;date_birth&#39;)] ) ## dept gender weight height amount date_birth ## 1 D1 Male 35.00000 173 100 1/7/1973 ## 2 D2 Female 37.10000 164 121 28/2/1980 ## 3 D3 Female 43.12000 178 152 31/12/1978 ## 4 D1 Male 38.12300 182 133 12/1/1997 ## 5 D1 Male 54.12340 159 143 2/1/1982 ## 6 D3 Female 34.12345 166 155 26/7/1973 5.3.4.2 dplyr As you can see, dplyr::select is more intuitive as compared to base [,] notation select(my.df, dept, gender, weight, height, amount, date_birth) %&gt;% head ## dept gender weight height amount date_birth ## 1 D1 Male 35.00000 173 100 1/7/1973 ## 2 D2 Female 37.10000 164 121 28/2/1980 ## 3 D3 Female 43.12000 178 152 31/12/1978 ## 4 D1 Male 38.12300 182 133 12/1/1997 ## 5 D1 Male 54.12340 159 143 2/1/1982 ## 6 D3 Female 34.12345 166 155 26/7/1973 5.3.5 Create New Columns 5.3.5.1 base ’\\(&#39; notation **\\) and [,]** are common useful notation in base R for data manipulation my.df$birth_month = month(my.df$date_birth) my.df$birth_year = year(my.df$date_birth) head( my.df[,c(&#39;date_birth&#39;, &#39;birth_year&#39;,&#39;birth_month&#39;)] ) ## date_birth birth_year birth_month ## 1 1/7/1973 1 7 ## 2 28/2/1980 28 2 ## 3 31/12/1978 31 12 ## 4 12/1/1997 12 1 ## 5 2/1/1982 2 1 ## 6 26/7/1973 26 7 5.3.5.2 dplyr::mutate Using dplyr family, we avoids repeating the data.frame name in the parameters See how elegantly we combined the statements using %&gt;% to improve readability by intuitive syntax construct and avoid repetition mutate(my.df, birth_month = month(date_birth), birth_year = year(date_birth)) %&gt;% select(date_birth, birth_year, birth_month) %&gt;% head ## date_birth birth_year birth_month ## 1 1/7/1973 1 7 ## 2 28/2/1980 28 2 ## 3 31/12/1978 31 12 ## 4 12/1/1997 12 1 ## 5 2/1/1982 2 1 ## 6 26/7/1973 26 7 "],
["5-4-missing-data.html", "5.4 Missing Data", " 5.4 Missing Data 5.4.1 Detecting Complete/Incomplete Vector/Row complete.cases returns logical vector for elements that doesn’t contain , with TRUE. It can be applied to both vector or data.frame. complete.cases(my.df$date_birth) # vector example complete.cases(my.df) # data.frame example ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [12] FALSE FALSE ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE ## [12] FALSE FALSE Negate complete.cases resulting TRUE for rows containing . !complete.cases(my.df$date_birth) # vector example !complete.cases(my.df) # data.frame example ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [12] TRUE TRUE ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [12] TRUE TRUE Result from complete.cases is useful to retrieve incomplete rows for further investigation. my.df[!complete.cases(my.df),] ## id dept gender weight height date_birth amount date_last date_first ## 11 ID111 D3 Female 75.1 170 9/8/1979 135 2/1/2015 &lt;NA&gt; ## 12 ID112 D2 Male 52.1 169 &lt;NA&gt; 128 &lt;NA&gt; &lt;NA&gt; ## 13 ID113 D3 &lt;NA&gt; 88.8 171 &lt;NA&gt; 141 &lt;NA&gt; &lt;NA&gt; ## birth_month birth_year ## 11 8 9 ## 12 NA NA ## 13 NA NA 5.4.2 Removing Missing Data na.omit returns data with removed. The advantage of this method compare to complete.cases are: - simpler syntax, filtering using [rows,] not require - additonal attribute, accessible through na.action(), providing information on element number removed 5.4.2.1 Remove Elements with Missing Data In Vector na.omit(my.df$date_birth) # vector example ## [1] 1/7/1973 28/2/1980 31/12/1978 12/1/1997 2/1/1982 26/7/1973 ## [7] 21/8/1985 2/1/1982 13/7/1975 24/8/1982 9/8/1979 ## attr(,&quot;na.action&quot;) ## [1] 12 13 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; ## 10 Levels: 1/7/1973 12/1/1997 13/7/1975 2/1/1982 21/8/1985 ... 9/8/1979 str(na.omit(my.df$date_birth)) ## Factor w/ 10 levels &quot;1/7/1973&quot;,&quot;12/1/1997&quot;,..: 1 8 9 2 4 7 5 4 3 6 ... ## - attr(*, &quot;na.action&quot;)=Class &#39;omit&#39; int [1:2] 12 13 5.4.2.2 Remove Rows with Missing Data In Data Frame # my.df[complete.cases(my.df),] # longer method which is less elegant my.df = na.omit(my.df) # data.frame example na.action(my.df) # number of rows removed ## 11 12 13 ## 11 12 13 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; "],
["5-5-merging-data.html", "5.5 Merging Data", " 5.5 Merging Data 5.5.1 Joining Columns 5.5.1.0.1 Left (Outer) Join Return all rows of x, and rows that match y are also returned with y columns The column of y in rows that do not match y is NA If multiple matches occur between x and y, all combinations are returned Left Join dplyr Method a &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ) , x2 = c ( 1 , 2 , 3 ) ) b &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;D&quot; ) , x3 = c ( TRUE , FALSE , TRUE ) ) dplyr::left_join ( a , b , by = &quot;x1&quot; ) ## # A tibble: 3 x 3 ## x1 x2 x3 ## &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA 5.5.1.1 Inner Join Returns only the rows matching the columns specified in x and y If there are multiple matches between x and y, all combinations will be returned Left Inner Join dplyr Method a &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ) , x2 = c ( 1 , 2 , 3 )) b &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;D&quot; ) , x3 = c ( TRUE , FALSE , TRUE ) ) dplyr::inner_join ( a , b , by = &quot;x1&quot; ) ## # A tibble: 2 x 3 ## x1 x2 x3 ## &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE 5.5.1.2 Right Join This is a reverse where x and y of left_join are reversed Return all rows of y, and columns that match x are also returned with columns of x The column of x of a row not matching x is NA If multiple matches occur between x and y, all combinations are returned Right Join dplyr Method a &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ) , x2 = c ( 1 , 2 , 3 ) ) b &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;D&quot; ) , x3 = c ( TRUE , FALSE , TRUE ) ) dplyr :: right_join ( a , b , by = &quot;x1&quot; ) ## # A tibble: 3 x 3 ## x1 x2 x3 ## &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 D NA TRUE 5.5.1.3 Full Join Return all rows and columns of x and y Where there is no match, it becomes NA Full Join dplyr Method a &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ) , x2 = c ( 1 , 2 , 3 ) ) b &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;D&quot; ) , x3 = c ( TRUE , FALSE , TRUE ) ) dplyr :: full_join ( a , b , by = &quot;x1&quot; ) ## # A tibble: 4 x 3 ## x1 x2 x3 ## &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 NA ## 4 D NA TRUE 5.5.1.4 Semi Join Return all x rows that matched y Columns returned are all columns of x Columns of y are not returned; this is different from inner_join Semi Join dplyr Method a &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ) , x2 = c ( 1 , 2 , 3 ) ) b &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;D&quot; ) , x3 = c ( TRUE , FALSE , TRUE ) ) dplyr::semi_join ( a , b , by = &quot;x1&quot; ) ## # A tibble: 2 x 2 ## x1 x2 ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 1 ## 2 B 2 5.5.1.5 Anti Join We return all x rows that did not match y All columns returned are x columns only and y columns are not returned Anti Join dplyr Method a &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ) , x2 = c ( 1 , 2 , 3 ) ) b &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;D&quot; ) , x3 = c ( TRUE , FALSE , TRUE ) ) dplyr::anti_join ( a , b , by = &quot;x1&quot; ) ## # A tibble: 1 x 2 ## x1 x2 ## &lt;chr&gt; &lt;dbl&gt; ## 1 C 3 5.5.2 Joining Rows: Set Operation 5.5.2.1 Intersect The columns at both x and y are returned Intersect dplyr Method y &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ) , x2 = c ( 1 , 2 , 3 ) ) z &lt;- dplyr :: data_frame ( x1 = c ( &quot;B&quot; , &quot;C&quot; , &quot;D&quot; ), x2 = c ( 2 , 3 , 4 ) ) dplyr :: intersect ( y , z ) ## # A tibble: 2 x 2 ## x1 x2 ## &lt;chr&gt; &lt;dbl&gt; ## 1 B 2 ## 2 C 3 5.5.2.2 Union A unique row with no duplication of x and y will be returned. Union dplyr Method y &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ) , x2 = c ( 1 , 2 , 3 ) ) z &lt;- dplyr :: data_frame ( x1 = c ( &quot;B&quot; , &quot;C&quot; , &quot;D&quot; ), x2 = c ( 2 , 3 , 4 ) ) dplyr :: union ( y , z ) ## # A tibble: 4 x 2 ## x1 x2 ## &lt;chr&gt; &lt;dbl&gt; ## 1 B 2 ## 2 A 1 ## 3 C 3 ## 4 D 4 5.5.2.3 Setdiff A row of x, not in y, is returned. Setdiff dplyr Method y &lt;- dplyr :: data_frame ( x1 = c ( &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ) , x2 = c ( 1 , 2 , 3 ) ) z &lt;- dplyr :: data_frame ( x1 = c ( &quot;B&quot; , &quot;C&quot; , &quot;D&quot; ), x2 = c ( 2 , 3 , 4 ) ) dplyr :: setdiff ( y , z ) ## # A tibble: 1 x 2 ## x1 x2 ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 1 "],
["5-6-categorical-data.html", "5.6 Categorical Data", " 5.6 Categorical Data 5.6.1 Converting to Factor as.factor converts string, discrete integer and logical data to factor. Each unique value will make up the levels for the factor, (sorted alphabatically during creation time). Convert below string to factor, and the first element of the sorted unique value - D1 is the reference level. x = as.factor( c(&#39;D2&#39;, &#39;D1&#39;, &#39;D3&#39;, &#39;D3&#39;, &#39;D2&#39;, &#39;D1&#39;, &#39;D3&#39;) ) x ## [1] D2 D1 D3 D3 D2 D1 D3 ## Levels: D1 D2 D3 5.6.2 Releveling Factor relevel return a new factor with base reference changed. Notice current factor x has ’D1` as the reference. levels(x) ## [1] &quot;D1&quot; &quot;D2&quot; &quot;D3&quot; Change the reference to ‘D3’, return a new factor y = relevel(x, &#39;D3&#39;) levels(y) ## [1] &quot;D3&quot; &quot;D1&quot; &quot;D2&quot; 5.6.3 Dropping Levels Levels can be ‘squeezed’ if it contain levels that no longer have data in it. Original data below contain three levels, D1 D2 D3. After removing all ‘D2’ value from the factor, all three original levels still exist ! z = x[x!=&#39;D2&#39;] str(z) ## Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 3 3 1 3 Use droplevels to remove all unused levels. All value will be renumbered. z = droplevels(z) str(z) ## Factor w/ 2 levels &quot;D1&quot;,&quot;D3&quot;: 1 2 2 1 2 "],
["5-7-string-manipulation.html", "5.7 String Manipulation", " 5.7 String Manipulation 5.7.1 Extration 5.7.2 Removal 5.7.3 Concatenation "],
["5-8-date-manipulation.html", "5.8 Date Manipulation", " 5.8 Date Manipulation 5.8.1 Parsing Date When import date date from text file using read(), often date column are imported as string or factor. Note that lubridate::dmy,ymd can convert from string only, whereas as.Date can convert from both string and factor. Before Conversion, verify that all dates column are actually chr. str(my.df) ## &#39;data.frame&#39;: 10 obs. of 11 variables: ## $ id : Factor w/ 13 levels &quot;ID101&quot;,&quot;ID102&quot;,..: 1 2 3 4 5 6 7 8 9 10 ## $ dept : Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 2 3 1 1 3 2 1 3 2 ## $ gender : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 1 1 2 2 1 2 2 1 2 ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 159 166 163 ## $ date_birth : Factor w/ 10 levels &quot;1/7/1973&quot;,&quot;12/1/1997&quot;,..: 1 8 9 2 4 7 5 4 3 6 ## $ amount : int 100 121 152 133 143 155 117 143 155 117 ## $ date_last : Factor w/ 10 levels &quot;10/31/2015&quot;,&quot;11/1/2016&quot;,..: 6 9 1 2 10 4 8 10 3 7 ## $ date_first : Factor w/ 10 levels &quot;2011-06-15&quot;,&quot;2012-04-02&quot;,..: 6 7 9 10 3 5 8 1 2 4 ## $ birth_month: int 7 2 12 1 1 7 8 1 7 8 ## $ birth_year : int 1 28 31 12 2 26 21 2 13 24 ## - attr(*, &quot;na.action&quot;)=Class &#39;omit&#39; Named int [1:3] 11 12 13 ## .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;11&quot; &quot;12&quot; &quot;13&quot; Two ways to convert string to date: as.Date - convert vector into date data type. A format parameter has to be specified to match the source format. Otherwise as.Date will try default format of “%Y-%m-%d” then “%Y/%m/%d” lubridate::dmy, mdy, ymd - this is more elegant because manual format is not required. However, it converts only string data. If the data source is factor, convert it to string first In both methods, unmatched rows with unrecognized format will throw an error. my.df$date_birth = as.Date( my.df$date_birth, format = &quot;%d/%m/%Y&quot; ) # base R my.df$date_last = mdy( my.df$date_last ) # lubridate my.df$date_first = ymd( my.df$date_first ) # lubridate str(my.df) ## &#39;data.frame&#39;: 10 obs. of 11 variables: ## $ id : Factor w/ 13 levels &quot;ID101&quot;,&quot;ID102&quot;,..: 1 2 3 4 5 6 7 8 9 10 ## $ dept : Factor w/ 3 levels &quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;: 1 2 3 1 1 3 2 1 3 2 ## $ gender : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 1 1 2 2 1 2 2 1 2 ## $ weight : num 35 37.1 43.1 38.1 54.1 ... ## $ height : int 173 164 178 182 159 166 153 159 166 163 ## $ date_birth : Date, format: &quot;1973-07-01&quot; &quot;1980-02-28&quot; ... ## $ amount : int 100 121 152 133 143 155 117 143 155 117 ## $ date_last : Date, format: &quot;2016-02-29&quot; &quot;2017-04-01&quot; ... ## $ date_first : Date, format: &quot;2013-07-31&quot; &quot;2013-08-31&quot; ... ## $ birth_month: int 7 2 12 1 1 7 8 1 7 8 ## $ birth_year : int 1 28 31 12 2 26 21 2 13 24 ## - attr(*, &quot;na.action&quot;)=Class &#39;omit&#39; Named int [1:3] 11 12 13 ## .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;11&quot; &quot;12&quot; &quot;13&quot; 5.8.2 What Day/Month/Year lubridate has useful functions to return numeric day, month, year from date object. 5.8.2.1 What Day d1 = as.Date(&#39;2017-03-31&#39;) lubridate::day(d1) ## [1] 31 5.8.2.2 What Month lubridate::month(d1) ## [1] 3 5.8.2.3 What Year lubridate::year(d1) ## [1] 2017 5.8.3 Days/Months/Year Difference 5.8.3.1 Days Difference my.df$date_last my.df$date_first my.df$date_last - my.df$date_first ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; &quot;2012-06-15&quot; ## [6] &quot;2013-04-28&quot; &quot;2014-03-01&quot; &quot;2011-06-15&quot; &quot;2012-04-02&quot; &quot;2013-03-12&quot; ## Time differences in days ## [1] 943 1309 304 612 1568 943 1126 1934 2039 1096 5.8.3.2 Months Difference Combination of lubridate::interval and lubridate operator provides a integer vector of months elapsed between two date: - The result can be negative if first date parameter &gt; second date parameter - lubridate ‘intelligently’ knows interval is from end of month to end of month interval interval( ymd(&#39;2016-03-30&#39;), ymd(&#39;2016-04-29&#39;) ) %/% months(1) # end day no. &lt; begining day no. interval( ymd(&#39;2016-03-30&#39;), ymd(&#39;2016-04-30&#39;) ) %/% months(1) # end day no. == beginning day no. interval( ymd(&#39;2016-03-31&#39;), ymd(&#39;2016-04-30&#39;) ) %/% months(1) # end of month to end of month ## [1] 0 ## [1] 1 ## [1] 1 Apply this to data frame / vector. my.df$date_first my.df$date_last interval( my.df$date_first, my.df$date_last ) %/% months(1) ## [1] &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; &quot;2012-06-15&quot; ## [6] &quot;2013-04-28&quot; &quot;2014-03-01&quot; &quot;2011-06-15&quot; &quot;2012-04-02&quot; &quot;2013-03-12&quot; ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] 31 43 10 20 51 30 36 63 66 36 5.8.3.3 Years Difference Use lubridate::year function to find the year (integer) of a given date. Difference of the year() results from the birthdate and current date is the Age. year(now()) - year(my.df$date_birth) ## [1] 44 37 39 20 35 44 32 35 42 35 However in insurance industry, only a full year is considred for age. interval( ymd(&#39;2016-02-29&#39;), ymd(&#39;2017-02-27&#39;) ) %/% years(1) # a day short for a year interval( ymd(&#39;2016-02-29&#39;), ymd(&#39;2017-02-28&#39;) ) %/% years(1) # EoM to EoM ## [1] 0 ## [1] 1 Apply this to data frame / vector. my.df$date_first my.df$date_last interval( my.df$date_first, my.df$date_last ) %/% years(1) ## [1] &quot;2013-07-31&quot; &quot;2013-08-31&quot; &quot;2014-12-31&quot; &quot;2015-02-28&quot; &quot;2012-06-15&quot; ## [6] &quot;2013-04-28&quot; &quot;2014-03-01&quot; &quot;2011-06-15&quot; &quot;2012-04-02&quot; &quot;2013-03-12&quot; ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] 2 3 0 1 4 2 3 5 5 3 5.8.4 Days/Monhts/Years Later Adding days to a date is simple. Just + days(123) for 123 days later. However, adding months and years is tricky, because certain months are shorter. Good solution is to use lubridate::%m+% operator. 5.8.4.1 Days Later Adding days is as simple as add number of days to the date variables. my.df$date_last ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; 5.8.4.2 Months Later Adding month(s) is tricky on the last day of month. Use lubridate operator for correct solution, because it takes cares of last day of month including February of leap years. my.df$date_last my.df$date_last + months(1) # 1 month later, bad solution, can result in &lt;NA&gt; my.df$date_last %m+% months(1) # 1 month later, good solution ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] &quot;2016-03-29&quot; &quot;2017-05-01&quot; NA &quot;2016-12-01&quot; &quot;2016-10-30&quot; ## [6] &quot;2015-12-27&quot; NA &quot;2016-10-30&quot; &quot;2017-12-01&quot; &quot;2016-04-12&quot; ## [1] &quot;2016-03-29&quot; &quot;2017-05-01&quot; &quot;2015-11-30&quot; &quot;2016-12-01&quot; &quot;2016-10-30&quot; ## [6] &quot;2015-12-27&quot; &quot;2017-04-30&quot; &quot;2016-10-30&quot; &quot;2017-12-01&quot; &quot;2016-04-12&quot; 5.8.4.3 Years Later Adding year(s) is similar to adding month(s) above. my.df$date_last my.df$date_last + years(1) # 1 year later, bad solution my.df$date_last %m+% years(1) # 1 year later, good solution ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] NA &quot;2018-04-01&quot; &quot;2016-10-31&quot; &quot;2017-11-01&quot; &quot;2017-09-30&quot; ## [6] &quot;2016-11-27&quot; &quot;2018-03-31&quot; &quot;2017-09-30&quot; &quot;2018-11-01&quot; &quot;2017-03-12&quot; ## [1] &quot;2017-02-28&quot; &quot;2018-04-01&quot; &quot;2016-10-31&quot; &quot;2017-11-01&quot; &quot;2017-09-30&quot; ## [6] &quot;2016-11-27&quot; &quot;2018-03-31&quot; &quot;2017-09-30&quot; &quot;2018-11-01&quot; &quot;2017-03-12&quot; 5.8.5 Last Day of Month lubridate::ceiling_date rounds up the date to the nearest unit. When rounding up a date to the **next nearest month*, it results the first day of next month. my.df$date_last ceiling_date(my.df$date_last, &quot;month&quot;) ## [1] &quot;2016-02-29&quot; &quot;2017-04-01&quot; &quot;2015-10-31&quot; &quot;2016-11-01&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-27&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-01&quot; &quot;2016-03-12&quot; ## [1] &quot;2016-03-01&quot; &quot;2017-05-01&quot; &quot;2015-11-01&quot; &quot;2016-12-01&quot; &quot;2016-10-01&quot; ## [6] &quot;2015-12-01&quot; &quot;2017-04-01&quot; &quot;2016-10-01&quot; &quot;2017-12-01&quot; &quot;2016-04-01&quot; Substracting this date by one will return last day of the month. ceiling_date(my.df$date_last, &quot;month&quot;) - days(1) ## [1] &quot;2016-02-29&quot; &quot;2017-04-30&quot; &quot;2015-10-31&quot; &quot;2016-11-30&quot; &quot;2016-09-30&quot; ## [6] &quot;2015-11-30&quot; &quot;2017-03-31&quot; &quot;2016-09-30&quot; &quot;2017-11-30&quot; &quot;2016-03-31&quot; "],
["5-9-number-manipulation.html", "5.9 Number Manipulation", " 5.9 Number Manipulation 5.9.1 Sample Data Scaling section will use sample data generated as below: set.seed(1234) num.df = data.frame( id = paste(&#39;ID_&#39;, 1:10, sep = &#39;&#39;), value1 = sample(50:100, 10), value2 = sample(10:50, 10), stringsAsFactors = F ) num.df ## id value1 value2 ## 1 ID_1 55 38 ## 2 ID_2 81 31 ## 3 ID_3 79 21 ## 4 ID_4 98 45 ## 5 ID_5 90 20 ## 6 ID_6 97 40 ## 7 ID_7 50 46 ## 8 ID_8 60 19 ## 9 ID_9 78 16 ## 10 ID_10 71 17 5.9.2 Z-Score Scaling scale apply transformation column-wise, for columns within matrix or dataframe scale return a matrix Non-numeric data will results in error, so filter the variables properly scale (x, center=T, scale=T) # default S-Score transformation \\(\\quad\\) center = T (default) means value minus with mean \\(\\quad\\) scale = T (default) means value divide by sd \\(\\quad\\) \\(\\quad\\) output scaled:center --&gt; mean \\(\\quad\\) \\(\\quad\\) output scaled:scale --&gt; sd scale( num.df[,2:3] ) ## value1 value2 ## [1,] -1.2399685 0.7216391 ## [2,] 0.3025761 0.1410099 ## [3,] 0.1839188 -0.6884603 ## [4,] 1.3111629 1.3022682 ## [5,] 0.8365338 -0.7714073 ## [6,] 1.2518343 0.8875331 ## [7,] -1.5366117 1.3852152 ## [8,] -0.9433254 -0.8543543 ## [9,] 0.1245901 -1.1031954 ## [10,] -0.2907103 -1.0202483 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 75.9 29.3 ## attr(,&quot;scaled:scale&quot;) ## value1 value2 ## 16.85527 12.05589 scale( num.df[,2:3], scale=F ) ## value1 value2 ## [1,] -20.9 8.7 ## [2,] 5.1 1.7 ## [3,] 3.1 -8.3 ## [4,] 22.1 15.7 ## [5,] 14.1 -9.3 ## [6,] 21.1 10.7 ## [7,] -25.9 16.7 ## [8,] -15.9 -10.3 ## [9,] 2.1 -13.3 ## [10,] -4.9 -12.3 ## attr(,&quot;scaled:center&quot;) ## value1 value2 ## 75.9 29.3 5.9.3 Min Max Scaling Min-Max scaling will transform all numbers between 0 and 1. Easiest way to perform this transformation is to write a function then apply. min_max = function(x){(x-min(x))/(max(x)-min(x))} apply( num.df[,2:3], MARGIN = 2, FUN = min_max ) ## 2 means column-wise ## value1 value2 ## [1,] 0.1041667 0.73333333 ## [2,] 0.6458333 0.50000000 ## [3,] 0.6041667 0.16666667 ## [4,] 1.0000000 0.96666667 ## [5,] 0.8333333 0.13333333 ## [6,] 0.9791667 0.80000000 ## [7,] 0.0000000 1.00000000 ## [8,] 0.2083333 0.10000000 ## [9,] 0.5833333 0.00000000 ## [10,] 0.4375000 0.03333333 5.9.4 Transformation Model Sometimes we wanted to preprocess a dataaset (eg. standardize the data), and apply to the ‘transofmration model’ to other dataset The transformation model is built with one set of data and it store parameters and methods to be used for future dataset transformation care::preProcess returns a model object 5.9.4.1 Build The Transformation Model caret::preProcess provides advance transformation, default to Z-Score scaling None numerical data will be ignored automatically preProcess(x, method = c(&quot;center&quot;, &quot;scale&quot;), \\(\\quad\\) thresh = 0.95, pcaComp = NULL, na.remove = TRUE, k = 5, \\(\\quad\\) knnSummary = mean, outcome = NULL, fudge = 0.2, numUnique = 3, \\(\\quad\\) verbose = FALSE, freqCut = 95/5, uniqueCut = 10, cutoff = 0.9, ...) \\(\\quad\\) method: &quot;BoxCox&quot;, &quot;YeoJohnson&quot;, &quot;expoTrans&quot;, &quot;center&quot;, &quot;scale&quot;, &quot;range&quot;, &quot;knnImpute&quot;, &quot;bagImpute&quot;, &quot;medianImpute&quot;, &quot;pca&quot;, &quot;ica&quot;, &quot;spatialSign&quot;, &quot;corr&quot;, &quot;zv&quot;, &quot;nzv&quot;, and &quot;conditionalX&quot; \\(\\quad\\) ` We will use default standardization method by default (center, scale), hence$mean and $std are calculated $method indicates what functions being used to what variables, as well as ignored variables Base on this transformation model, we can apply to any numerical data spl = sample(1:nrow(num.df), nrow(num.df)*0.7, rep=FALSE) train = num.df[spl,] test = num.df[-spl,] fit.preproc = preProcess(train) str(fit.preproc) ## List of 20 ## $ dim : int [1:2] 7 3 ## $ bc : NULL ## $ yj : NULL ## $ et : NULL ## $ invHyperbolicSine: NULL ## $ mean : Named num [1:2] 77.3 27.1 ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;value1&quot; &quot;value2&quot; ## $ std : Named num [1:2] 15.3 11 ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;value1&quot; &quot;value2&quot; ## $ ranges : NULL ## $ rotation : NULL ## $ method :List of 3 ## ..$ center: chr [1:2] &quot;value1&quot; &quot;value2&quot; ## ..$ scale : chr [1:2] &quot;value1&quot; &quot;value2&quot; ## ..$ ignore: chr &quot;id&quot; ## $ thresh : num 0.95 ## $ pcaComp : NULL ## $ numComp : NULL ## $ ica : NULL ## $ wildcards :List of 2 ## ..$ PCA: chr(0) ## ..$ ICA: chr(0) ## $ k : num 5 ## $ knnSummary :function (x, ...) ## $ bagImp : NULL ## $ median : NULL ## $ data : NULL ## - attr(*, &quot;class&quot;)= chr &quot;preProcess&quot; 5.9.4.2 Apply Transformation Predict, or rather tranform the data using the model Perfect standardization on the train data (mean==zero, sd==1), because model is built based on the train data summary(predict(fit.preproc, train)) ## id value1 value2 ## Length:7 Min. :-1.4572 Min. :-1.0096 ## Class :character 1st Qu.:-0.5418 1st Qu.:-0.6925 ## Mode :character Median : 0.1121 Median :-0.5566 ## Mean : 0.0000 Mean : 0.0000 ## 3rd Qu.: 0.5371 3rd Qu.: 0.6666 ## Max. : 1.3544 Max. : 1.6180 When apply model to test data, all values are substract by train data’s mean, and train data’s std summary(predict(fit.preproc, test)) ## id value1 value2 ## Length:3 Min. :-1.784 Min. :-0.9190 ## Class :character 1st Qu.:-1.098 1st Qu.: 0.1230 ## Mode :character Median :-0.411 Median : 1.1649 ## Mean :-0.302 Mean : 0.6515 ## 3rd Qu.: 0.439 3rd Qu.: 1.4368 ## Max. : 1.289 Max. : 1.7086 Refernce to Other Types of Transformation preProcess Reference "],
["5-10-artificial-grouping.html", "5.10 Artificial Grouping", " 5.10 Artificial Grouping Artificial group can be created based on existing numeric data. Such as age_group based on age. 5.10.1 Grouping with Numeric Breakpoints Simulate data with x,y,z variables. p simulates priority scoring. x = rnorm(10, mean = 10) y = rnorm(10, mean = 10) p = x * y Articial groups is created first by identifying the number of groups, generate the break points vector, then cut the data base on break points and return factor as output. Automatically calculate breakpoints by distributing numbers into the min-max range, in low to high order: num_groups = 4 breakPoints = seq(min(p), max(p), length.out = num_groups + 1) breakPoints ## [1] 80.37521 90.24923 100.12325 109.99727 119.87129 cut ( x, breaks, right = TRUE, include.lowest = FALSE) \\(\\quad\\) x: numeric vector to be cutted \\(\\quad\\) breaks: numeric vector ranging from low to high (in order) \\(\\quad\\) include.lowest: FALSE - ommit element matching lowest number in breaks \\(\\quad\\) right: TRUE - close end on right;open end on left The result from cut is factor based on order from breakPoints. Therefore, once convert into numeric, the group number is in order of low to high accoriding to breakPoints. Verify that group (g) has been assigned for each priority (p). g = as.numeric( cut( p, breakPoints, include.lowest=TRUE)) data.frame(p,g) ## p g ## 1 113.27225 4 ## 2 89.14491 1 ## 3 89.06992 1 ## 4 100.29733 3 ## 5 107.15799 3 ## 6 99.87367 2 ## 7 119.87129 4 ## 8 85.81140 1 ## 9 80.37521 1 ## 10 105.48452 3 5.10.2 Grouping based on Custom Criteria creates a logical vector, indicating. Ratio specified in SplitRatio will be have value ‘TRUE’ "],
["5-11-radom-dataset-splitting.html", "5.11 Radom Dataset Splitting", " 5.11 Radom Dataset Splitting When we have only ONE dataset, we can split them into training and testing, example 0.7/0.3 split. 5.11.1 Simple Random Split 5.11.1.1 Verify Dataset Verify the total number of rows before splitting. nrow(my.df) ## [1] 10 5.11.1.2 Create Randomized Row Numbers Vector Randomly pick 60% of elements from a bag of all row numbers, with no replacement. Verify that 60% of full observations are picked. set.seed(8034) train.rows = sample( 1:nrow(my.df), 0.6 * nrow(my.df) ) length(train.rows) ## [1] 6 train.rows ## [1] 5 7 4 3 1 10 5.11.1.3 Split Data Into Two Sets Subseting for the training data, using [,] row selection method. my.df [train.rows, ] # Training Data (0.6) ## dept gender weight height date_birth amount date_last date_first ## 5 D1 Male 54.12340 159 1982-01-02 143 2016-09-30 2012-06-15 ## 7 D2 Male 49.12346 153 1985-08-21 117 2017-03-31 2014-03-01 ## 4 D1 Male 38.12300 182 1997-01-12 133 2016-11-01 2015-02-28 ## 3 D3 Female 43.12000 178 1978-12-31 152 2015-10-31 2014-12-31 ## 1 D1 Male 35.00000 173 1973-07-01 100 2016-02-29 2013-07-31 ## 10 D2 Male 63.20000 163 1982-08-24 117 2016-03-12 2013-03-12 ## birth_month birth_year ## 5 1 2 ## 7 8 21 ## 4 1 12 ## 3 12 31 ## 1 7 1 ## 10 8 24 Subsetting the test data by negating the splitting row numbers. my.df [-train.rows, ] # Training Data (0.4) ## dept gender weight height date_birth amount date_last date_first ## 2 D2 Female 37.10000 164 1980-02-28 121 2017-04-01 2013-08-31 ## 6 D3 Female 34.12345 166 1973-07-26 155 2015-11-27 2013-04-28 ## 8 D1 Male 50.20000 159 1982-01-02 143 2016-09-30 2011-06-15 ## 9 D3 Female 59.10000 166 1975-07-13 155 2017-11-01 2012-04-02 ## birth_month birth_year ## 2 2 28 ## 6 7 26 ## 8 1 2 ## 9 7 13 5.11.2 Random Split (Maintaining Data Value Ratio) Sometimes we want to maintain the original data value ratio. For example, if original factor variable contains 40%A, 30%B and 30%C, and we want the splitted sample to maintain 40-30-30 ratio. For prediction on classification/clustering, usually the dependent variable (categorical/binary) is used as spliting parameter For regression prediction of continuous data, it doesn’t make sense to use dependent variable for spliting, as the ratio cannot be determined with continuous data Maintaining the ratio is key difference to sample approach which does not care about the original balance 5.11.2.1 Verify Data Value Ratio We are going to split the data frame, while maintaining the ratio of dept variable. Here is distribution dept variable. table(my.df[,c(&#39;dept&#39;)]) ## ## D1 D2 D3 ## 4 3 3 5.11.2.2 Create The Spliting Logical Vector caTools::sample.split is the right tool for this job: It takes a vector (or a column from a data.frame), randomly assign TRUE (training data) and FALSE (test data) according to a specified ratio While doing so, it automatically maintaining the data value ratio within the split It returns a logical vector for data subsetting purpose sample.split (Y, SplitRatio = 2/3, group = NULL) \\(\\quad\\) Y = vector, of which ratio of value to be maintained \\(\\quad\\) SplitRatio = ratio of split set.seed(8034) spl = sample.split(my.df$dept, 0.6) # randomly 0.6 set to TRUE, remaining FALSE spl ## [1] FALSE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE 5.11.2.3 Split Data Into Two Sets Subseting for the training data, using subset or [,] row selection method # my.df[split.data,] # alternative s1 = subset( my.df, spl ) # Training Data (0.6) table(s1[,&#39;dept&#39;]) ## ## D1 D2 D3 ## 2 2 2 Subsetting the test data by negating the splitting logical vector. # my.df[!spl,] # alternative s2 = subset( my.df, !spl ) # Testing Data (0.4) table(s2[,&#39;dept&#39;]) ## ## D1 D2 D3 ## 2 1 1 -->"]
]
